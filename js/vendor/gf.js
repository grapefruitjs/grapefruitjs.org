// Combined file generated by uRequire v0.5.0, with help from r.js & almond
(function (){
  var __isAMD = (typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;


  var __global = null,
      __nodeRequire = function(){};

  if (__isNode) {
      __nodeRequire = require;
      __global = global;
  } else {
      __global = window;
  };

  factory = function() {
/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

(function (window) {
  define(
  'utils/EventEmitter',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = function() {
    this._events = this._events || {};
    this.addEventListener = this.on = function(type, listener) {
        if (typeof listener !== "function") throw new TypeError("listener must be a function");
        if (!this._events) this._events = {};
        if (!this._events[type]) this._events[type] = listener; else if (typeof this._events[type] === "object") this._events[type].push(listener); else this._events[type] = [ this._events[type], listener ];
        return this;
    };
    this.dispatchEvent = this.emit = function(type) {
        var handler, len, args, i, listeners;
        if (!this._events) this._events = {};
        handler = this._events[type];
        if (typeof handler === "undefined") return false;
        if (typeof handler === "function") {
            switch (arguments.length) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                handler.apply(this, args);
            }
        } else if (typeof handler === "object") {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++) args[i - 1] = arguments[i];
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++) listeners[i].apply(this, args);
        }
        return this;
    };
    this.removeEventListener = this.off = function(type, listener) {
        var list, position, length, i;
        if (typeof listener !== "function") throw new TypeError("listener must be a function");
        if (!this._events[type]) return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || typeof list.listener === "function" && list.listener === listener) {
            this._events[type] = undefined;
        } else if (typeof list === "object") {
            for (i = length; i-- > 0; ) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                    position = i;
                    break;
                }
            }
            if (position < 0) return this;
            if (list.length === 1) {
                list.length = 0;
                this._events[type] = undefined;
            } else {
                list.splice(position, 1);
            }
        }
    };
    this.once = function(type, listener) {
        if (typeof listener !== "function") throw new TypeError("listener must be a function");
        function g() {
            this.off(type, g);
            listener.apply(this, arguments);
        }
        g.listener = listener;
        this.on(type, g);
        return this;
    };
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'utils/inherit',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = function(child, parent, proto) {
    proto = proto || {};
    var desc = {};
    [ child.prototype, proto ].forEach(function(s) {
        Object.getOwnPropertyNames(s).forEach(function(k) {
            desc[k] = Object.getOwnPropertyDescriptor(s, k);
        });
    });
    desc.constructor = {
        value: child,
        enumerable: false,
        writable: true,
        configurable: true
    };
    child.prototype = Object.create(parent.prototype, desc);
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('math/Vector',['require', 'exports', 'module', '../utils/inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit");

var Vector = module.exports = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
};

inherit(Vector, Object, {
    set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index);
        }
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    },
    add: function(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
    },
    sub: function(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    },
    multiplyScalar: function(s) {
        this.x *= s;
        this.y *= s;
        return this;
    },
    divideScalar: function(s) {
        if (s !== 0) {
            this.x /= s;
            this.y /= s;
        } else {
            this.set(0, 0);
        }
        return this;
    },
    min: function(v) {
        if (this.x > v.x) {
            this.x = v.x;
        }
        if (this.y > v.y) {
            this.y = v.y;
        }
        return this;
    },
    max: function(v) {
        if (this.x < v.x) {
            this.x = v.x;
        }
        if (this.y < v.y) {
            this.y = v.y;
        }
        return this;
    },
    clamp: function(min, max) {
        if (this.x < min.x) {
            this.x = min.x;
        } else if (this.x > max.x) {
            this.x = max.x;
        }
        if (this.y < min.y) {
            this.y = min.y;
        } else if (this.y > max.y) {
            this.y = max.y;
        }
        return this;
    },
    negate: function() {
        return this.multiplyScalar(-1);
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    },
    setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
            this.multiplyScalar(l / oldLength);
        }
        return this;
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y;
    },
    toArray: function() {
        return [ this.x, this.y ];
    },
    clone: function() {
        return new Vector(this.x, this.y);
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'vendor/pixi',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
(function() {
    var root = this;
    var PIXI = PIXI || {};
    PIXI.Point = function(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    };
    PIXI.Point.prototype.clone = function() {
        return new PIXI.Point(this.x, this.y);
    };
    PIXI.Point.prototype.constructor = PIXI.Point;
    PIXI.Rectangle = function(x, y, width, height) {
        this.x = x || 0;
        this.y = y || 0;
        this.width = width || 0;
        this.height = height || 0;
    };
    PIXI.Rectangle.prototype.clone = function() {
        return new PIXI.Rectangle(this.x, this.y, this.width, this.height);
    };
    PIXI.Rectangle.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) return false;
        var x1 = this.x;
        if (x >= x1 && x <= x1 + this.width) {
            var y1 = this.y;
            if (y >= y1 && y <= y1 + this.height) {
                return true;
            }
        }
        return false;
    };
    PIXI.Rectangle.prototype.constructor = PIXI.Rectangle;
    PIXI.Polygon = function(points) {
        if (!(points instanceof Array)) points = Array.prototype.slice.call(arguments);
        if (typeof points[0] === "number") {
            var p = [];
            for (var i = 0, il = points.length; i < il; i += 2) {
                p.push(new PIXI.Point(points[i], points[i + 1]));
            }
            points = p;
        }
        this.points = points;
    };
    PIXI.Polygon.prototype.clone = function() {
        var points = [];
        for (var i = 0; i < this.points.length; i++) {
            points.push(this.points[i].clone());
        }
        return new PIXI.Polygon(points);
    };
    PIXI.Polygon.prototype.contains = function(x, y) {
        var inside = false;
        for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
            var xi = this.points[i].x, yi = this.points[i].y, xj = this.points[j].x, yj = this.points[j].y, intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
            if (intersect) inside = !inside;
        }
        return inside;
    };
    PIXI.Polygon.prototype.constructor = PIXI.Polygon;
    PIXI.Circle = function(x, y, radius) {
        this.x = x || 0;
        this.y = y || 0;
        this.radius = radius || 0;
    };
    PIXI.Circle.prototype.clone = function() {
        return new PIXI.Circle(this.x, this.y, this.radius);
    };
    PIXI.Circle.prototype.contains = function(x, y) {
        if (this.radius <= 0) return false;
        var dx = this.x - x, dy = this.y - y, r2 = this.radius * this.radius;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
    };
    PIXI.Circle.prototype.constructor = PIXI.Circle;
    PIXI.Ellipse = function(x, y, width, height) {
        this.x = x || 0;
        this.y = y || 0;
        this.width = width || 0;
        this.height = height || 0;
    };
    PIXI.Ellipse.prototype.clone = function() {
        return new PIXI.Ellipse(this.x, this.y, this.width, this.height);
    };
    PIXI.Ellipse.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) return false;
        var normx = (x - this.x) / this.width - .5, normy = (y - this.y) / this.height - .5;
        normx *= normx;
        normy *= normy;
        return normx + normy < .25;
    };
    PIXI.Ellipse.getBounds = function() {
        return new PIXI.Rectangle(this.x, this.y, this.width, this.height);
    };
    PIXI.Ellipse.prototype.constructor = PIXI.Ellipse;
    function determineMatrixArrayType() {
        PIXI.Matrix = typeof Float32Array !== "undefined" ? Float32Array : Array;
        return PIXI.Matrix;
    }
    determineMatrixArrayType();
    PIXI.mat3 = {};
    PIXI.mat3.create = function() {
        var matrix = new PIXI.Matrix(9);
        matrix[0] = 1;
        matrix[1] = 0;
        matrix[2] = 0;
        matrix[3] = 0;
        matrix[4] = 1;
        matrix[5] = 0;
        matrix[6] = 0;
        matrix[7] = 0;
        matrix[8] = 1;
        return matrix;
    };
    PIXI.mat3.identity = function(matrix) {
        matrix[0] = 1;
        matrix[1] = 0;
        matrix[2] = 0;
        matrix[3] = 0;
        matrix[4] = 1;
        matrix[5] = 0;
        matrix[6] = 0;
        matrix[7] = 0;
        matrix[8] = 1;
        return matrix;
    };
    PIXI.mat4 = {};
    PIXI.mat4.create = function() {
        var matrix = new PIXI.Matrix(16);
        matrix[0] = 1;
        matrix[1] = 0;
        matrix[2] = 0;
        matrix[3] = 0;
        matrix[4] = 0;
        matrix[5] = 1;
        matrix[6] = 0;
        matrix[7] = 0;
        matrix[8] = 0;
        matrix[9] = 0;
        matrix[10] = 1;
        matrix[11] = 0;
        matrix[12] = 0;
        matrix[13] = 0;
        matrix[14] = 0;
        matrix[15] = 1;
        return matrix;
    };
    PIXI.mat3.multiply = function(mat, mat2, dest) {
        if (!dest) {
            dest = mat;
        }
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a10 = mat[3], a11 = mat[4], a12 = mat[5], a20 = mat[6], a21 = mat[7], a22 = mat[8], b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b10 = mat2[3], b11 = mat2[4], b12 = mat2[5], b20 = mat2[6], b21 = mat2[7], b22 = mat2[8];
        dest[0] = b00 * a00 + b01 * a10 + b02 * a20;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22;
        dest[3] = b10 * a00 + b11 * a10 + b12 * a20;
        dest[4] = b10 * a01 + b11 * a11 + b12 * a21;
        dest[5] = b10 * a02 + b11 * a12 + b12 * a22;
        dest[6] = b20 * a00 + b21 * a10 + b22 * a20;
        dest[7] = b20 * a01 + b21 * a11 + b22 * a21;
        dest[8] = b20 * a02 + b21 * a12 + b22 * a22;
        return dest;
    };
    PIXI.mat3.clone = function(mat) {
        var matrix = new PIXI.Matrix(9);
        matrix[0] = mat[0];
        matrix[1] = mat[1];
        matrix[2] = mat[2];
        matrix[3] = mat[3];
        matrix[4] = mat[4];
        matrix[5] = mat[5];
        matrix[6] = mat[6];
        matrix[7] = mat[7];
        matrix[8] = mat[8];
        return matrix;
    };
    PIXI.mat3.transpose = function(mat, dest) {
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a12 = mat[5];
            mat[1] = mat[3];
            mat[2] = mat[6];
            mat[3] = a01;
            mat[5] = mat[7];
            mat[6] = a02;
            mat[7] = a12;
            return mat;
        }
        dest[0] = mat[0];
        dest[1] = mat[3];
        dest[2] = mat[6];
        dest[3] = mat[1];
        dest[4] = mat[4];
        dest[5] = mat[7];
        dest[6] = mat[2];
        dest[7] = mat[5];
        dest[8] = mat[8];
        return dest;
    };
    PIXI.mat3.toMat4 = function(mat, dest) {
        if (!dest) {
            dest = PIXI.mat4.create();
        }
        dest[15] = 1;
        dest[14] = 0;
        dest[13] = 0;
        dest[12] = 0;
        dest[11] = 0;
        dest[10] = mat[8];
        dest[9] = mat[7];
        dest[8] = mat[6];
        dest[7] = 0;
        dest[6] = mat[5];
        dest[5] = mat[4];
        dest[4] = mat[3];
        dest[3] = 0;
        dest[2] = mat[2];
        dest[1] = mat[1];
        dest[0] = mat[0];
        return dest;
    };
    PIXI.mat4.create = function() {
        var matrix = new PIXI.Matrix(16);
        matrix[0] = 1;
        matrix[1] = 0;
        matrix[2] = 0;
        matrix[3] = 0;
        matrix[4] = 0;
        matrix[5] = 1;
        matrix[6] = 0;
        matrix[7] = 0;
        matrix[8] = 0;
        matrix[9] = 0;
        matrix[10] = 1;
        matrix[11] = 0;
        matrix[12] = 0;
        matrix[13] = 0;
        matrix[14] = 0;
        matrix[15] = 1;
        return matrix;
    };
    PIXI.mat4.transpose = function(mat, dest) {
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3], a12 = mat[6], a13 = mat[7], a23 = mat[11];
            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }
        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };
    PIXI.mat4.multiply = function(mat, mat2, dest) {
        if (!dest) {
            dest = mat;
        }
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
        var b0 = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];
        dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return dest;
    };
    PIXI.DisplayObject = function() {
        this.last = this;
        this.first = this;
        this.position = new PIXI.Point;
        this.scale = new PIXI.Point(1, 1);
        this.pivot = new PIXI.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = true;
        this.hitArea = null;
        this.buttonMode = false;
        this.renderable = false;
        this.parent = null;
        this.stage = null;
        this.worldAlpha = 1;
        this._interactive = false;
        this.worldTransform = PIXI.mat3.create();
        this.localTransform = PIXI.mat3.create();
        this.color = [];
        this.dynamic = true;
        this._sr = 0;
        this._cr = 1;
    };
    PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;
    PIXI.DisplayObject.prototype.setInteractive = function(interactive) {
        this.interactive = interactive;
    };
    Object.defineProperty(PIXI.DisplayObject.prototype, "interactive", {
        get: function() {
            return this._interactive;
        },
        set: function(value) {
            this._interactive = value;
            if (this.stage) this.stage.dirty = true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask;
        },
        set: function(value) {
            this._mask = value;
            if (value) {
                this.addFilter(value);
            } else {
                this.removeFilter();
            }
        }
    });
    PIXI.DisplayObject.prototype.addFilter = function(mask) {
        if (this.filter) return;
        this.filter = true;
        var start = new PIXI.FilterBlock;
        var end = new PIXI.FilterBlock;
        start.mask = mask;
        end.mask = mask;
        start.first = start.last = this;
        end.first = end.last = this;
        start.open = true;
        var childFirst = start;
        var childLast = start;
        var nextObject;
        var previousObject;
        previousObject = this.first._iPrev;
        if (previousObject) {
            nextObject = previousObject._iNext;
            childFirst._iPrev = previousObject;
            previousObject._iNext = childFirst;
        } else {
            nextObject = this;
        }
        if (nextObject) {
            nextObject._iPrev = childLast;
            childLast._iNext = nextObject;
        }
        var childFirst = end;
        var childLast = end;
        var nextObject = null;
        var previousObject = null;
        previousObject = this.last;
        nextObject = previousObject._iNext;
        if (nextObject) {
            nextObject._iPrev = childLast;
            childLast._iNext = nextObject;
        }
        childFirst._iPrev = previousObject;
        previousObject._iNext = childFirst;
        var updateLast = this;
        var prevLast = this.last;
        while (updateLast) {
            if (updateLast.last == prevLast) {
                updateLast.last = end;
            }
            updateLast = updateLast.parent;
        }
        this.first = start;
        if (this.__renderGroup) {
            this.__renderGroup.addFilterBlocks(start, end);
        }
        mask.renderable = false;
    };
    PIXI.DisplayObject.prototype.removeFilter = function() {
        if (!this.filter) return;
        this.filter = false;
        var startBlock = this.first;
        var nextObject = startBlock._iNext;
        var previousObject = startBlock._iPrev;
        if (nextObject) nextObject._iPrev = previousObject;
        if (previousObject) previousObject._iNext = nextObject;
        this.first = startBlock._iNext;
        var lastBlock = this.last;
        var nextObject = lastBlock._iNext;
        var previousObject = lastBlock._iPrev;
        if (nextObject) nextObject._iPrev = previousObject;
        previousObject._iNext = nextObject;
        var tempLast = lastBlock._iPrev;
        var updateLast = this;
        while (updateLast.last == lastBlock) {
            updateLast.last = tempLast;
            updateLast = updateLast.parent;
            if (!updateLast) break;
        }
        var mask = startBlock.mask;
        mask.renderable = true;
        if (this.__renderGroup) {
            this.__renderGroup.removeFilterBlocks(startBlock, lastBlock);
        }
    };
    PIXI.DisplayObject.prototype.updateTransform = function() {
        if (this.rotation !== this.rotationCache) {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation);
        }
        var localTransform = this.localTransform;
        var parentTransform = this.parent.worldTransform;
        var worldTransform = this.worldTransform;
        localTransform[0] = this._cr * this.scale.x;
        localTransform[1] = -this._sr * this.scale.y;
        localTransform[3] = this._sr * this.scale.x;
        localTransform[4] = this._cr * this.scale.y;
        var px = this.pivot.x;
        var py = this.pivot.y;
        var a00 = localTransform[0], a01 = localTransform[1], a02 = this.position.x - localTransform[0] * px - py * localTransform[1], a10 = localTransform[3], a11 = localTransform[4], a12 = this.position.y - localTransform[4] * py - px * localTransform[3], b00 = parentTransform[0], b01 = parentTransform[1], b02 = parentTransform[2], b10 = parentTransform[3], b11 = parentTransform[4], b12 = parentTransform[5];
        localTransform[2] = a02;
        localTransform[5] = a12;
        worldTransform[0] = b00 * a00 + b01 * a10;
        worldTransform[1] = b00 * a01 + b01 * a11;
        worldTransform[2] = b00 * a02 + b01 * a12 + b02;
        worldTransform[3] = b10 * a00 + b11 * a10;
        worldTransform[4] = b10 * a01 + b11 * a11;
        worldTransform[5] = b10 * a02 + b11 * a12 + b12;
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this.vcount = PIXI.visibleCount;
    };
    PIXI.visibleCount = 0;
    PIXI.DisplayObjectContainer = function() {
        PIXI.DisplayObject.call(this);
        this.children = [];
    };
    PIXI.DisplayObjectContainer.prototype = Object.create(PIXI.DisplayObject.prototype);
    PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;
    PIXI.DisplayObjectContainer.prototype.addChild = function(child) {
        if (child.parent != undefined) {
            child.parent.removeChild(child);
        }
        child.parent = this;
        this.children.push(child);
        if (this.stage) {
            var tmpChild = child;
            do {
                if (tmpChild.interactive) this.stage.dirty = true;
                tmpChild.stage = this.stage;
                tmpChild = tmpChild._iNext;
            } while (tmpChild);
        }
        var childFirst = child.first;
        var childLast = child.last;
        var nextObject;
        var previousObject;
        if (this.filter) {
            previousObject = this.last._iPrev;
        } else {
            previousObject = this.last;
        }
        nextObject = previousObject._iNext;
        var updateLast = this;
        var prevLast = previousObject;
        while (updateLast) {
            if (updateLast.last == prevLast) {
                updateLast.last = child.last;
            }
            updateLast = updateLast.parent;
        }
        if (nextObject) {
            nextObject._iPrev = childLast;
            childLast._iNext = nextObject;
        }
        childFirst._iPrev = previousObject;
        previousObject._iNext = childFirst;
        if (this.__renderGroup) {
            if (child.__renderGroup) child.__renderGroup.removeDisplayObjectAndChildren(child);
            this.__renderGroup.addDisplayObjectAndChildren(child);
        }
    };
    PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index) {
        if (index >= 0 && index <= this.children.length) {
            if (child.parent != undefined) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            if (this.stage) {
                var tmpChild = child;
                do {
                    if (tmpChild.interactive) this.stage.dirty = true;
                    tmpChild.stage = this.stage;
                    tmpChild = tmpChild._iNext;
                } while (tmpChild);
            }
            var childFirst = child.first;
            var childLast = child.last;
            var nextObject;
            var previousObject;
            if (index == this.children.length) {
                previousObject = this.last;
                var updateLast = this;
                var prevLast = this.last;
                while (updateLast) {
                    if (updateLast.last == prevLast) {
                        updateLast.last = child.last;
                    }
                    updateLast = updateLast.parent;
                }
            } else if (index == 0) {
                previousObject = this;
            } else {
                previousObject = this.children[index - 1].last;
            }
            nextObject = previousObject._iNext;
            if (nextObject) {
                nextObject._iPrev = childLast;
                childLast._iNext = nextObject;
            }
            childFirst._iPrev = previousObject;
            previousObject._iNext = childFirst;
            this.children.splice(index, 0, child);
            if (this.__renderGroup) {
                if (child.__renderGroup) child.__renderGroup.removeDisplayObjectAndChildren(child);
                this.__renderGroup.addDisplayObjectAndChildren(child);
            }
        } else {
            throw new Error(child + " The index " + index + " supplied is out of bounds " + this.children.length);
        }
    };
    PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2) {
        return;
    };
    PIXI.DisplayObjectContainer.prototype.getChildAt = function(index) {
        if (index >= 0 && index < this.children.length) {
            return this.children[index];
        } else {
            throw new Error(child + " Both the supplied DisplayObjects must be a child of the caller " + this);
        }
    };
    PIXI.DisplayObjectContainer.prototype.removeChild = function(child) {
        var index = this.children.indexOf(child);
        if (index !== -1) {
            var childFirst = child.first;
            var childLast = child.last;
            var nextObject = childLast._iNext;
            var previousObject = childFirst._iPrev;
            if (nextObject) nextObject._iPrev = previousObject;
            previousObject._iNext = nextObject;
            if (this.last == childLast) {
                var tempLast = childFirst._iPrev;
                var updateLast = this;
                while (updateLast.last == childLast.last) {
                    updateLast.last = tempLast;
                    updateLast = updateLast.parent;
                    if (!updateLast) break;
                }
            }
            childLast._iNext = null;
            childFirst._iPrev = null;
            if (this.stage) {
                var tmpChild = child;
                do {
                    if (tmpChild.interactive) this.stage.dirty = true;
                    tmpChild.stage = null;
                    tmpChild = tmpChild._iNext;
                } while (tmpChild);
            }
            if (child.__renderGroup) {
                child.__renderGroup.removeDisplayObjectAndChildren(child);
            }
            child.parent = undefined;
            this.children.splice(index, 1);
        } else {
            throw new Error(child + " The supplied DisplayObject must be a child of the caller " + this);
        }
    };
    PIXI.DisplayObjectContainer.prototype.updateTransform = function() {
        if (!this.visible) return;
        PIXI.DisplayObject.prototype.updateTransform.call(this);
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
    };
    PIXI.blendModes = {};
    PIXI.blendModes.NORMAL = 0;
    PIXI.blendModes.SCREEN = 1;
    PIXI.Sprite = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.anchor = new PIXI.Point;
        this.texture = texture;
        this.blendMode = PIXI.blendModes.NORMAL;
        this._width = 0;
        this._height = 0;
        if (texture.baseTexture.hasLoaded) {
            this.updateFrame = true;
        } else {
            this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
            this.texture.addEventListener("update", this.onTextureUpdateBind);
        }
        this.renderable = true;
    };
    PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Sprite.prototype.constructor = PIXI.Sprite;
    Object.defineProperty(PIXI.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width;
        },
        set: function(value) {
            this.scale.x = value / this.texture.frame.width;
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height;
        },
        set: function(value) {
            this.scale.y = value / this.texture.frame.height;
            this._height = value;
        }
    });
    PIXI.Sprite.prototype.setTexture = function(texture) {
        if (this.texture.baseTexture != texture.baseTexture) {
            this.textureChange = true;
            if (this.__renderGroup) {
                this.texture = texture;
                this.__renderGroup.updateTexture(this);
            }
        } else {
            this.texture = texture;
        }
        this.updateFrame = true;
    };
    PIXI.Sprite.prototype.onTextureUpdate = function(event) {
        if (this._width) this.scale.x = this._width / this.texture.frame.width;
        if (this._height) this.scale.y = this._height / this.texture.frame.height;
        this.updateFrame = true;
    };
    PIXI.Sprite.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error("The frameId '" + frameId + "' does not exist in the texture cache" + this);
        return new PIXI.Sprite(texture);
    };
    PIXI.Sprite.fromImage = function(imageId) {
        var texture = PIXI.Texture.fromImage(imageId);
        return new PIXI.Sprite(texture);
    };
    PIXI.MovieClip = function(textures) {
        PIXI.Sprite.call(this, textures[0]);
        this.textures = textures;
        this.animationSpeed = 1;
        this.loop = true;
        this.onComplete = null;
        this.currentFrame = 0;
        this.playing = false;
    };
    PIXI.MovieClip.prototype = Object.create(PIXI.Sprite.prototype);
    PIXI.MovieClip.prototype.constructor = PIXI.MovieClip;
    PIXI.MovieClip.prototype.stop = function() {
        this.playing = false;
    };
    PIXI.MovieClip.prototype.play = function() {
        this.playing = true;
    };
    PIXI.MovieClip.prototype.gotoAndStop = function(frameNumber) {
        this.playing = false;
        this.currentFrame = frameNumber;
        var round = this.currentFrame + .5 | 0;
        this.setTexture(this.textures[round % this.textures.length]);
    };
    PIXI.MovieClip.prototype.gotoAndPlay = function(frameNumber) {
        this.currentFrame = frameNumber;
        this.playing = true;
    };
    PIXI.MovieClip.prototype.updateTransform = function() {
        PIXI.Sprite.prototype.updateTransform.call(this);
        if (!this.playing) return;
        this.currentFrame += this.animationSpeed;
        var round = this.currentFrame + .5 | 0;
        if (this.loop || round < this.textures.length) {
            this.setTexture(this.textures[round % this.textures.length]);
        } else if (round >= this.textures.length) {
            this.gotoAndStop(this.textures.length - 1);
            if (this.onComplete) {
                this.onComplete();
            }
        }
    };
    PIXI.FilterBlock = function(mask) {
        this.graphics = mask;
        this.visible = true;
        this.renderable = true;
    };
    PIXI.Text = function(text, style) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));
        this.setText(text);
        this.setStyle(style);
        this.updateText();
        this.dirty = false;
    };
    PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);
    PIXI.Text.prototype.constructor = PIXI.Text;
    PIXI.Text.prototype.setStyle = function(style) {
        style = style || {};
        style.font = style.font || "bold 20pt Arial";
        style.fill = style.fill || "black";
        style.align = style.align || "left";
        style.stroke = style.stroke || "black";
        style.strokeThickness = style.strokeThickness || 0;
        style.wordWrap = style.wordWrap || false;
        style.wordWrapWidth = style.wordWrapWidth || 100;
        this.style = style;
        this.dirty = true;
    };
    PIXI.Sprite.prototype.setText = function(text) {
        this.text = text.toString() || " ";
        this.dirty = true;
    };
    PIXI.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var outputText = this.text;
        if (this.style.wordWrap) outputText = this.wordWrap(this.text);
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = [];
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = this.context.measureText(lines[i]).width;
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        this.canvas.width = maxLineWidth + this.style.strokeThickness;
        var lineHeight = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness;
        this.canvas.height = lineHeight * lines.length;
        this.context.fillStyle = this.style.fill;
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.textBaseline = "top";
        for (i = 0; i < lines.length; i++) {
            var linePosition = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + i * lineHeight);
            if (this.style.align == "right") {
                linePosition.x += maxLineWidth - lineWidths[i];
            } else if (this.style.align == "center") {
                linePosition.x += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(lines[i], linePosition.x, linePosition.y);
            }
            if (this.style.fill) {
                this.context.fillText(lines[i], linePosition.x, linePosition.y);
            }
        }
        this.updateTexture();
    };
    PIXI.Text.prototype.updateTexture = function() {
        this.texture.baseTexture.width = this.canvas.width;
        this.texture.baseTexture.height = this.canvas.height;
        this.texture.frame.width = this.canvas.width;
        this.texture.frame.height = this.canvas.height;
        this._width = this.canvas.width;
        this._height = this.canvas.height;
        PIXI.texturesToUpdate.push(this.texture.baseTexture);
    };
    PIXI.Text.prototype.updateTransform = function() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        PIXI.Sprite.prototype.updateTransform.call(this);
    };
    PIXI.Text.prototype.determineFontHeight = function(fontStyle) {
        var result = PIXI.Text.heightCache[fontStyle];
        if (!result) {
            var body = document.getElementsByTagName("body")[0];
            var dummy = document.createElement("div");
            var dummyText = document.createTextNode("M");
            dummy.appendChild(dummyText);
            dummy.setAttribute("style", fontStyle + ";position:absolute;top:0;left:0");
            body.appendChild(dummy);
            result = dummy.offsetHeight;
            PIXI.Text.heightCache[fontStyle] = result;
            body.removeChild(dummy);
        }
        return result;
    };
    PIXI.Text.prototype.wordWrap = function(text) {
        var searchWrapPos = function(ctx, text, start, end, wrapWidth) {
            var p = Math.floor((end - start) / 2) + start;
            if (p == start) {
                return 1;
            }
            if (ctx.measureText(text.substring(0, p)).width <= wrapWidth) {
                if (ctx.measureText(text.substring(0, p + 1)).width > wrapWidth) {
                    return p;
                } else {
                    return arguments.callee(ctx, text, p, end, wrapWidth);
                }
            } else {
                return arguments.callee(ctx, text, start, p, wrapWidth);
            }
        };
        var lineWrap = function(ctx, text, wrapWidth) {
            if (ctx.measureText(text).width <= wrapWidth || text.length < 1) {
                return text;
            }
            var pos = searchWrapPos(ctx, text, 0, text.length, wrapWidth);
            return text.substring(0, pos) + "\n" + arguments.callee(ctx, text.substring(pos), wrapWidth);
        };
        var result = "";
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
            result += lineWrap(this.context, lines[i], this.style.wordWrapWidth) + "\n";
        }
        return result;
    };
    PIXI.Text.prototype.destroy = function(destroyTexture) {
        if (destroyTexture) {
            this.texture.destroy();
        }
    };
    PIXI.Text.heightCache = {};
    PIXI.BitmapText = function(text, style) {
        PIXI.DisplayObjectContainer.call(this);
        this.setText(text);
        this.setStyle(style);
        this.updateText();
        this.dirty = false;
    };
    PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.BitmapText.prototype.constructor = PIXI.BitmapText;
    PIXI.BitmapText.prototype.setText = function(text) {
        this.text = text || " ";
        this.dirty = true;
    };
    PIXI.BitmapText.prototype.setStyle = function(style) {
        style = style || {};
        style.align = style.align || "left";
        this.style = style;
        var font = style.font.split(" ");
        this.fontName = font[font.length - 1];
        this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;
        this.dirty = true;
    };
    PIXI.BitmapText.prototype.updateText = function() {
        var data = PIXI.BitmapText.fonts[this.fontName];
        var pos = new PIXI.Point;
        var prevCharCode = null;
        var chars = [];
        var maxLineWidth = 0;
        var lineWidths = [];
        var line = 0;
        var scale = this.fontSize / data.size;
        for (var i = 0; i < this.text.length; i++) {
            var charCode = this.text.charCodeAt(i);
            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) {
                lineWidths.push(pos.x);
                maxLineWidth = Math.max(maxLineWidth, pos.x);
                line++;
                pos.x = 0;
                pos.y += data.lineHeight;
                prevCharCode = null;
                continue;
            }
            var charData = data.chars[charCode];
            if (!charData) continue;
            if (prevCharCode && charData[prevCharCode]) {
                pos.x += charData.kerning[prevCharCode];
            }
            chars.push({
                texture: charData.texture,
                line: line,
                charCode: charCode,
                position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)
            });
            pos.x += charData.xAdvance;
            prevCharCode = charCode;
        }
        lineWidths.push(pos.x);
        maxLineWidth = Math.max(maxLineWidth, pos.x);
        var lineAlignOffsets = [];
        for (i = 0; i <= line; i++) {
            var alignOffset = 0;
            if (this.style.align == "right") {
                alignOffset = maxLineWidth - lineWidths[i];
            } else if (this.style.align == "center") {
                alignOffset = (maxLineWidth - lineWidths[i]) / 2;
            }
            lineAlignOffsets.push(alignOffset);
        }
        for (i = 0; i < chars.length; i++) {
            var c = new PIXI.Sprite(chars[i].texture);
            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
            c.position.y = chars[i].position.y * scale;
            c.scale.x = c.scale.y = scale;
            this.addChild(c);
        }
        this.width = pos.x * scale;
        this.height = (pos.y + data.lineHeight) * scale;
    };
    PIXI.BitmapText.prototype.updateTransform = function() {
        if (this.dirty) {
            while (this.children.length > 0) {
                this.removeChild(this.getChildAt(0));
            }
            this.updateText();
            this.dirty = false;
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.BitmapText.fonts = {};
    PIXI.InteractionManager = function(stage) {
        this.stage = stage;
        this.mouse = new PIXI.InteractionData;
        this.touchs = {};
        this.tempPoint = new PIXI.Point;
        this.mouseoverEnabled = true;
        this.pool = [];
        this.interactiveItems = [];
        this.last = 0;
    };
    PIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager;
    PIXI.InteractionManager.prototype.collectInteractiveSprite = function(displayObject, iParent) {
        var children = displayObject.children;
        var length = children.length;
        for (var i = length - 1; i >= 0; i--) {
            var child = children[i];
            if (child.interactive) {
                iParent.interactiveChildren = true;
                this.interactiveItems.push(child);
                if (child.children.length > 0) {
                    this.collectInteractiveSprite(child, child);
                }
            } else {
                child.__iParent = null;
                if (child.children.length > 0) {
                    this.collectInteractiveSprite(child, iParent);
                }
            }
        }
    };
    PIXI.InteractionManager.prototype.setTarget = function(target) {
        if (window.navigator.msPointerEnabled) {
            target.view.style["-ms-content-zooming"] = "none";
            target.view.style["-ms-touch-action"] = "none";
        }
        this.target = target;
        target.view.addEventListener("mousemove", this.onMouseMove.bind(this), true);
        target.view.addEventListener("mousedown", this.onMouseDown.bind(this), true);
        document.body.addEventListener("mouseup", this.onMouseUp.bind(this), true);
        target.view.addEventListener("mouseout", this.onMouseOut.bind(this), true);
        target.view.addEventListener("touchstart", this.onTouchStart.bind(this), true);
        target.view.addEventListener("touchend", this.onTouchEnd.bind(this), true);
        target.view.addEventListener("touchmove", this.onTouchMove.bind(this), true);
    };
    PIXI.InteractionManager.prototype.update = function() {
        if (!this.target) return;
        var now = Date.now();
        var diff = now - this.last;
        diff = diff * 30 / 1e3;
        if (diff < 1) return;
        this.last = now;
        if (this.dirty) {
            this.dirty = false;
            var len = this.interactiveItems.length;
            for (var i = 0; i < len; i++) {
                this.interactiveItems[i].interactiveChildren = false;
            }
            this.interactiveItems = [];
            if (this.stage.interactive) this.interactiveItems.push(this.stage);
            this.collectInteractiveSprite(this.stage, this.stage);
        }
        var length = this.interactiveItems.length;
        this.target.view.style.cursor = "default";
        for (var i = 0; i < length; i++) {
            var item = this.interactiveItems[i];
            if (item.mouseover || item.mouseout || item.buttonMode) {
                item.__hit = this.hitTest(item, this.mouse);
                this.mouse.target = item;
                if (item.__hit) {
                    if (item.buttonMode) this.target.view.style.cursor = "pointer";
                    if (!item.__isOver) {
                        if (item.mouseover) item.mouseover(this.mouse);
                        item.__isOver = true;
                    }
                } else {
                    if (item.__isOver) {
                        if (item.mouseout) item.mouseout(this.mouse);
                        item.__isOver = false;
                    }
                }
            }
        }
    };
    PIXI.InteractionManager.prototype.onMouseMove = function(event) {
        this.mouse.originalEvent = event || window.event;
        var rect = this.target.view.getBoundingClientRect();
        this.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width);
        this.mouse.global.y = (event.clientY - rect.top) * (this.target.height / rect.height);
        var length = this.interactiveItems.length;
        var global = this.mouse.global;
        for (var i = 0; i < length; i++) {
            var item = this.interactiveItems[i];
            if (item.mousemove) {
                item.mousemove(this.mouse);
            }
        }
    };
    PIXI.InteractionManager.prototype.onMouseDown = function(event) {
        this.mouse.originalEvent = event || window.event;
        var length = this.interactiveItems.length;
        var global = this.mouse.global;
        var index = 0;
        var parent = this.stage;
        for (var i = 0; i < length; i++) {
            var item = this.interactiveItems[i];
            if (item.mousedown || item.click) {
                item.__mouseIsDown = true;
                item.__hit = this.hitTest(item, this.mouse);
                if (item.__hit) {
                    if (item.mousedown) item.mousedown(this.mouse);
                    item.__isDown = true;
                    if (!item.interactiveChildren) break;
                }
            }
        }
    };
    PIXI.InteractionManager.prototype.onMouseOut = function(event) {
        var length = this.interactiveItems.length;
        this.target.view.style.cursor = "default";
        for (var i = 0; i < length; i++) {
            var item = this.interactiveItems[i];
            if (item.__isOver) {
                this.mouse.target = item;
                if (item.mouseout) item.mouseout(this.mouse);
                item.__isOver = false;
            }
        }
    };
    PIXI.InteractionManager.prototype.onMouseUp = function(event) {
        this.mouse.originalEvent = event || window.event;
        var global = this.mouse.global;
        var length = this.interactiveItems.length;
        var up = false;
        for (var i = 0; i < length; i++) {
            var item = this.interactiveItems[i];
            if (item.mouseup || item.mouseupoutside || item.click) {
                item.__hit = this.hitTest(item, this.mouse);
                if (item.__hit && !up) {
                    if (item.mouseup) {
                        item.mouseup(this.mouse);
                    }
                    if (item.__isDown) {
                        if (item.click) item.click(this.mouse);
                    }
                    if (!item.interactiveChildren) up = true;
                } else {
                    if (item.__isDown) {
                        if (item.mouseupoutside) item.mouseupoutside(this.mouse);
                    }
                }
                item.__isDown = false;
            }
        }
    };
    PIXI.InteractionManager.prototype.hitTest = function(item, interactionData) {
        var global = interactionData.global;
        if (item.vcount !== PIXI.visibleCount) return false;
        var isSprite = item instanceof PIXI.Sprite, worldTransform = item.worldTransform, a00 = worldTransform[0], a01 = worldTransform[1], a02 = worldTransform[2], a10 = worldTransform[3], a11 = worldTransform[4], a12 = worldTransform[5], id = 1 / (a00 * a11 + a01 * -a10), x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id, y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;
        interactionData.target = item;
        if (item.hitArea && item.hitArea.contains) {
            if (item.hitArea.contains(x, y)) {
                interactionData.target = item;
                return true;
            }
            return false;
        } else if (isSprite) {
            var width = item.texture.frame.width, height = item.texture.frame.height, x1 = -width * item.anchor.x, y1;
            if (x > x1 && x < x1 + width) {
                y1 = -height * item.anchor.y;
                if (y > y1 && y < y1 + height) {
                    interactionData.target = item;
                    return true;
                }
            }
        }
        var length = item.children.length;
        for (var i = 0; i < length; i++) {
            var tempItem = item.children[i];
            var hit = this.hitTest(tempItem, interactionData);
            if (hit) {
                interactionData.target = item;
                return true;
            }
        }
        return false;
    };
    PIXI.InteractionManager.prototype.onTouchMove = function(event) {
        var rect = this.target.view.getBoundingClientRect();
        var changedTouches = event.changedTouches;
        for (var i = 0; i < changedTouches.length; i++) {
            var touchEvent = changedTouches[i];
            var touchData = this.touchs[touchEvent.identifier];
            touchData.originalEvent = event || window.event;
            touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
            touchData.global.y = (touchEvent.clientY - rect.top) * (this.target.height / rect.height);
        }
        var length = this.interactiveItems.length;
        for (var i = 0; i < length; i++) {
            var item = this.interactiveItems[i];
            if (item.touchmove) item.touchmove(touchData);
        }
    };
    PIXI.InteractionManager.prototype.onTouchStart = function(event) {
        var rect = this.target.view.getBoundingClientRect();
        var changedTouches = event.changedTouches;
        for (var i = 0; i < changedTouches.length; i++) {
            var touchEvent = changedTouches[i];
            var touchData = this.pool.pop();
            if (!touchData) touchData = new PIXI.InteractionData;
            touchData.originalEvent = event || window.event;
            this.touchs[touchEvent.identifier] = touchData;
            touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
            touchData.global.y = (touchEvent.clientY - rect.top) * (this.target.height / rect.height);
            var length = this.interactiveItems.length;
            for (var j = 0; j < length; j++) {
                var item = this.interactiveItems[j];
                if (item.touchstart || item.tap) {
                    item.__hit = this.hitTest(item, touchData);
                    if (item.__hit) {
                        if (item.touchstart) item.touchstart(touchData);
                        item.__isDown = true;
                        item.__touchData = touchData;
                        if (!item.interactiveChildren) break;
                    }
                }
            }
        }
    };
    PIXI.InteractionManager.prototype.onTouchEnd = function(event) {
        var rect = this.target.view.getBoundingClientRect();
        var changedTouches = event.changedTouches;
        for (var i = 0; i < changedTouches.length; i++) {
            var touchEvent = changedTouches[i];
            var touchData = this.touchs[touchEvent.identifier];
            var up = false;
            touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
            touchData.global.y = (touchEvent.clientY - rect.top) * (this.target.height / rect.height);
            var length = this.interactiveItems.length;
            for (var j = 0; j < length; j++) {
                var item = this.interactiveItems[j];
                var itemTouchData = item.__touchData;
                item.__hit = this.hitTest(item, touchData);
                if (itemTouchData == touchData) {
                    touchData.originalEvent = event || window.event;
                    if (item.touchend || item.tap) {
                        if (item.__hit && !up) {
                            if (item.touchend) item.touchend(touchData);
                            if (item.__isDown) {
                                if (item.tap) item.tap(touchData);
                            }
                            if (!item.interactiveChildren) up = true;
                        } else {
                            if (item.__isDown) {
                                if (item.touchendoutside) item.touchendoutside(touchData);
                            }
                        }
                        item.__isDown = false;
                    }
                    item.__touchData = null;
                } else {}
            }
            this.pool.push(touchData);
            this.touchs[touchEvent.identifier] = null;
        }
    };
    PIXI.InteractionData = function() {
        this.global = new PIXI.Point;
        this.local = new PIXI.Point;
        this.target;
        this.originalEvent;
    };
    PIXI.InteractionData.prototype.getLocalPosition = function(displayObject) {
        var worldTransform = displayObject.worldTransform;
        var global = this.global;
        var a00 = worldTransform[0], a01 = worldTransform[1], a02 = worldTransform[2], a10 = worldTransform[3], a11 = worldTransform[4], a12 = worldTransform[5], id = 1 / (a00 * a11 + a01 * -a10);
        return new PIXI.Point(a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id, a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id);
    };
    PIXI.InteractionData.prototype.constructor = PIXI.InteractionData;
    PIXI.Stage = function(backgroundColor, interactive) {
        PIXI.DisplayObjectContainer.call(this);
        this.worldTransform = PIXI.mat3.create();
        this.interactive = interactive;
        this.interactionManager = new PIXI.InteractionManager(this);
        this.dirty = true;
        this.__childrenAdded = [];
        this.__childrenRemoved = [];
        this.stage = this;
        this.stage.hitArea = new PIXI.Rectangle(0, 0, 1e5, 1e5);
        this.setBackgroundColor(backgroundColor);
        this.worldVisible = true;
    };
    PIXI.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Stage.prototype.constructor = PIXI.Stage;
    PIXI.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
        if (this.dirty) {
            this.dirty = false;
            this.interactionManager.dirty = true;
        }
        if (this.interactive) this.interactionManager.update();
    };
    PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor) {
        this.backgroundColor = backgroundColor || 0;
        this.backgroundColorSplit = HEXtoRGB(this.backgroundColor);
        var hex = this.backgroundColor.toString(16);
        hex = "000000".substr(0, 6 - hex.length) + hex;
        this.backgroundColorString = "#" + hex;
    };
    PIXI.Stage.prototype.getMousePosition = function() {
        return this.interactionManager.mouse.global;
    };
    var lastTime = 0;
    var vendors = [ "ms", "moz", "webkit", "o" ];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) {
        var currTime = (new Date).getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
    window.requestAnimFrame = window.requestAnimationFrame;
    function HEXtoRGB(hex) {
        return [ (hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255 ];
    }
    if (typeof Function.prototype.bind != "function") {
        Function.prototype.bind = function() {
            var slice = Array.prototype.slice;
            return function(thisArg) {
                var target = this, boundArgs = slice.call(arguments, 1);
                if (typeof target != "function") throw new TypeError;
                function bound() {
                    var args = boundArgs.concat(slice.call(arguments));
                    target.apply(this instanceof bound ? this : thisArg, args);
                }
                bound.prototype = function F(proto) {
                    proto && (F.prototype = proto);
                    if (!(this instanceof F)) return new F;
                }(target.prototype);
                return bound;
            };
        }();
    }
    var AjaxRequest = PIXI.AjaxRequest = function() {
        var activexmodes = [ "Msxml2.XMLHTTP", "Microsoft.XMLHTTP" ];
        if (window.ActiveXObject) {
            for (var i = 0; i < activexmodes.length; i++) {
                try {
                    return new ActiveXObject(activexmodes[i]);
                } catch (e) {}
            }
        } else if (window.XMLHttpRequest) {
            return new XMLHttpRequest;
        } else {
            return false;
        }
    };
    PIXI.runList = function(item) {
        console.log(">>>>>>>>>");
        console.log("_");
        var safe = 0;
        var tmp = item.first;
        console.log(tmp);
        while (tmp._iNext) {
            safe++;
            tmp = tmp._iNext;
            console.log(tmp);
            if (safe > 100) {
                console.log("BREAK");
                break;
            }
        }
    };
    PIXI.EventTarget = function() {
        var listeners = {};
        this.addEventListener = this.on = function(type, listener) {
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
        };
        this.dispatchEvent = this.emit = function(event) {
            for (var listener in listeners[event.type]) {
                listeners[event.type][listener](event);
            }
        };
        this.removeEventListener = this.off = function(type, listener) {
            var index = listeners[type].indexOf(listener);
            if (index !== -1) {
                listeners[type].splice(index, 1);
            }
        };
    };
    PIXI.autoDetectRenderer = function(width, height, view, transparent, antialias) {
        if (!width) width = 800;
        if (!height) height = 600;
        var webgl = function() {
            try {
                return !!window.WebGLRenderingContext && !!document.createElement("canvas").getContext("experimental-webgl");
            } catch (e) {
                return false;
            }
        }();
        if (webgl) {
            return new PIXI.WebGLRenderer(width, height, view, transparent, antialias);
        }
        return new PIXI.CanvasRenderer(width, height, view, transparent);
    };
    PIXI.PolyK = {};
    PIXI.PolyK.Triangulate = function(p) {
        var sign = true;
        var n = p.length >> 1;
        if (n < 3) return [];
        var tgs = [];
        var avl = [];
        for (var i = 0; i < n; i++) avl.push(i);
        var i = 0;
        var al = n;
        while (al > 3) {
            var i0 = avl[(i + 0) % al];
            var i1 = avl[(i + 1) % al];
            var i2 = avl[(i + 2) % al];
            var ax = p[2 * i0], ay = p[2 * i0 + 1];
            var bx = p[2 * i1], by = p[2 * i1 + 1];
            var cx = p[2 * i2], cy = p[2 * i2 + 1];
            var earFound = false;
            if (PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign)) {
                earFound = true;
                for (var j = 0; j < al; j++) {
                    var vi = avl[j];
                    if (vi == i0 || vi == i1 || vi == i2) continue;
                    if (PIXI.PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }
            if (earFound) {
                tgs.push(i0, i1, i2);
                avl.splice((i + 1) % al, 1);
                al--;
                i = 0;
            } else if (i++ > 3 * al) {
                if (sign) {
                    var tgs = [];
                    avl = [];
                    for (var i = 0; i < n; i++) avl.push(i);
                    i = 0;
                    al = n;
                    sign = false;
                } else {
                    console.log("PIXI Warning: shape too complex to fill");
                    return [];
                }
            }
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    };
    PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = px - ax;
        var v2y = py - ay;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return u >= 0 && v >= 0 && u + v < 1;
    };
    PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign) {
        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0 == sign;
    };
    PIXI.shaderFragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "gl_FragColor = gl_FragColor * vColor;", "}" ];
    PIXI.shaderVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "varying vec2 vTextureCoord;", "varying float vColor;", "void main(void) {", "gl_Position = vec4( aVertexPosition.x / projectionVector.x -1.0, aVertexPosition.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "vTextureCoord = aTextureCoord;", "vColor = aColor;", "}" ];
    PIXI.stripShaderFragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "gl_FragColor = gl_FragColor * alpha;", "}" ];
    PIXI.stripShaderVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "varying vec2 vTextureCoord;", "varying float vColor;", "void main(void) {", "vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);", "gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "vTextureCoord = aTextureCoord;", "vColor = aColor;", "}" ];
    PIXI.primitiveShaderFragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "gl_FragColor = vColor;", "}" ];
    PIXI.primitiveShaderVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform float alpha;", "varying vec4 vColor;", "void main(void) {", "vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);", "gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "vColor = aColor  * alpha;", "}" ];
    PIXI.initPrimitiveShader = function() {
        var gl = PIXI.gl;
        var shaderProgram = PIXI.compileProgram(PIXI.primitiveShaderVertexSrc, PIXI.primitiveShaderFragmentSrc);
        gl.useProgram(shaderProgram);
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        shaderProgram.colorAttribute = gl.getAttribLocation(shaderProgram, "aColor");
        shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, "projectionVector");
        shaderProgram.translationMatrix = gl.getUniformLocation(shaderProgram, "translationMatrix");
        shaderProgram.alpha = gl.getUniformLocation(shaderProgram, "alpha");
        PIXI.primitiveProgram = shaderProgram;
    };
    PIXI.initDefaultShader = function() {
        var gl = this.gl;
        var shaderProgram = PIXI.compileProgram(PIXI.shaderVertexSrc, PIXI.shaderFragmentSrc);
        gl.useProgram(shaderProgram);
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, "projectionVector");
        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        shaderProgram.colorAttribute = gl.getAttribLocation(shaderProgram, "aColor");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        PIXI.shaderProgram = shaderProgram;
    };
    PIXI.initDefaultStripShader = function() {
        var gl = this.gl;
        var shaderProgram = PIXI.compileProgram(PIXI.stripShaderVertexSrc, PIXI.stripShaderFragmentSrc);
        gl.useProgram(shaderProgram);
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, "projectionVector");
        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        shaderProgram.translationMatrix = gl.getUniformLocation(shaderProgram, "translationMatrix");
        shaderProgram.alpha = gl.getUniformLocation(shaderProgram, "alpha");
        shaderProgram.colorAttribute = gl.getAttribLocation(shaderProgram, "aColor");
        shaderProgram.projectionVector = gl.getUniformLocation(shaderProgram, "projectionVector");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        PIXI.stripShaderProgram = shaderProgram;
    };
    PIXI.CompileVertexShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
    };
    PIXI.CompileFragmentShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
    };
    PIXI._CompileShader = function(gl, shaderSrc, shaderType) {
        var src = shaderSrc.join("\n");
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    };
    PIXI.compileProgram = function(vertexSrc, fragmentSrc) {
        var gl = PIXI.gl;
        var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
        var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        return shaderProgram;
    };
    PIXI.activateDefaultShader = function() {
        var gl = PIXI.gl;
        var shaderProgram = PIXI.shaderProgram;
        gl.useProgram(shaderProgram);
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
        gl.enableVertexAttribArray(shaderProgram.colorAttribute);
    };
    PIXI.activatePrimitiveShader = function() {
        var gl = PIXI.gl;
        gl.disableVertexAttribArray(PIXI.shaderProgram.textureCoordAttribute);
        gl.disableVertexAttribArray(PIXI.shaderProgram.colorAttribute);
        gl.useProgram(PIXI.primitiveProgram);
        gl.enableVertexAttribArray(PIXI.primitiveProgram.vertexPositionAttribute);
        gl.enableVertexAttribArray(PIXI.primitiveProgram.colorAttribute);
    };
    PIXI.WebGLGraphics = function() {};
    PIXI.WebGLGraphics.renderGraphics = function(graphics, projection) {
        var gl = PIXI.gl;
        if (!graphics._webGL) graphics._webGL = {
            points: [],
            indices: [],
            lastIndex: 0,
            buffer: gl.createBuffer(),
            indexBuffer: gl.createBuffer()
        };
        if (graphics.dirty) {
            graphics.dirty = false;
            if (graphics.clearDirty) {
                graphics.clearDirty = false;
                graphics._webGL.lastIndex = 0;
                graphics._webGL.points = [];
                graphics._webGL.indices = [];
            }
            PIXI.WebGLGraphics.updateGraphics(graphics);
        }
        PIXI.activatePrimitiveShader();
        var m = PIXI.mat3.clone(graphics.worldTransform);
        PIXI.mat3.transpose(m);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.uniformMatrix3fv(PIXI.primitiveProgram.translationMatrix, false, m);
        gl.uniform2f(PIXI.primitiveProgram.projectionVector, projection.x, projection.y);
        gl.uniform1f(PIXI.primitiveProgram.alpha, graphics.worldAlpha);
        gl.bindBuffer(gl.ARRAY_BUFFER, graphics._webGL.buffer);
        gl.vertexAttribPointer(PIXI.shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.vertexAttribPointer(PIXI.primitiveProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(PIXI.primitiveProgram.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, graphics._webGL.indexBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, graphics._webGL.indices.length, gl.UNSIGNED_SHORT, 0);
        PIXI.activateDefaultShader();
    };
    PIXI.WebGLGraphics.updateGraphics = function(graphics) {
        for (var i = graphics._webGL.lastIndex; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            if (data.type == PIXI.Graphics.POLY) {
                if (data.fill) {
                    if (data.points.length > 3) PIXI.WebGLGraphics.buildPoly(data, graphics._webGL);
                }
                if (data.lineWidth > 0) {
                    PIXI.WebGLGraphics.buildLine(data, graphics._webGL);
                }
            } else if (data.type == PIXI.Graphics.RECT) {
                PIXI.WebGLGraphics.buildRectangle(data, graphics._webGL);
            } else if (data.type == PIXI.Graphics.CIRC || data.type == PIXI.Graphics.ELIP) {
                PIXI.WebGLGraphics.buildCircle(data, graphics._webGL);
            }
        }
        graphics._webGL.lastIndex = graphics.graphicsData.length;
        var gl = PIXI.gl;
        graphics._webGL.glPoints = new Float32Array(graphics._webGL.points);
        gl.bindBuffer(gl.ARRAY_BUFFER, graphics._webGL.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, graphics._webGL.glPoints, gl.STATIC_DRAW);
        graphics._webGL.glIndicies = new Uint16Array(graphics._webGL.indices);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, graphics._webGL.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, graphics._webGL.glIndicies, gl.STATIC_DRAW);
    };
    PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData) {
        var rectData = graphicsData.points;
        var x = rectData[0];
        var y = rectData[1];
        var width = rectData[2];
        var height = rectData[3];
        if (graphicsData.fill) {
            var color = HEXtoRGB(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vertPos = verts.length / 6;
            verts.push(x, y);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y);
            verts.push(r, g, b, alpha);
            verts.push(x, y + height);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y + height);
            verts.push(r, g, b, alpha);
            indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        }
        if (graphicsData.lineWidth) {
            graphicsData.points = [ x, y, x + width, y, x + width, y + height, x, y + height, x, y ];
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
        }
    };
    PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData) {
        var rectData = graphicsData.points;
        var x = rectData[0];
        var y = rectData[1];
        var width = rectData[2];
        var height = rectData[3];
        var totalSegs = 40;
        var seg = Math.PI * 2 / totalSegs;
        if (graphicsData.fill) {
            var color = HEXtoRGB(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vecPos = verts.length / 6;
            indices.push(vecPos);
            for (var i = 0; i < totalSegs + 1; i++) {
                verts.push(x, y, r, g, b, alpha);
                verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);
                indices.push(vecPos++, vecPos++);
            }
            indices.push(vecPos - 1);
        }
        if (graphicsData.lineWidth) {
            graphicsData.points = [];
            for (var i = 0; i < totalSegs + 1; i++) {
                graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height);
            }
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
        }
    };
    PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData) {
        var wrap = true;
        var points = graphicsData.points;
        if (points.length == 0) return;
        var firstPoint = new PIXI.Point(points[0], points[1]);
        var lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
        if (firstPoint.x == lastPoint.x && firstPoint.y == lastPoint.y) {
            points.pop();
            points.pop();
            lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
            var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * .5;
            var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * .5;
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 6;
        var width = graphicsData.lineWidth / 2;
        var color = HEXtoRGB(graphicsData.lineColor);
        var alpha = graphicsData.lineAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var p1x, p1y, p2x, p2y, p3x, p3y;
        var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
        var ipx, ipy;
        var a1, b1, c1, a2, b2, c2;
        var denom, pdist, dist;
        p1x = points[0];
        p1y = points[1];
        p2x = points[2];
        p2y = points[3];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);
        verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);
        for (var i = 1; i < length - 1; i++) {
            p1x = points[(i - 1) * 2];
            p1y = points[(i - 1) * 2 + 1];
            p2x = points[i * 2];
            p2y = points[i * 2 + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[(i + 1) * 2 + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            a1 = -perpy + p1y - (-perpy + p2y);
            b1 = -perpx + p2x - (-perpx + p1x);
            c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
            a2 = -perp2y + p3y - (-perp2y + p2y);
            b2 = -perp2x + p2x - (-perp2x + p3x);
            c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
            denom = a1 * b2 - a2 * b1;
            if (denom == 0) {
                denom += 1;
            }
            px = (b1 * c2 - b2 * c1) / denom;
            py = (a2 * c1 - a1 * c2) / denom;
            pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
            if (pdist > 140 * 140) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x + perp3x, p2y + perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                indexCount++;
            } else {
                verts.push(px, py);
                verts.push(r, g, b, alpha);
                verts.push(p2x - (px - p2x), p2y - (py - p2y));
                verts.push(r, g, b, alpha);
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[(length - 2) * 2 + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[(length - 1) * 2 + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - perpx, p2y - perpy);
        verts.push(r, g, b, alpha);
        verts.push(p2x + perpx, p2y + perpy);
        verts.push(r, g, b, alpha);
        indices.push(indexStart);
        for (var i = 0; i < indexCount; i++) {
            indices.push(indexStart++);
        }
        indices.push(indexStart - 1);
    };
    PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points;
        if (points.length < 6) return;
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var color = HEXtoRGB(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var triangles = PIXI.PolyK.Triangulate(points);
        var vertPos = verts.length / 6;
        for (var i = 0; i < triangles.length; i += 3) {
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i + 1] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
        }
        for (var i = 0; i < length; i++) {
            verts.push(points[i * 2], points[i * 2 + 1], r, g, b, alpha);
        }
    };
    function HEXtoRGB(hex) {
        return [ (hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255 ];
    }
    PIXI._defaultFrame = new PIXI.Rectangle(0, 0, 1, 1);
    PIXI.gl;
    PIXI.WebGLRenderer = function(width, height, view, transparent, antialias) {
        this.transparent = !!transparent;
        this.width = width || 800;
        this.height = height || 600;
        this.view = view || document.createElement("canvas");
        this.view.width = this.width;
        this.view.height = this.height;
        var scope = this;
        this.view.addEventListener("webglcontextlost", function(event) {
            scope.handleContextLost(event);
        }, false);
        this.view.addEventListener("webglcontextrestored", function(event) {
            scope.handleContextRestored(event);
        }, false);
        this.batchs = [];
        try {
            PIXI.gl = this.gl = this.view.getContext("experimental-webgl", {
                alpha: this.transparent,
                antialias: !!antialias,
                premultipliedAlpha: false,
                stencil: true
            });
        } catch (e) {
            throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this);
        }
        PIXI.initPrimitiveShader();
        PIXI.initDefaultShader();
        PIXI.initDefaultStripShader();
        PIXI.activateDefaultShader();
        var gl = this.gl;
        PIXI.WebGLRenderer.gl = gl;
        this.batch = new PIXI.WebGLBatch(gl);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.colorMask(true, true, true, this.transparent);
        PIXI.projection = new PIXI.Point(400, 300);
        this.resize(this.width, this.height);
        this.contextLost = false;
        this.stageRenderGroup = new PIXI.WebGLRenderGroup(this.gl);
    };
    PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;
    PIXI.WebGLRenderer.getBatch = function() {
        if (PIXI._batchs.length == 0) {
            return new PIXI.WebGLBatch(PIXI.WebGLRenderer.gl);
        } else {
            return PIXI._batchs.pop();
        }
    };
    PIXI.WebGLRenderer.returnBatch = function(batch) {
        batch.clean();
        PIXI._batchs.push(batch);
    };
    PIXI.WebGLRenderer.prototype.render = function(stage) {
        if (this.contextLost) return;
        if (this.__stage !== stage) {
            this.__stage = stage;
            this.stageRenderGroup.setRenderable(stage);
        }
        PIXI.WebGLRenderer.updateTextures();
        PIXI.visibleCount++;
        stage.updateTransform();
        var gl = this.gl;
        gl.colorMask(true, true, true, this.transparent);
        gl.viewport(0, 0, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.clearColor(stage.backgroundColorSplit[0], stage.backgroundColorSplit[1], stage.backgroundColorSplit[2], !this.transparent);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.stageRenderGroup.backgroundColor = stage.backgroundColorSplit;
        this.stageRenderGroup.render(PIXI.projection);
        if (stage.interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        }
        if (PIXI.Texture.frameUpdates.length > 0) {
            for (var i = 0; i < PIXI.Texture.frameUpdates.length; i++) {
                PIXI.Texture.frameUpdates[i].updateFrame = false;
            }
            PIXI.Texture.frameUpdates = [];
        }
    };
    PIXI.WebGLRenderer.updateTextures = function() {
        for (var i = 0; i < PIXI.texturesToUpdate.length; i++) PIXI.WebGLRenderer.updateTexture(PIXI.texturesToUpdate[i]);
        for (var i = 0; i < PIXI.texturesToDestroy.length; i++) PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);
        PIXI.texturesToUpdate = [];
        PIXI.texturesToDestroy = [];
    };
    PIXI.WebGLRenderer.updateTexture = function(texture) {
        var gl = PIXI.gl;
        if (!texture._glTexture) {
            texture._glTexture = gl.createTexture();
        }
        if (texture.hasLoaded) {
            gl.bindTexture(gl.TEXTURE_2D, texture._glTexture);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            if (!texture._powerOf2) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            }
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    };
    PIXI.WebGLRenderer.destroyTexture = function(texture) {
        var gl = PIXI.gl;
        if (texture._glTexture) {
            texture._glTexture = gl.createTexture();
            gl.deleteTexture(gl.TEXTURE_2D, texture._glTexture);
        }
    };
    PIXI.WebGLRenderer.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        this.view.width = width;
        this.view.height = height;
        this.gl.viewport(0, 0, this.width, this.height);
        PIXI.projection.x = this.width / 2;
        PIXI.projection.y = this.height / 2;
    };
    PIXI.WebGLRenderer.prototype.handleContextLost = function(event) {
        event.preventDefault();
        this.contextLost = true;
    };
    PIXI.WebGLRenderer.prototype.handleContextRestored = function(event) {
        this.gl = this.view.getContext("experimental-webgl", {
            alpha: true
        });
        this.initShaders();
        for (var key in PIXI.TextureCache) {
            var texture = PIXI.TextureCache[key].baseTexture;
            texture._glTexture = null;
            PIXI.WebGLRenderer.updateTexture(texture);
        }
        for (var i = 0; i < this.batchs.length; i++) {
            this.batchs[i].restoreLostContext(this.gl);
            this.batchs[i].dirty = true;
        }
        PIXI._restoreBatchs(this.gl);
        this.contextLost = false;
    };
    PIXI._batchs = [];
    PIXI._getBatch = function(gl) {
        if (PIXI._batchs.length == 0) {
            return new PIXI.WebGLBatch(gl);
        } else {
            return PIXI._batchs.pop();
        }
    };
    PIXI._returnBatch = function(batch) {
        batch.clean();
        PIXI._batchs.push(batch);
    };
    PIXI._restoreBatchs = function(gl) {
        for (var i = 0; i < PIXI._batchs.length; i++) {
            PIXI._batchs[i].restoreLostContext(gl);
        }
    };
    PIXI.WebGLBatch = function(gl) {
        this.gl = gl;
        this.size = 0;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.uvBuffer = gl.createBuffer();
        this.colorBuffer = gl.createBuffer();
        this.blendMode = PIXI.blendModes.NORMAL;
        this.dynamicSize = 1;
    };
    PIXI.WebGLBatch.prototype.constructor = PIXI.WebGLBatch;
    PIXI.WebGLBatch.prototype.clean = function() {
        this.verticies = [];
        this.uvs = [];
        this.indices = [];
        this.colors = [];
        this.dynamicSize = 1;
        this.texture = null;
        this.last = null;
        this.size = 0;
        this.head;
        this.tail;
    };
    PIXI.WebGLBatch.prototype.restoreLostContext = function(gl) {
        this.gl = gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.uvBuffer = gl.createBuffer();
        this.colorBuffer = gl.createBuffer();
    };
    PIXI.WebGLBatch.prototype.init = function(sprite) {
        sprite.batch = this;
        this.dirty = true;
        this.blendMode = sprite.blendMode;
        this.texture = sprite.texture.baseTexture;
        this.head = sprite;
        this.tail = sprite;
        this.size = 1;
        this.growBatch();
    };
    PIXI.WebGLBatch.prototype.insertBefore = function(sprite, nextSprite) {
        this.size++;
        sprite.batch = this;
        this.dirty = true;
        var tempPrev = nextSprite.__prev;
        nextSprite.__prev = sprite;
        sprite.__next = nextSprite;
        if (tempPrev) {
            sprite.__prev = tempPrev;
            tempPrev.__next = sprite;
        } else {
            this.head = sprite;
        }
    };
    PIXI.WebGLBatch.prototype.insertAfter = function(sprite, previousSprite) {
        this.size++;
        sprite.batch = this;
        this.dirty = true;
        var tempNext = previousSprite.__next;
        previousSprite.__next = sprite;
        sprite.__prev = previousSprite;
        if (tempNext) {
            sprite.__next = tempNext;
            tempNext.__prev = sprite;
        } else {
            this.tail = sprite;
        }
    };
    PIXI.WebGLBatch.prototype.remove = function(sprite) {
        this.size--;
        if (this.size == 0) {
            sprite.batch = null;
            sprite.__prev = null;
            sprite.__next = null;
            return;
        }
        if (sprite.__prev) {
            sprite.__prev.__next = sprite.__next;
        } else {
            this.head = sprite.__next;
            this.head.__prev = null;
        }
        if (sprite.__next) {
            sprite.__next.__prev = sprite.__prev;
        } else {
            this.tail = sprite.__prev;
            this.tail.__next = null;
        }
        sprite.batch = null;
        sprite.__next = null;
        sprite.__prev = null;
        this.dirty = true;
    };
    PIXI.WebGLBatch.prototype.split = function(sprite) {
        this.dirty = true;
        var batch = new PIXI.WebGLBatch(this.gl);
        batch.init(sprite);
        batch.texture = this.texture;
        batch.tail = this.tail;
        this.tail = sprite.__prev;
        this.tail.__next = null;
        sprite.__prev = null;
        var tempSize = 0;
        while (sprite) {
            tempSize++;
            sprite.batch = batch;
            sprite = sprite.__next;
        }
        batch.size = tempSize;
        this.size -= tempSize;
        return batch;
    };
    PIXI.WebGLBatch.prototype.merge = function(batch) {
        this.dirty = true;
        this.tail.__next = batch.head;
        batch.head.__prev = this.tail;
        this.size += batch.size;
        this.tail = batch.tail;
        var sprite = batch.head;
        while (sprite) {
            sprite.batch = this;
            sprite = sprite.__next;
        }
    };
    PIXI.WebGLBatch.prototype.growBatch = function() {
        var gl = this.gl;
        if (this.size == 1) {
            this.dynamicSize = 1;
        } else {
            this.dynamicSize = this.size * 1.5;
        }
        this.verticies = new Float32Array(this.dynamicSize * 8);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.DYNAMIC_DRAW);
        this.uvs = new Float32Array(this.dynamicSize * 8);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.DYNAMIC_DRAW);
        this.dirtyUVS = true;
        this.colors = new Float32Array(this.dynamicSize * 4);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.DYNAMIC_DRAW);
        this.dirtyColors = true;
        this.indices = new Uint16Array(this.dynamicSize * 6);
        var length = this.indices.length / 6;
        for (var i = 0; i < length; i++) {
            var index2 = i * 6;
            var index3 = i * 4;
            this.indices[index2 + 0] = index3 + 0;
            this.indices[index2 + 1] = index3 + 1;
            this.indices[index2 + 2] = index3 + 2;
            this.indices[index2 + 3] = index3 + 0;
            this.indices[index2 + 4] = index3 + 2;
            this.indices[index2 + 5] = index3 + 3;
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
    };
    PIXI.WebGLBatch.prototype.refresh = function() {
        var gl = this.gl;
        if (this.dynamicSize < this.size) {
            this.growBatch();
        }
        var indexRun = 0;
        var worldTransform, width, height, aX, aY, w0, w1, h0, h1, index;
        var a, b, c, d, tx, ty;
        var displayObject = this.head;
        while (displayObject) {
            index = indexRun * 8;
            var texture = displayObject.texture;
            var frame = texture.frame;
            var tw = texture.baseTexture.width;
            var th = texture.baseTexture.height;
            this.uvs[index + 0] = frame.x / tw;
            this.uvs[index + 1] = frame.y / th;
            this.uvs[index + 2] = (frame.x + frame.width) / tw;
            this.uvs[index + 3] = frame.y / th;
            this.uvs[index + 4] = (frame.x + frame.width) / tw;
            this.uvs[index + 5] = (frame.y + frame.height) / th;
            this.uvs[index + 6] = frame.x / tw;
            this.uvs[index + 7] = (frame.y + frame.height) / th;
            displayObject.updateFrame = false;
            colorIndex = indexRun * 4;
            this.colors[colorIndex] = this.colors[colorIndex + 1] = this.colors[colorIndex + 2] = this.colors[colorIndex + 3] = displayObject.worldAlpha;
            displayObject = displayObject.__next;
            indexRun++;
        }
        this.dirtyUVS = true;
        this.dirtyColors = true;
    };
    PIXI.WebGLBatch.prototype.update = function() {
        var gl = this.gl;
        var worldTransform, width, height, aX, aY, w0, w1, h0, h1, index, index2, index3;
        var a, b, c, d, tx, ty;
        var indexRun = 0;
        var displayObject = this.head;
        while (displayObject) {
            if (displayObject.vcount === PIXI.visibleCount) {
                width = displayObject.texture.frame.width;
                height = displayObject.texture.frame.height;
                aX = displayObject.anchor.x;
                aY = displayObject.anchor.y;
                w0 = width * (1 - aX);
                w1 = width * -aX;
                h0 = height * (1 - aY);
                h1 = height * -aY;
                index = indexRun * 8;
                worldTransform = displayObject.worldTransform;
                a = worldTransform[0];
                b = worldTransform[3];
                c = worldTransform[1];
                d = worldTransform[4];
                tx = worldTransform[2];
                ty = worldTransform[5];
                this.verticies[index + 0] = a * w1 + c * h1 + tx;
                this.verticies[index + 1] = d * h1 + b * w1 + ty;
                this.verticies[index + 2] = a * w0 + c * h1 + tx;
                this.verticies[index + 3] = d * h1 + b * w0 + ty;
                this.verticies[index + 4] = a * w0 + c * h0 + tx;
                this.verticies[index + 5] = d * h0 + b * w0 + ty;
                this.verticies[index + 6] = a * w1 + c * h0 + tx;
                this.verticies[index + 7] = d * h0 + b * w1 + ty;
                if (displayObject.updateFrame || displayObject.texture.updateFrame) {
                    this.dirtyUVS = true;
                    var texture = displayObject.texture;
                    var frame = texture.frame;
                    var tw = texture.baseTexture.width;
                    var th = texture.baseTexture.height;
                    this.uvs[index + 0] = frame.x / tw;
                    this.uvs[index + 1] = frame.y / th;
                    this.uvs[index + 2] = (frame.x + frame.width) / tw;
                    this.uvs[index + 3] = frame.y / th;
                    this.uvs[index + 4] = (frame.x + frame.width) / tw;
                    this.uvs[index + 5] = (frame.y + frame.height) / th;
                    this.uvs[index + 6] = frame.x / tw;
                    this.uvs[index + 7] = (frame.y + frame.height) / th;
                    displayObject.updateFrame = false;
                }
                if (displayObject.cacheAlpha != displayObject.worldAlpha) {
                    displayObject.cacheAlpha = displayObject.worldAlpha;
                    var colorIndex = indexRun * 4;
                    this.colors[colorIndex] = this.colors[colorIndex + 1] = this.colors[colorIndex + 2] = this.colors[colorIndex + 3] = displayObject.worldAlpha;
                    this.dirtyColors = true;
                }
            } else {
                index = indexRun * 8;
                this.verticies[index + 0] = 0;
                this.verticies[index + 1] = 0;
                this.verticies[index + 2] = 0;
                this.verticies[index + 3] = 0;
                this.verticies[index + 4] = 0;
                this.verticies[index + 5] = 0;
                this.verticies[index + 6] = 0;
                this.verticies[index + 7] = 0;
            }
            indexRun++;
            displayObject = displayObject.__next;
        }
    };
    PIXI.WebGLBatch.prototype.render = function(start, end) {
        start = start || 0;
        if (end == undefined) end = this.size;
        if (this.dirty) {
            this.refresh();
            this.dirty = false;
        }
        if (this.size == 0) return;
        this.update();
        var gl = this.gl;
        var shaderProgram = PIXI.shaderProgram;
        gl.useProgram(shaderProgram);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        if (this.dirtyUVS) {
            this.dirtyUVS = false;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvs);
        }
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture._glTexture);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        if (this.dirtyColors) {
            this.dirtyColors = false;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.colors);
        }
        gl.vertexAttribPointer(shaderProgram.colorAttribute, 1, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var len = end - start;
        gl.drawElements(gl.TRIANGLES, len * 6, gl.UNSIGNED_SHORT, start * 2 * 6);
    };
    PIXI.WebGLRenderGroup = function(gl) {
        this.gl = gl;
        this.root;
        this.backgroundColor;
        this.batchs = [];
        this.toRemove = [];
    };
    PIXI.WebGLRenderGroup.prototype.constructor = PIXI.WebGLRenderGroup;
    PIXI.WebGLRenderGroup.prototype.setRenderable = function(displayObject) {
        if (this.root) this.removeDisplayObjectAndChildren(this.root);
        displayObject.worldVisible = displayObject.visible;
        this.root = displayObject;
        this.addDisplayObjectAndChildren(displayObject);
    };
    PIXI.WebGLRenderGroup.prototype.render = function(projection) {
        PIXI.WebGLRenderer.updateTextures();
        var gl = this.gl;
        gl.uniform2f(PIXI.shaderProgram.projectionVector, projection.x, projection.y);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        var renderable;
        for (var i = 0; i < this.batchs.length; i++) {
            renderable = this.batchs[i];
            if (renderable instanceof PIXI.WebGLBatch) {
                this.batchs[i].render();
                continue;
            }
            var worldVisible = renderable.vcount === PIXI.visibleCount;
            if (renderable instanceof PIXI.TilingSprite) {
                if (worldVisible) this.renderTilingSprite(renderable, projection);
            } else if (renderable instanceof PIXI.Strip) {
                if (worldVisible) this.renderStrip(renderable, projection);
            } else if (renderable instanceof PIXI.Graphics) {
                if (worldVisible && renderable.renderable) PIXI.WebGLGraphics.renderGraphics(renderable, projection);
            } else if (renderable instanceof PIXI.FilterBlock) {
                if (renderable.open) {
                    gl.enable(gl.STENCIL_TEST);
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.ALWAYS, 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                    PIXI.WebGLGraphics.renderGraphics(renderable.mask, projection);
                    gl.colorMask(true, true, true, false);
                    gl.stencilFunc(gl.NOTEQUAL, 0, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                } else {
                    gl.disable(gl.STENCIL_TEST);
                }
            }
        }
    };
    PIXI.WebGLRenderGroup.prototype.handleFilter = function(filter, projection) {};
    PIXI.WebGLRenderGroup.prototype.renderSpecific = function(displayObject, projection) {
        PIXI.WebGLRenderer.updateTextures();
        var gl = this.gl;
        gl.uniform2f(PIXI.shaderProgram.projectionVector, projection.x, projection.y);
        var startIndex;
        var startBatchIndex;
        var endIndex;
        var endBatchIndex;
        var nextRenderable = displayObject.first;
        while (nextRenderable._iNext) {
            nextRenderable = nextRenderable._iNext;
            if (nextRenderable.renderable && nextRenderable.__renderGroup) break;
        }
        var startBatch = nextRenderable.batch;
        if (nextRenderable instanceof PIXI.Sprite) {
            startBatch = nextRenderable.batch;
            var head = startBatch.head;
            var next = head;
            if (head == nextRenderable) {
                startIndex = 0;
            } else {
                startIndex = 1;
                while (head.__next != nextRenderable) {
                    startIndex++;
                    head = head.__next;
                }
            }
        } else {
            startBatch = nextRenderable;
        }
        var lastRenderable = displayObject;
        var endBatch;
        var lastItem = displayObject;
        while (lastItem.children.length > 0) {
            lastItem = lastItem.children[lastItem.children.length - 1];
            if (lastItem.renderable) lastRenderable = lastItem;
        }
        if (lastRenderable instanceof PIXI.Sprite) {
            endBatch = lastRenderable.batch;
            var head = endBatch.head;
            if (head == lastRenderable) {
                endIndex = 0;
            } else {
                endIndex = 1;
                while (head.__next != lastRenderable) {
                    endIndex++;
                    head = head.__next;
                }
            }
        } else {
            endBatch = lastRenderable;
        }
        if (startBatch == endBatch) {
            if (startBatch instanceof PIXI.WebGLBatch) {
                startBatch.render(startIndex, endIndex + 1);
            } else {
                this.renderSpecial(startBatch, projection);
            }
            return;
        }
        startBatchIndex = this.batchs.indexOf(startBatch);
        endBatchIndex = this.batchs.indexOf(endBatch);
        if (startBatch instanceof PIXI.WebGLBatch) {
            startBatch.render(startIndex);
        } else {
            this.renderSpecial(startBatch, projection);
        }
        for (var i = startBatchIndex + 1; i < endBatchIndex; i++) {
            renderable = this.batchs[i];
            if (renderable instanceof PIXI.WebGLBatch) {
                this.batchs[i].render();
            } else {
                this.renderSpecial(renderable, projection);
            }
        }
        if (endBatch instanceof PIXI.WebGLBatch) {
            endBatch.render(0, endIndex + 1);
        } else {
            this.renderSpecial(endBatch, projection);
        }
    };
    PIXI.WebGLRenderGroup.prototype.renderSpecial = function(renderable, projection) {
        var worldVisible = renderable.vcount === PIXI.visibleCount;
        if (renderable instanceof PIXI.TilingSprite) {
            if (worldVisible) this.renderTilingSprite(renderable, projection);
        } else if (renderable instanceof PIXI.Strip) {
            if (worldVisible) this.renderStrip(renderable, projection);
        } else if (renderable instanceof PIXI.CustomRenderable) {
            if (worldVisible) renderable.renderWebGL(this, projection);
        } else if (renderable instanceof PIXI.Graphics) {
            if (worldVisible && renderable.renderable) PIXI.WebGLGraphics.renderGraphics(renderable, projection);
        } else if (renderable instanceof PIXI.FilterBlock) {
            var gl = PIXI.gl;
            if (renderable.open) {
                gl.enable(gl.STENCIL_TEST);
                gl.colorMask(false, false, false, false);
                gl.stencilFunc(gl.ALWAYS, 1, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                PIXI.WebGLGraphics.renderGraphics(renderable.mask, projection);
                gl.colorMask(true, true, true, true);
                gl.stencilFunc(gl.NOTEQUAL, 0, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            } else {
                gl.disable(gl.STENCIL_TEST);
            }
        }
    };
    PIXI.WebGLRenderGroup.prototype.updateTexture = function(displayObject) {
        this.removeObject(displayObject);
        var previousRenderable = displayObject.first;
        while (previousRenderable != this.root) {
            previousRenderable = previousRenderable._iPrev;
            if (previousRenderable.renderable && previousRenderable.__renderGroup) break;
        }
        var nextRenderable = displayObject.last;
        while (nextRenderable._iNext) {
            nextRenderable = nextRenderable._iNext;
            if (nextRenderable.renderable && nextRenderable.__renderGroup) break;
        }
        this.insertObject(displayObject, previousRenderable, nextRenderable);
    };
    PIXI.WebGLRenderGroup.prototype.addFilterBlocks = function(start, end) {
        start.__renderGroup = this;
        end.__renderGroup = this;
        var previousRenderable = start;
        while (previousRenderable != this.root) {
            previousRenderable = previousRenderable._iPrev;
            if (previousRenderable.renderable && previousRenderable.__renderGroup) break;
        }
        this.insertAfter(start, previousRenderable);
        var previousRenderable2 = end;
        while (previousRenderable2 != this.root) {
            previousRenderable2 = previousRenderable2._iPrev;
            if (previousRenderable2.renderable && previousRenderable2.__renderGroup) break;
        }
        this.insertAfter(end, previousRenderable2);
    };
    PIXI.WebGLRenderGroup.prototype.removeFilterBlocks = function(start, end) {
        this.removeObject(start);
        this.removeObject(end);
    };
    PIXI.WebGLRenderGroup.prototype.addDisplayObjectAndChildren = function(displayObject) {
        if (displayObject.__renderGroup) displayObject.__renderGroup.removeDisplayObjectAndChildren(displayObject);
        var previousRenderable = displayObject.first;
        while (previousRenderable != this.root.first) {
            previousRenderable = previousRenderable._iPrev;
            if (previousRenderable.renderable && previousRenderable.__renderGroup) break;
        }
        var nextRenderable = displayObject.last;
        while (nextRenderable._iNext) {
            nextRenderable = nextRenderable._iNext;
            if (nextRenderable.renderable && nextRenderable.__renderGroup) break;
        }
        var tempObject = displayObject.first;
        var testObject = displayObject.last._iNext;
        do {
            tempObject.__renderGroup = this;
            if (tempObject.renderable) {
                this.insertObject(tempObject, previousRenderable, nextRenderable);
                previousRenderable = tempObject;
            }
            tempObject = tempObject._iNext;
        } while (tempObject != testObject);
    };
    PIXI.WebGLRenderGroup.prototype.removeDisplayObjectAndChildren = function(displayObject) {
        if (displayObject.__renderGroup != this) return;
        var lastObject = displayObject.last;
        do {
            displayObject.__renderGroup = null;
            if (displayObject.renderable) this.removeObject(displayObject);
            displayObject = displayObject._iNext;
        } while (displayObject);
    };
    PIXI.WebGLRenderGroup.prototype.insertObject = function(displayObject, previousObject, nextObject) {
        var previousSprite = previousObject;
        var nextSprite = nextObject;
        if (displayObject instanceof PIXI.Sprite) {
            var previousBatch;
            var nextBatch;
            if (previousSprite instanceof PIXI.Sprite) {
                previousBatch = previousSprite.batch;
                if (previousBatch) {
                    if (previousBatch.texture == displayObject.texture.baseTexture && previousBatch.blendMode == displayObject.blendMode) {
                        previousBatch.insertAfter(displayObject, previousSprite);
                        return;
                    }
                }
            } else {
                previousBatch = previousSprite;
            }
            if (nextSprite) {
                if (nextSprite instanceof PIXI.Sprite) {
                    nextBatch = nextSprite.batch;
                    if (nextBatch) {
                        if (nextBatch.texture == displayObject.texture.baseTexture && nextBatch.blendMode == displayObject.blendMode) {
                            nextBatch.insertBefore(displayObject, nextSprite);
                            return;
                        } else {
                            if (nextBatch == previousBatch) {
                                var splitBatch = previousBatch.split(nextSprite);
                                var batch = PIXI.WebGLRenderer.getBatch();
                                var index = this.batchs.indexOf(previousBatch);
                                batch.init(displayObject);
                                this.batchs.splice(index + 1, 0, batch, splitBatch);
                                return;
                            }
                        }
                    }
                } else {
                    nextBatch = nextSprite;
                }
            }
            var batch = PIXI.WebGLRenderer.getBatch();
            batch.init(displayObject);
            if (previousBatch) {
                var index = this.batchs.indexOf(previousBatch);
                this.batchs.splice(index + 1, 0, batch);
            } else {
                this.batchs.push(batch);
            }
            return;
        } else if (displayObject instanceof PIXI.TilingSprite) {
            this.initTilingSprite(displayObject);
        } else if (displayObject instanceof PIXI.Strip) {
            this.initStrip(displayObject);
        } else if (displayObject) {}
        this.insertAfter(displayObject, previousSprite);
    };
    PIXI.WebGLRenderGroup.prototype.insertAfter = function(item, displayObject) {
        if (displayObject instanceof PIXI.Sprite) {
            var previousBatch = displayObject.batch;
            if (previousBatch) {
                if (previousBatch.tail == displayObject) {
                    var index = this.batchs.indexOf(previousBatch);
                    this.batchs.splice(index + 1, 0, item);
                } else {
                    var splitBatch = previousBatch.split(displayObject.__next);
                    var index = this.batchs.indexOf(previousBatch);
                    this.batchs.splice(index + 1, 0, item, splitBatch);
                }
            } else {
                this.batchs.push(item);
            }
        } else {
            var index = this.batchs.indexOf(displayObject);
            this.batchs.splice(index + 1, 0, item);
        }
    };
    PIXI.WebGLRenderGroup.prototype.removeObject = function(displayObject) {
        var batchToRemove;
        if (displayObject instanceof PIXI.Sprite) {
            var batch = displayObject.batch;
            if (!batch) return;
            batch.remove(displayObject);
            if (batch.size == 0) {
                batchToRemove = batch;
            }
        } else {
            batchToRemove = displayObject;
        }
        if (batchToRemove) {
            var index = this.batchs.indexOf(batchToRemove);
            if (index == -1) return;
            if (index == 0 || index == this.batchs.length - 1) {
                this.batchs.splice(index, 1);
                if (batchToRemove instanceof PIXI.WebGLBatch) PIXI.WebGLRenderer.returnBatch(batchToRemove);
                return;
            }
            if (this.batchs[index - 1] instanceof PIXI.WebGLBatch && this.batchs[index + 1] instanceof PIXI.WebGLBatch) {
                if (this.batchs[index - 1].texture == this.batchs[index + 1].texture && this.batchs[index - 1].blendMode == this.batchs[index + 1].blendMode) {
                    this.batchs[index - 1].merge(this.batchs[index + 1]);
                    if (batchToRemove instanceof PIXI.WebGLBatch) PIXI.WebGLRenderer.returnBatch(batchToRemove);
                    PIXI.WebGLRenderer.returnBatch(this.batchs[index + 1]);
                    this.batchs.splice(index, 2);
                    return;
                }
            }
            this.batchs.splice(index, 1);
            if (batchToRemove instanceof PIXI.WebGLBatch) PIXI.WebGLRenderer.returnBatch(batchToRemove);
        }
    };
    PIXI.WebGLRenderGroup.prototype.initTilingSprite = function(sprite) {
        var gl = this.gl;
        sprite.verticies = new Float32Array([ 0, 0, sprite.width, 0, sprite.width, sprite.height, 0, sprite.height ]);
        sprite.uvs = new Float32Array([ 0, 0, 1, 0, 1, 1, 0, 1 ]);
        sprite.colors = new Float32Array([ 1, 1, 1, 1 ]);
        sprite.indices = new Uint16Array([ 0, 1, 3, 2 ]);
        sprite._vertexBuffer = gl.createBuffer();
        sprite._indexBuffer = gl.createBuffer();
        sprite._uvBuffer = gl.createBuffer();
        sprite._colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sprite._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sprite.verticies, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, sprite._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sprite.uvs, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, sprite._colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sprite.colors, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sprite._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sprite.indices, gl.STATIC_DRAW);
        if (sprite.texture.baseTexture._glTexture) {
            gl.bindTexture(gl.TEXTURE_2D, sprite.texture.baseTexture._glTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            sprite.texture.baseTexture._powerOf2 = true;
        } else {
            sprite.texture.baseTexture._powerOf2 = true;
        }
    };
    PIXI.WebGLRenderGroup.prototype.renderStrip = function(strip, projection) {
        var gl = this.gl;
        var shaderProgram = PIXI.shaderProgram;
        gl.useProgram(PIXI.stripShaderProgram);
        var m = PIXI.mat3.clone(strip.worldTransform);
        PIXI.mat3.transpose(m);
        gl.uniformMatrix3fv(PIXI.stripShaderProgram.translationMatrix, false, m);
        gl.uniform2f(PIXI.stripShaderProgram.projectionVector, projection.x, projection.y);
        gl.uniform1f(PIXI.stripShaderProgram.alpha, strip.worldAlpha);
        if (!strip.dirty) {
            gl.bindBuffer(gl.ARRAY_BUFFER, strip._vertexBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, strip.verticies);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, strip._uvBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, strip.texture.baseTexture._glTexture);
            gl.bindBuffer(gl.ARRAY_BUFFER, strip._colorBuffer);
            gl.vertexAttribPointer(shaderProgram.colorAttribute, 1, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, strip._indexBuffer);
        } else {
            strip.dirty = false;
            gl.bindBuffer(gl.ARRAY_BUFFER, strip._vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, strip.verticies, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, strip._uvBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, strip.uvs, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, strip.texture.baseTexture._glTexture);
            gl.bindBuffer(gl.ARRAY_BUFFER, strip._colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, strip.colors, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProgram.colorAttribute, 1, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, strip._indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, strip.indices, gl.STATIC_DRAW);
        }
        gl.drawElements(gl.TRIANGLE_STRIP, strip.indices.length, gl.UNSIGNED_SHORT, 0);
        gl.useProgram(PIXI.shaderProgram);
    };
    PIXI.WebGLRenderGroup.prototype.renderTilingSprite = function(sprite, projectionMatrix) {
        var gl = this.gl;
        var shaderProgram = PIXI.shaderProgram;
        var tilePosition = sprite.tilePosition;
        var tileScale = sprite.tileScale;
        var offsetX = tilePosition.x / sprite.texture.baseTexture.width;
        var offsetY = tilePosition.y / sprite.texture.baseTexture.height;
        var scaleX = sprite.width / sprite.texture.baseTexture.width / tileScale.x;
        var scaleY = sprite.height / sprite.texture.baseTexture.height / tileScale.y;
        sprite.uvs[0] = 0 - offsetX;
        sprite.uvs[1] = 0 - offsetY;
        sprite.uvs[2] = 1 * scaleX - offsetX;
        sprite.uvs[3] = 0 - offsetY;
        sprite.uvs[4] = 1 * scaleX - offsetX;
        sprite.uvs[5] = 1 * scaleY - offsetY;
        sprite.uvs[6] = 0 - offsetX;
        sprite.uvs[7] = 1 * scaleY - offsetY;
        gl.bindBuffer(gl.ARRAY_BUFFER, sprite._uvBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, sprite.uvs);
        this.renderStrip(sprite, projectionMatrix);
    };
    PIXI.WebGLRenderGroup.prototype.initStrip = function(strip) {
        var gl = this.gl;
        var shaderProgram = this.shaderProgram;
        strip._vertexBuffer = gl.createBuffer();
        strip._indexBuffer = gl.createBuffer();
        strip._uvBuffer = gl.createBuffer();
        strip._colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, strip._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, strip.verticies, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, strip._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, strip.uvs, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, strip._colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, strip.colors, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, strip._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, strip.indices, gl.STATIC_DRAW);
    };
    PIXI.CanvasRenderer = function(width, height, view, transparent) {
        this.transparent = transparent;
        this.width = width || 800;
        this.height = height || 600;
        this.view = view || document.createElement("canvas");
        this.context = this.view.getContext("2d");
        this.refresh = true;
        this.view.width = this.width;
        this.view.height = this.height;
        this.count = 0;
    };
    PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;
    PIXI.CanvasRenderer.prototype.render = function(stage) {
        PIXI.texturesToUpdate = [];
        PIXI.texturesToDestroy = [];
        stage.updateTransform();
        if (this.view.style.backgroundColor != stage.backgroundColorString && !this.transparent) this.view.style.backgroundColor = stage.backgroundColorString;
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.width, this.height);
        this.renderDisplayObject(stage);
        if (stage.interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        }
        if (PIXI.Texture.frameUpdates.length > 0) {
            PIXI.Texture.frameUpdates = [];
        }
    };
    PIXI.CanvasRenderer.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        this.view.width = width;
        this.view.height = height;
    };
    PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject) {
        var transform;
        var context = this.context;
        context.globalCompositeOperation = "source-over";
        var testObject = displayObject.last._iNext;
        displayObject = displayObject.first;
        do {
            transform = displayObject.worldTransform;
            if (!displayObject.visible) {
                displayObject = displayObject.last._iNext;
                continue;
            }
            if (!displayObject.renderable) {
                displayObject = displayObject._iNext;
                continue;
            }
            if (displayObject instanceof PIXI.Sprite) {
                var frame = displayObject.texture.frame;
                if (frame) {
                    context.globalAlpha = displayObject.worldAlpha;
                    context.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5]);
                    context.drawImage(displayObject.texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, displayObject.anchor.x * -frame.width, displayObject.anchor.y * -frame.height, frame.width, frame.height);
                }
            } else if (displayObject instanceof PIXI.Strip) {
                context.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5]);
                this.renderStrip(displayObject);
            } else if (displayObject instanceof PIXI.TilingSprite) {
                context.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5]);
                this.renderTilingSprite(displayObject);
            } else if (displayObject instanceof PIXI.CustomRenderable) {
                displayObject.renderCanvas(this);
            } else if (displayObject instanceof PIXI.Graphics) {
                context.setTransform(transform[0], transform[3], transform[1], transform[4], transform[2], transform[5]);
                PIXI.CanvasGraphics.renderGraphics(displayObject, context);
            } else if (displayObject instanceof PIXI.FilterBlock) {
                if (displayObject.open) {
                    context.save();
                    var cacheAlpha = displayObject.mask.alpha;
                    var maskTransform = displayObject.mask.worldTransform;
                    context.setTransform(maskTransform[0], maskTransform[3], maskTransform[1], maskTransform[4], maskTransform[2], maskTransform[5]);
                    displayObject.mask.worldAlpha = .5;
                    context.worldAlpha = 0;
                    PIXI.CanvasGraphics.renderGraphicsMask(displayObject.mask, context);
                    context.clip();
                    displayObject.mask.worldAlpha = cacheAlpha;
                } else {
                    context.restore();
                }
            }
            displayObject = displayObject._iNext;
        } while (displayObject != testObject);
    };
    PIXI.CanvasRenderer.prototype.renderStripFlat = function(strip) {
        var context = this.context;
        var verticies = strip.verticies;
        var uvs = strip.uvs;
        var length = verticies.length / 2;
        this.count++;
        context.beginPath();
        for (var i = 1; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
        }
        context.fillStyle = "#FF0000";
        context.fill();
        context.closePath();
    };
    PIXI.CanvasRenderer.prototype.renderTilingSprite = function(sprite) {
        var context = this.context;
        context.globalAlpha = sprite.worldAlpha;
        if (!sprite.__tilePattern) sprite.__tilePattern = context.createPattern(sprite.texture.baseTexture.source, "repeat");
        context.beginPath();
        var tilePosition = sprite.tilePosition;
        var tileScale = sprite.tileScale;
        context.scale(tileScale.x, tileScale.y);
        context.translate(tilePosition.x, tilePosition.y);
        context.fillStyle = sprite.__tilePattern;
        context.fillRect(-tilePosition.x, -tilePosition.y, sprite.width / tileScale.x, sprite.height / tileScale.y);
        context.scale(1 / tileScale.x, 1 / tileScale.y);
        context.translate(-tilePosition.x, -tilePosition.y);
        context.closePath();
    };
    PIXI.CanvasRenderer.prototype.renderStrip = function(strip) {
        var context = this.context;
        var verticies = strip.verticies;
        var uvs = strip.uvs;
        var length = verticies.length / 2;
        this.count++;
        for (var i = 1; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            var u0 = uvs[index] * strip.texture.width, u1 = uvs[index + 2] * strip.texture.width, u2 = uvs[index + 4] * strip.texture.width;
            var v0 = uvs[index + 1] * strip.texture.height, v1 = uvs[index + 3] * strip.texture.height, v2 = uvs[index + 5] * strip.texture.height;
            context.save();
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.clip();
            var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
            var delta_a = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
            var delta_b = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
            var delta_c = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
            var delta_d = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
            var delta_e = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
            var delta_f = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
            context.transform(delta_a / delta, delta_d / delta, delta_b / delta, delta_e / delta, delta_c / delta, delta_f / delta);
            context.drawImage(strip.texture.baseTexture.source, 0, 0);
            context.restore();
        }
    };
    PIXI.CanvasGraphics = function() {};
    PIXI.CanvasGraphics.renderGraphics = function(graphics, context) {
        var worldAlpha = graphics.worldAlpha;
        for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var points = data.points;
            context.strokeStyle = color = "#" + ("00000" + (data.lineColor | 0).toString(16)).substr(-6);
            context.lineWidth = data.lineWidth;
            if (data.type == PIXI.Graphics.POLY) {
                context.beginPath();
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (points[0] == points[points.length - 2] && points[1] == points[points.length - 1]) {
                    context.closePath();
                }
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type == PIXI.Graphics.RECT) {
                if (data.fillColor) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fillRect(points[0], points[1], points[2], points[3]);
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeRect(points[0], points[1], points[2], points[3]);
                }
            } else if (data.type == PIXI.Graphics.CIRC) {
                context.beginPath();
                context.arc(points[0], points[1], points[2], 0, 2 * Math.PI);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type == PIXI.Graphics.ELIP) {
                var elipseData = data.points;
                var w = elipseData[2] * 2;
                var h = elipseData[3] * 2;
                var x = elipseData[0] - w / 2;
                var y = elipseData[1] - h / 2;
                context.beginPath();
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            }
        }
    };
    PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context) {
        var worldAlpha = graphics.worldAlpha;
        var len = graphics.graphicsData.length;
        if (len > 1) {
            len = 1;
            console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object");
        }
        for (var i = 0; i < 1; i++) {
            var data = graphics.graphicsData[i];
            var points = data.points;
            if (data.type == PIXI.Graphics.POLY) {
                context.beginPath();
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (points[0] == points[points.length - 2] && points[1] == points[points.length - 1]) {
                    context.closePath();
                }
            } else if (data.type == PIXI.Graphics.RECT) {
                context.beginPath();
                context.rect(points[0], points[1], points[2], points[3]);
                context.closePath();
            } else if (data.type == PIXI.Graphics.CIRC) {
                context.beginPath();
                context.arc(points[0], points[1], points[2], 0, 2 * Math.PI);
                context.closePath();
            } else if (data.type == PIXI.Graphics.ELIP) {
                var elipseData = data.points;
                var w = elipseData[2] * 2;
                var h = elipseData[3] * 2;
                var x = elipseData[0] - w / 2;
                var y = elipseData[1] - h / 2;
                context.beginPath();
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
            }
        }
    };
    PIXI.Graphics = function() {
        PIXI.DisplayObjectContainer.call(this);
        this.renderable = true;
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = "black";
        this.graphicsData = [];
        this.currentPath = {
            points: []
        };
    };
    PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Graphics.prototype.constructor = PIXI.Graphics;
    PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha) {
        if (this.currentPath.points.length == 0) this.graphicsData.pop();
        this.lineWidth = lineWidth || 0;
        this.lineColor = color || 0;
        this.lineAlpha = alpha == undefined ? 1 : alpha;
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath);
    };
    PIXI.Graphics.prototype.moveTo = function(x, y) {
        if (this.currentPath.points.length == 0) this.graphicsData.pop();
        this.currentPath = this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.currentPath.points.push(x, y);
        this.graphicsData.push(this.currentPath);
    };
    PIXI.Graphics.prototype.lineTo = function(x, y) {
        this.currentPath.points.push(x, y);
        this.dirty = true;
    };
    PIXI.Graphics.prototype.beginFill = function(color, alpha) {
        this.filling = true;
        this.fillColor = color || 0;
        this.fillAlpha = alpha == undefined ? 1 : alpha;
    };
    PIXI.Graphics.prototype.endFill = function() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;
    };
    PIXI.Graphics.prototype.drawRect = function(x, y, width, height) {
        if (this.currentPath.points.length == 0) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height ],
            type: PIXI.Graphics.RECT
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
    };
    PIXI.Graphics.prototype.drawCircle = function(x, y, radius) {
        if (this.currentPath.points.length == 0) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, radius, radius ],
            type: PIXI.Graphics.CIRC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
    };
    PIXI.Graphics.prototype.drawElipse = function(x, y, width, height) {
        if (this.currentPath.points.length == 0) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height ],
            type: PIXI.Graphics.ELIP
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
    };
    PIXI.Graphics.prototype.clear = function() {
        this.lineWidth = 0;
        this.filling = false;
        this.dirty = true;
        this.clearDirty = true;
        this.graphicsData = [];
    };
    PIXI.Graphics.POLY = 0;
    PIXI.Graphics.RECT = 1;
    PIXI.Graphics.CIRC = 2;
    PIXI.Graphics.ELIP = 3;
    PIXI.Strip = function(texture, width, height) {
        PIXI.DisplayObjectContainer.call(this);
        this.texture = texture;
        this.blendMode = PIXI.blendModes.NORMAL;
        try {
            this.uvs = new Float32Array([ 0, 1, 1, 1, 1, 0, 0, 1 ]);
            this.verticies = new Float32Array([ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]);
            this.colors = new Float32Array([ 1, 1, 1, 1 ]);
            this.indices = new Uint16Array([ 0, 1, 2, 3 ]);
        } catch (error) {
            this.uvs = [ 0, 1, 1, 1, 1, 0, 0, 1 ];
            this.verticies = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
            this.colors = [ 1, 1, 1, 1 ];
            this.indices = [ 0, 1, 2, 3 ];
        }
        this.width = width;
        this.height = height;
        if (texture.baseTexture.hasLoaded) {
            this.width = this.texture.frame.width;
            this.height = this.texture.frame.height;
            this.updateFrame = true;
        } else {
            this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
            this.texture.addEventListener("update", this.onTextureUpdateBind);
        }
        this.renderable = true;
    };
    PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Strip.prototype.constructor = PIXI.Strip;
    PIXI.Strip.prototype.setTexture = function(texture) {
        this.texture = texture;
        this.width = texture.frame.width;
        this.height = texture.frame.height;
        this.updateFrame = true;
    };
    PIXI.Strip.prototype.onTextureUpdate = function(event) {
        this.updateFrame = true;
    };
    PIXI.Rope = function(texture, points) {
        PIXI.Strip.call(this, texture);
        this.points = points;
        try {
            this.verticies = new Float32Array(points.length * 4);
            this.uvs = new Float32Array(points.length * 4);
            this.colors = new Float32Array(points.length * 2);
            this.indices = new Uint16Array(points.length * 2);
        } catch (error) {
            this.verticies = verticies;
            this.uvs = uvs;
            this.colors = colors;
            this.indices = indices;
        }
        this.refresh();
    };
    PIXI.Rope.prototype = Object.create(PIXI.Strip.prototype);
    PIXI.Rope.prototype.constructor = PIXI.Rope;
    PIXI.Rope.prototype.refresh = function() {
        var points = this.points;
        if (points.length < 1) return;
        var uvs = this.uvs;
        var indices = this.indices;
        var colors = this.colors;
        var lastPoint = points[0];
        var nextPoint;
        var perp = {
            x: 0,
            y: 0
        };
        var point = points[0];
        this.count -= .2;
        uvs[0] = 0;
        uvs[1] = 1;
        uvs[2] = 0;
        uvs[3] = 1;
        colors[0] = 1;
        colors[1] = 1;
        indices[0] = 0;
        indices[1] = 1;
        var total = points.length;
        for (var i = 1; i < total; i++) {
            var point = points[i];
            var index = i * 4;
            var amount = i / (total - 1);
            if (i % 2) {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            } else {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            }
            index = i * 2;
            colors[index] = 1;
            colors[index + 1] = 1;
            index = i * 2;
            indices[index] = index;
            indices[index + 1] = index + 1;
            lastPoint = point;
        }
    };
    PIXI.Rope.prototype.updateTransform = function() {
        var points = this.points;
        if (points.length < 1) return;
        var verticies = this.verticies;
        var lastPoint = points[0];
        var nextPoint;
        var perp = {
            x: 0,
            y: 0
        };
        var point = points[0];
        this.count -= .2;
        verticies[0] = point.x + perp.x;
        verticies[1] = point.y + perp.y;
        verticies[2] = point.x - perp.x;
        verticies[3] = point.y - perp.y;
        var total = points.length;
        for (var i = 1; i < total; i++) {
            var point = points[i];
            var index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            } else {
                nextPoint = point;
            }
            perp.y = -(nextPoint.x - lastPoint.x);
            perp.x = nextPoint.y - lastPoint.y;
            var ratio = (1 - i / (total - 1)) * 10;
            if (ratio > 1) ratio = 1;
            var perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);
            var num = this.texture.height / 2;
            perp.x /= perpLength;
            perp.y /= perpLength;
            perp.x *= num;
            perp.y *= num;
            verticies[index] = point.x + perp.x;
            verticies[index + 1] = point.y + perp.y;
            verticies[index + 2] = point.x - perp.x;
            verticies[index + 3] = point.y - perp.y;
            lastPoint = point;
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.Rope.prototype.setTexture = function(texture) {
        this.texture = texture;
        this.updateFrame = true;
    };
    PIXI.TilingSprite = function(texture, width, height) {
        PIXI.DisplayObjectContainer.call(this);
        this.texture = texture;
        this.width = width;
        this.height = height;
        this.tileScale = new PIXI.Point(1, 1);
        this.tilePosition = new PIXI.Point(0, 0);
        this.renderable = true;
        this.blendMode = PIXI.blendModes.NORMAL;
    };
    PIXI.TilingSprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;
    PIXI.TilingSprite.prototype.setTexture = function(texture) {
        this.texture = texture;
        this.updateFrame = true;
    };
    PIXI.TilingSprite.prototype.onTextureUpdate = function(event) {
        this.updateFrame = true;
    };
    PIXI.Spine = function(url) {
        PIXI.DisplayObjectContainer.call(this);
        this.spineData = PIXI.AnimCache[url];
        if (!this.spineData) {
            throw new Error("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + url);
        }
        this.skeleton = new spine.Skeleton(this.spineData);
        this.skeleton.updateWorldTransform();
        this.stateData = new spine.AnimationStateData(this.spineData);
        this.state = new spine.AnimationState(this.stateData);
        this.slotContainers = [];
        for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) {
            var slot = this.skeleton.drawOrder[i];
            var attachment = slot.attachment;
            var slotContainer = new PIXI.DisplayObjectContainer;
            this.slotContainers.push(slotContainer);
            this.addChild(slotContainer);
            if (!(attachment instanceof spine.RegionAttachment)) {
                continue;
            }
            var spriteName = attachment.rendererObject.name;
            var sprite = this.createSprite(slot, attachment.rendererObject);
            slot.currentSprite = sprite;
            slot.currentSpriteName = spriteName;
            slotContainer.addChild(sprite);
        }
    };
    PIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Spine.prototype.constructor = PIXI.Spine;
    PIXI.Spine.prototype.updateTransform = function() {
        this.lastTime = this.lastTime || Date.now();
        var timeDelta = (Date.now() - this.lastTime) * .001;
        this.lastTime = Date.now();
        this.state.update(timeDelta);
        this.state.apply(this.skeleton);
        this.skeleton.updateWorldTransform();
        var drawOrder = this.skeleton.drawOrder;
        for (var i = 0, n = drawOrder.length; i < n; i++) {
            var slot = drawOrder[i];
            var attachment = slot.attachment;
            var slotContainer = this.slotContainers[i];
            if (!(attachment instanceof spine.RegionAttachment)) {
                slotContainer.visible = false;
                continue;
            }
            if (attachment.rendererObject) {
                if (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) {
                    var spriteName = attachment.rendererObject.name;
                    if (slot.currentSprite !== undefined) {
                        slot.currentSprite.visible = false;
                    }
                    slot.sprites = slot.sprites || {};
                    if (slot.sprites[spriteName] !== undefined) {
                        slot.sprites[spriteName].visible = true;
                    } else {
                        var sprite = this.createSprite(slot, attachment.rendererObject);
                        slotContainer.addChild(sprite);
                    }
                    slot.currentSprite = slot.sprites[spriteName];
                    slot.currentSpriteName = spriteName;
                }
            }
            slotContainer.visible = true;
            var bone = slot.bone;
            slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;
            slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;
            slotContainer.scale.x = bone.worldScaleX;
            slotContainer.scale.y = bone.worldScaleY;
            slotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180);
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.Spine.prototype.createSprite = function(slot, descriptor) {
        var name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + ".png";
        var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name));
        sprite.scale = descriptor.scale;
        sprite.rotation = descriptor.rotation;
        sprite.anchor.x = sprite.anchor.y = .5;
        slot.sprites = slot.sprites || {};
        slot.sprites[descriptor.name] = sprite;
        return sprite;
    };
    var spine = {};
    spine.BoneData = function(name, parent) {
        this.name = name;
        this.parent = parent;
    };
    spine.BoneData.prototype = {
        length: 0,
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1
    };
    spine.SlotData = function(name, boneData) {
        this.name = name;
        this.boneData = boneData;
    };
    spine.SlotData.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        attachmentName: null
    };
    spine.Bone = function(boneData, parent) {
        this.data = boneData;
        this.parent = parent;
        this.setToSetupPose();
    };
    spine.Bone.yDown = false;
    spine.Bone.prototype = {
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        m00: 0,
        m01: 0,
        worldX: 0,
        m10: 0,
        m11: 0,
        worldY: 0,
        worldRotation: 0,
        worldScaleX: 1,
        worldScaleY: 1,
        updateWorldTransform: function(flipX, flipY) {
            var parent = this.parent;
            if (parent != null) {
                this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
                this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
                this.worldScaleX = parent.worldScaleX * this.scaleX;
                this.worldScaleY = parent.worldScaleY * this.scaleY;
                this.worldRotation = parent.worldRotation + this.rotation;
            } else {
                this.worldX = this.x;
                this.worldY = this.y;
                this.worldScaleX = this.scaleX;
                this.worldScaleY = this.scaleY;
                this.worldRotation = this.rotation;
            }
            var radians = this.worldRotation * Math.PI / 180;
            var cos = Math.cos(radians);
            var sin = Math.sin(radians);
            this.m00 = cos * this.worldScaleX;
            this.m10 = sin * this.worldScaleX;
            this.m01 = -sin * this.worldScaleY;
            this.m11 = cos * this.worldScaleY;
            if (flipX) {
                this.m00 = -this.m00;
                this.m01 = -this.m01;
            }
            if (flipY) {
                this.m10 = -this.m10;
                this.m11 = -this.m11;
            }
            if (spine.Bone.yDown) {
                this.m10 = -this.m10;
                this.m11 = -this.m11;
            }
        },
        setToSetupPose: function() {
            var data = this.data;
            this.x = data.x;
            this.y = data.y;
            this.rotation = data.rotation;
            this.scaleX = data.scaleX;
            this.scaleY = data.scaleY;
        }
    };
    spine.Slot = function(slotData, skeleton, bone) {
        this.data = slotData;
        this.skeleton = skeleton;
        this.bone = bone;
        this.setToSetupPose();
    };
    spine.Slot.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        _attachmentTime: 0,
        attachment: null,
        setAttachment: function(attachment) {
            this.attachment = attachment;
            this._attachmentTime = this.skeleton.time;
        },
        setAttachmentTime: function(time) {
            this._attachmentTime = this.skeleton.time - time;
        },
        getAttachmentTime: function() {
            return this.skeleton.time - this._attachmentTime;
        },
        setToSetupPose: function() {
            var data = this.data;
            this.r = data.r;
            this.g = data.g;
            this.b = data.b;
            this.a = data.a;
            var slotDatas = this.skeleton.data.slots;
            for (var i = 0, n = slotDatas.length; i < n; i++) {
                if (slotDatas[i] == data) {
                    this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
                    break;
                }
            }
        }
    };
    spine.Skin = function(name) {
        this.name = name;
        this.attachments = {};
    };
    spine.Skin.prototype = {
        addAttachment: function(slotIndex, name, attachment) {
            this.attachments[slotIndex + ":" + name] = attachment;
        },
        getAttachment: function(slotIndex, name) {
            return this.attachments[slotIndex + ":" + name];
        },
        _attachAll: function(skeleton, oldSkin) {
            for (var key in oldSkin.attachments) {
                var colon = key.indexOf(":");
                var slotIndex = parseInt(key.substring(0, colon));
                var name = key.substring(colon + 1);
                var slot = skeleton.slots[slotIndex];
                if (slot.attachment && slot.attachment.name == name) {
                    var attachment = this.getAttachment(slotIndex, name);
                    if (attachment) slot.setAttachment(attachment);
                }
            }
        }
    };
    spine.Animation = function(name, timelines, duration) {
        this.name = name;
        this.timelines = timelines;
        this.duration = duration;
    };
    spine.Animation.prototype = {
        apply: function(skeleton, time, loop) {
            if (loop && this.duration != 0) time %= this.duration;
            var timelines = this.timelines;
            for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, time, 1);
        },
        mix: function(skeleton, time, loop, alpha) {
            if (loop && this.duration != 0) time %= this.duration;
            var timelines = this.timelines;
            for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, time, alpha);
        }
    };
    spine.binarySearch = function(values, target, step) {
        var low = 0;
        var high = Math.floor(values.length / step) - 2;
        if (high == 0) return step;
        var current = high >>> 1;
        while (true) {
            if (values[(current + 1) * step] <= target) low = current + 1; else high = current;
            if (low == high) return (low + 1) * step;
            current = low + high >>> 1;
        }
    };
    spine.linearSearch = function(values, target, step) {
        for (var i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;
        return -1;
    };
    spine.Curves = function(frameCount) {
        this.curves = [];
        this.curves.length = (frameCount - 1) * 6;
    };
    spine.Curves.prototype = {
        setLinear: function(frameIndex) {
            this.curves[frameIndex * 6] = 0;
        },
        setStepped: function(frameIndex) {
            this.curves[frameIndex * 6] = -1;
        },
        setCurve: function(frameIndex, cx1, cy1, cx2, cy2) {
            var subdiv_step = 1 / 10;
            var subdiv_step2 = subdiv_step * subdiv_step;
            var subdiv_step3 = subdiv_step2 * subdiv_step;
            var pre1 = 3 * subdiv_step;
            var pre2 = 3 * subdiv_step2;
            var pre4 = 6 * subdiv_step2;
            var pre5 = 6 * subdiv_step3;
            var tmp1x = -cx1 * 2 + cx2;
            var tmp1y = -cy1 * 2 + cy2;
            var tmp2x = (cx1 - cx2) * 3 + 1;
            var tmp2y = (cy1 - cy2) * 3 + 1;
            var i = frameIndex * 6;
            var curves = this.curves;
            curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
            curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
            curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
            curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
            curves[i + 4] = tmp2x * pre5;
            curves[i + 5] = tmp2y * pre5;
        },
        getCurvePercent: function(frameIndex, percent) {
            percent = percent < 0 ? 0 : percent > 1 ? 1 : percent;
            var curveIndex = frameIndex * 6;
            var curves = this.curves;
            var dfx = curves[curveIndex];
            if (!dfx) return percent;
            if (dfx == -1) return 0;
            var dfy = curves[curveIndex + 1];
            var ddfx = curves[curveIndex + 2];
            var ddfy = curves[curveIndex + 3];
            var dddfx = curves[curveIndex + 4];
            var dddfy = curves[curveIndex + 5];
            var x = dfx, y = dfy;
            var i = 10 - 2;
            while (true) {
                if (x >= percent) {
                    var lastX = x - dfx;
                    var lastY = y - dfy;
                    return lastY + (y - lastY) * (percent - lastX) / (x - lastX);
                }
                if (i == 0) break;
                i--;
                dfx += ddfx;
                dfy += ddfy;
                ddfx += dddfx;
                ddfy += dddfy;
                x += dfx;
                y += dfy;
            }
            return y + (1 - y) * (percent - x) / (1 - x);
        }
    };
    spine.RotateTimeline = function(frameCount) {
        this.curves = new spine.Curves(frameCount);
        this.frames = [];
        this.frames.length = frameCount * 2;
    };
    spine.RotateTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 2;
        },
        setFrame: function(frameIndex, time, angle) {
            frameIndex *= 2;
            this.frames[frameIndex] = time;
            this.frames[frameIndex + 1] = angle;
        },
        apply: function(skeleton, time, alpha) {
            var frames = this.frames;
            if (time < frames[0]) return;
            var bone = skeleton.bones[this.boneIndex];
            if (time >= frames[frames.length - 2]) {
                var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
                while (amount > 180) amount -= 360;
                while (amount < -180) amount += 360;
                bone.rotation += amount * alpha;
                return;
            }
            var frameIndex = spine.binarySearch(frames, time, 2);
            var lastFrameValue = frames[frameIndex - 1];
            var frameTime = frames[frameIndex];
            var percent = 1 - (time - frameTime) / (frames[frameIndex - 2] - frameTime);
            percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);
            var amount = frames[frameIndex + 1] - lastFrameValue;
            while (amount > 180) amount -= 360;
            while (amount < -180) amount += 360;
            amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
            while (amount > 180) amount -= 360;
            while (amount < -180) amount += 360;
            bone.rotation += amount * alpha;
        }
    };
    spine.TranslateTimeline = function(frameCount) {
        this.curves = new spine.Curves(frameCount);
        this.frames = [];
        this.frames.length = frameCount * 3;
    };
    spine.TranslateTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 3;
        },
        setFrame: function(frameIndex, time, x, y) {
            frameIndex *= 3;
            this.frames[frameIndex] = time;
            this.frames[frameIndex + 1] = x;
            this.frames[frameIndex + 2] = y;
        },
        apply: function(skeleton, time, alpha) {
            var frames = this.frames;
            if (time < frames[0]) return;
            var bone = skeleton.bones[this.boneIndex];
            if (time >= frames[frames.length - 3]) {
                bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
                bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
                return;
            }
            var frameIndex = spine.binarySearch(frames, time, 3);
            var lastFrameX = frames[frameIndex - 2];
            var lastFrameY = frames[frameIndex - 1];
            var frameTime = frames[frameIndex];
            var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime);
            percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);
            bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1] - lastFrameX) * percent - bone.x) * alpha;
            bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2] - lastFrameY) * percent - bone.y) * alpha;
        }
    };
    spine.ScaleTimeline = function(frameCount) {
        this.curves = new spine.Curves(frameCount);
        this.frames = [];
        this.frames.length = frameCount * 3;
    };
    spine.ScaleTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 3;
        },
        setFrame: function(frameIndex, time, x, y) {
            frameIndex *= 3;
            this.frames[frameIndex] = time;
            this.frames[frameIndex + 1] = x;
            this.frames[frameIndex + 2] = y;
        },
        apply: function(skeleton, time, alpha) {
            var frames = this.frames;
            if (time < frames[0]) return;
            var bone = skeleton.bones[this.boneIndex];
            if (time >= frames[frames.length - 3]) {
                bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
                bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
                return;
            }
            var frameIndex = spine.binarySearch(frames, time, 3);
            var lastFrameX = frames[frameIndex - 2];
            var lastFrameY = frames[frameIndex - 1];
            var frameTime = frames[frameIndex];
            var percent = 1 - (time - frameTime) / (frames[frameIndex + -3] - frameTime);
            percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);
            bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1] - lastFrameX) * percent - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2] - lastFrameY) * percent - bone.scaleY) * alpha;
        }
    };
    spine.ColorTimeline = function(frameCount) {
        this.curves = new spine.Curves(frameCount);
        this.frames = [];
        this.frames.length = frameCount * 5;
    };
    spine.ColorTimeline.prototype = {
        slotIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 2;
        },
        setFrame: function(frameIndex, time, x, y) {
            frameIndex *= 5;
            this.frames[frameIndex] = time;
            this.frames[frameIndex + 1] = r;
            this.frames[frameIndex + 2] = g;
            this.frames[frameIndex + 3] = b;
            this.frames[frameIndex + 4] = a;
        },
        apply: function(skeleton, time, alpha) {
            var frames = this.frames;
            if (time < frames[0]) return;
            var slot = skeleton.slots[this.slotIndex];
            if (time >= frames[frames.length - 5]) {
                var i = frames.length - 1;
                slot.r = frames[i - 3];
                slot.g = frames[i - 2];
                slot.b = frames[i - 1];
                slot.a = frames[i];
                return;
            }
            var frameIndex = spine.binarySearch(frames, time, 5);
            var lastFrameR = frames[frameIndex - 4];
            var lastFrameG = frames[frameIndex - 3];
            var lastFrameB = frames[frameIndex - 2];
            var lastFrameA = frames[frameIndex - 1];
            var frameTime = frames[frameIndex];
            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5] - frameTime);
            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);
            var r = lastFrameR + (frames[frameIndex + 1] - lastFrameR) * percent;
            var g = lastFrameG + (frames[frameIndex + 2] - lastFrameG) * percent;
            var b = lastFrameB + (frames[frameIndex + 3] - lastFrameB) * percent;
            var a = lastFrameA + (frames[frameIndex + 4] - lastFrameA) * percent;
            if (alpha < 1) {
                slot.r += (r - slot.r) * alpha;
                slot.g += (g - slot.g) * alpha;
                slot.b += (b - slot.b) * alpha;
                slot.a += (a - slot.a) * alpha;
            } else {
                slot.r = r;
                slot.g = g;
                slot.b = b;
                slot.a = a;
            }
        }
    };
    spine.AttachmentTimeline = function(frameCount) {
        this.curves = new spine.Curves(frameCount);
        this.frames = [];
        this.frames.length = frameCount;
        this.attachmentNames = [];
        this.attachmentNames.length = frameCount;
    };
    spine.AttachmentTimeline.prototype = {
        slotIndex: 0,
        getFrameCount: function() {
            return this.frames.length;
        },
        setFrame: function(frameIndex, time, attachmentName) {
            this.frames[frameIndex] = time;
            this.attachmentNames[frameIndex] = attachmentName;
        },
        apply: function(skeleton, time, alpha) {
            var frames = this.frames;
            if (time < frames[0]) return;
            var frameIndex;
            if (time >= frames[frames.length - 1]) frameIndex = frames.length - 1; else frameIndex = spine.binarySearch(frames, time, 1) - 1;
            var attachmentName = this.attachmentNames[frameIndex];
            skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
        }
    };
    spine.SkeletonData = function() {
        this.bones = [];
        this.slots = [];
        this.skins = [];
        this.animations = [];
    };
    spine.SkeletonData.prototype = {
        defaultSkin: null,
        findBone: function(boneName) {
            var bones = this.bones;
            for (var i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return bones[i];
            return null;
        },
        findBoneIndex: function(boneName) {
            var bones = this.bones;
            for (var i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;
            return -1;
        },
        findSlot: function(slotName) {
            var slots = this.slots;
            for (var i = 0, n = slots.length; i < n; i++) {
                if (slots[i].name == slotName) return slot[i];
            }
            return null;
        },
        findSlotIndex: function(slotName) {
            var slots = this.slots;
            for (var i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;
            return -1;
        },
        findSkin: function(skinName) {
            var skins = this.skins;
            for (var i = 0, n = skins.length; i < n; i++) if (skins[i].name == skinName) return skins[i];
            return null;
        },
        findAnimation: function(animationName) {
            var animations = this.animations;
            for (var i = 0, n = animations.length; i < n; i++) if (animations[i].name == animationName) return animations[i];
            return null;
        }
    };
    spine.Skeleton = function(skeletonData) {
        this.data = skeletonData;
        this.bones = [];
        for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
            var boneData = skeletonData.bones[i];
            var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
            this.bones.push(new spine.Bone(boneData, parent));
        }
        this.slots = [];
        this.drawOrder = [];
        for (var i = 0, n = skeletonData.slots.length; i < n; i++) {
            var slotData = skeletonData.slots[i];
            var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
            var slot = new spine.Slot(slotData, this, bone);
            this.slots.push(slot);
            this.drawOrder.push(slot);
        }
    };
    spine.Skeleton.prototype = {
        x: 0,
        y: 0,
        skin: null,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        time: 0,
        flipX: false,
        flipY: false,
        updateWorldTransform: function() {
            var flipX = this.flipX;
            var flipY = this.flipY;
            var bones = this.bones;
            for (var i = 0, n = bones.length; i < n; i++) bones[i].updateWorldTransform(flipX, flipY);
        },
        setToSetupPose: function() {
            this.setBonesToSetupPose();
            this.setSlotsToSetupPose();
        },
        setBonesToSetupPose: function() {
            var bones = this.bones;
            for (var i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();
        },
        setSlotsToSetupPose: function() {
            var slots = this.slots;
            for (var i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose(i);
        },
        getRootBone: function() {
            return this.bones.length == 0 ? null : this.bones[0];
        },
        findBone: function(boneName) {
            var bones = this.bones;
            for (var i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return bones[i];
            return null;
        },
        findBoneIndex: function(boneName) {
            var bones = this.bones;
            for (var i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;
            return -1;
        },
        findSlot: function(slotName) {
            var slots = this.slots;
            for (var i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return slots[i];
            return null;
        },
        findSlotIndex: function(slotName) {
            var slots = this.slots;
            for (var i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;
            return -1;
        },
        setSkinByName: function(skinName) {
            var skin = this.data.findSkin(skinName);
            if (!skin) throw "Skin not found: " + skinName;
            this.setSkin(skin);
        },
        setSkin: function(newSkin) {
            if (this.skin && newSkin) newSkin._attachAll(this, this.skin);
            this.skin = newSkin;
        },
        getAttachmentBySlotName: function(slotName, attachmentName) {
            return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
        },
        getAttachmentBySlotIndex: function(slotIndex, attachmentName) {
            if (this.skin) {
                var attachment = this.skin.getAttachment(slotIndex, attachmentName);
                if (attachment) return attachment;
            }
            if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
            return null;
        },
        setAttachment: function(slotName, attachmentName) {
            var slots = this.slots;
            for (var i = 0, n = slots.size; i < n; i++) {
                var slot = slots[i];
                if (slot.data.name == slotName) {
                    var attachment = null;
                    if (attachmentName) {
                        attachment = this.getAttachment(i, attachmentName);
                        if (attachment == null) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
                    }
                    slot.setAttachment(attachment);
                    return;
                }
            }
            throw "Slot not found: " + slotName;
        },
        update: function(delta) {
            time += delta;
        }
    };
    spine.AttachmentType = {
        region: 0
    };
    spine.RegionAttachment = function() {
        this.offset = [];
        this.offset.length = 8;
        this.uvs = [];
        this.uvs.length = 8;
    };
    spine.RegionAttachment.prototype = {
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        width: 0,
        height: 0,
        rendererObject: null,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        setUVs: function(u, v, u2, v2, rotate) {
            var uvs = this.uvs;
            if (rotate) {
                uvs[2] = u;
                uvs[3] = v2;
                uvs[4] = u;
                uvs[5] = v;
                uvs[6] = u2;
                uvs[7] = v;
                uvs[0] = u2;
                uvs[1] = v2;
            } else {
                uvs[0] = u;
                uvs[1] = v2;
                uvs[2] = u;
                uvs[3] = v;
                uvs[4] = u2;
                uvs[5] = v;
                uvs[6] = u2;
                uvs[7] = v2;
            }
        },
        updateOffset: function() {
            var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
            var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
            var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
            var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
            var localX2 = localX + this.regionWidth * regionScaleX;
            var localY2 = localY + this.regionHeight * regionScaleY;
            var radians = this.rotation * Math.PI / 180;
            var cos = Math.cos(radians);
            var sin = Math.sin(radians);
            var localXCos = localX * cos + this.x;
            var localXSin = localX * sin;
            var localYCos = localY * cos + this.y;
            var localYSin = localY * sin;
            var localX2Cos = localX2 * cos + this.x;
            var localX2Sin = localX2 * sin;
            var localY2Cos = localY2 * cos + this.y;
            var localY2Sin = localY2 * sin;
            var offset = this.offset;
            offset[0] = localXCos - localYSin;
            offset[1] = localYCos + localXSin;
            offset[2] = localXCos - localY2Sin;
            offset[3] = localY2Cos + localXSin;
            offset[4] = localX2Cos - localY2Sin;
            offset[5] = localY2Cos + localX2Sin;
            offset[6] = localX2Cos - localYSin;
            offset[7] = localYCos + localX2Sin;
        },
        computeVertices: function(x, y, bone, vertices) {
            x += bone.worldX;
            y += bone.worldY;
            var m00 = bone.m00;
            var m01 = bone.m01;
            var m10 = bone.m10;
            var m11 = bone.m11;
            var offset = this.offset;
            vertices[0] = offset[0] * m00 + offset[1] * m01 + x;
            vertices[1] = offset[0] * m10 + offset[1] * m11 + y;
            vertices[2] = offset[2] * m00 + offset[3] * m01 + x;
            vertices[3] = offset[2] * m10 + offset[3] * m11 + y;
            vertices[4] = offset[4] * m00 + offset[5] * m01 + x;
            vertices[5] = offset[4] * m10 + offset[5] * m11 + y;
            vertices[6] = offset[6] * m00 + offset[7] * m01 + x;
            vertices[7] = offset[6] * m10 + offset[7] * m11 + y;
        }
    };
    spine.AnimationStateData = function(skeletonData) {
        this.skeletonData = skeletonData;
        this.animationToMixTime = {};
    };
    spine.AnimationStateData.prototype = {
        defaultMix: 0,
        setMixByName: function(fromName, toName, duration) {
            var from = this.skeletonData.findAnimation(fromName);
            if (!from) throw "Animation not found: " + fromName;
            var to = this.skeletonData.findAnimation(toName);
            if (!to) throw "Animation not found: " + toName;
            this.setMix(from, to, duration);
        },
        setMix: function(from, to, duration) {
            this.animationToMixTime[from.name + ":" + to.name] = duration;
        },
        getMix: function(from, to) {
            var time = this.animationToMixTime[from.name + ":" + to.name];
            return time ? time : this.defaultMix;
        }
    };
    spine.AnimationState = function(stateData) {
        this.data = stateData;
        this.queue = [];
    };
    spine.AnimationState.prototype = {
        current: null,
        previous: null,
        currentTime: 0,
        previousTime: 0,
        currentLoop: false,
        previousLoop: false,
        mixTime: 0,
        mixDuration: 0,
        update: function(delta) {
            this.currentTime += delta;
            this.previousTime += delta;
            this.mixTime += delta;
            if (this.queue.length > 0) {
                var entry = this.queue[0];
                if (this.currentTime >= entry.delay) {
                    this._setAnimation(entry.animation, entry.loop);
                    this.queue.shift();
                }
            }
        },
        apply: function(skeleton) {
            if (!this.current) return;
            if (this.previous) {
                this.previous.apply(skeleton, this.previousTime, this.previousLoop);
                var alpha = this.mixTime / this.mixDuration;
                if (alpha >= 1) {
                    alpha = 1;
                    this.previous = null;
                }
                this.current.mix(skeleton, this.currentTime, this.currentLoop, alpha);
            } else this.current.apply(skeleton, this.currentTime, this.currentLoop);
        },
        clearAnimation: function() {
            this.previous = null;
            this.current = null;
            this.queue.length = 0;
        },
        _setAnimation: function(animation, loop) {
            this.previous = null;
            if (animation && this.current) {
                this.mixDuration = this.data.getMix(this.current, animation);
                if (this.mixDuration > 0) {
                    this.mixTime = 0;
                    this.previous = this.current;
                    this.previousTime = this.currentTime;
                    this.previousLoop = this.currentLoop;
                }
            }
            this.current = animation;
            this.currentLoop = loop;
            this.currentTime = 0;
        },
        setAnimationByName: function(animationName, loop) {
            var animation = this.data.skeletonData.findAnimation(animationName);
            if (!animation) throw "Animation not found: " + animationName;
            this.setAnimation(animation, loop);
        },
        setAnimation: function(animation, loop) {
            this.queue.length = 0;
            this._setAnimation(animation, loop);
        },
        addAnimationByName: function(animationName, loop, delay) {
            var animation = this.data.skeletonData.findAnimation(animationName);
            if (!animation) throw "Animation not found: " + animationName;
            this.addAnimation(animation, loop, delay);
        },
        addAnimation: function(animation, loop, delay) {
            var entry = {};
            entry.animation = animation;
            entry.loop = loop;
            if (!delay || delay <= 0) {
                var previousAnimation = this.queue.length == 0 ? this.current : this.queue[this.queue.length - 1].animation;
                if (previousAnimation != null) delay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0); else delay = 0;
            }
            entry.delay = delay;
            this.queue.push(entry);
        },
        isComplete: function() {
            return !this.current || this.currentTime >= this.current.duration;
        }
    };
    spine.SkeletonJson = function(attachmentLoader) {
        this.attachmentLoader = attachmentLoader;
    };
    spine.SkeletonJson.prototype = {
        scale: 1,
        readSkeletonData: function(root) {
            var skeletonData = new spine.SkeletonData;
            var bones = root["bones"];
            for (var i = 0, n = bones.length; i < n; i++) {
                var boneMap = bones[i];
                var parent = null;
                if (boneMap["parent"]) {
                    parent = skeletonData.findBone(boneMap["parent"]);
                    if (!parent) throw "Parent bone not found: " + boneMap["parent"];
                }
                var boneData = new spine.BoneData(boneMap["name"], parent);
                boneData.length = (boneMap["length"] || 0) * this.scale;
                boneData.x = (boneMap["x"] || 0) * this.scale;
                boneData.y = (boneMap["y"] || 0) * this.scale;
                boneData.rotation = boneMap["rotation"] || 0;
                boneData.scaleX = boneMap["scaleX"] || 1;
                boneData.scaleY = boneMap["scaleY"] || 1;
                skeletonData.bones.push(boneData);
            }
            var slots = root["slots"];
            for (var i = 0, n = slots.length; i < n; i++) {
                var slotMap = slots[i];
                var boneData = skeletonData.findBone(slotMap["bone"]);
                if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
                var slotData = new spine.SlotData(slotMap["name"], boneData);
                var color = slotMap["color"];
                if (color) {
                    slotData.r = spine.SkeletonJson.toColor(color, 0);
                    slotData.g = spine.SkeletonJson.toColor(color, 1);
                    slotData.b = spine.SkeletonJson.toColor(color, 2);
                    slotData.a = spine.SkeletonJson.toColor(color, 3);
                }
                slotData.attachmentName = slotMap["attachment"];
                skeletonData.slots.push(slotData);
            }
            var skins = root["skins"];
            for (var skinName in skins) {
                if (!skins.hasOwnProperty(skinName)) continue;
                var skinMap = skins[skinName];
                var skin = new spine.Skin(skinName);
                for (var slotName in skinMap) {
                    if (!skinMap.hasOwnProperty(slotName)) continue;
                    var slotIndex = skeletonData.findSlotIndex(slotName);
                    var slotEntry = skinMap[slotName];
                    for (var attachmentName in slotEntry) {
                        if (!slotEntry.hasOwnProperty(attachmentName)) continue;
                        var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
                        if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);
                    }
                }
                skeletonData.skins.push(skin);
                if (skin.name == "default") skeletonData.defaultSkin = skin;
            }
            var animations = root["animations"];
            for (var animationName in animations) {
                if (!animations.hasOwnProperty(animationName)) continue;
                this.readAnimation(animationName, animations[animationName], skeletonData);
            }
            return skeletonData;
        },
        readAttachment: function(skin, name, map) {
            name = map["name"] || name;
            var type = spine.AttachmentType[map["type"] || "region"];
            if (type == spine.AttachmentType.region) {
                var attachment = new spine.RegionAttachment;
                attachment.x = (map["x"] || 0) * this.scale;
                attachment.y = (map["y"] || 0) * this.scale;
                attachment.scaleX = map["scaleX"] || 1;
                attachment.scaleY = map["scaleY"] || 1;
                attachment.rotation = map["rotation"] || 0;
                attachment.width = (map["width"] || 32) * this.scale;
                attachment.height = (map["height"] || 32) * this.scale;
                attachment.updateOffset();
                attachment.rendererObject = {};
                attachment.rendererObject.name = name;
                attachment.rendererObject.scale = {};
                attachment.rendererObject.scale.x = attachment.scaleX;
                attachment.rendererObject.scale.y = attachment.scaleY;
                attachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180;
                return attachment;
            }
            throw "Unknown attachment type: " + type;
        },
        readAnimation: function(name, map, skeletonData) {
            var timelines = [];
            var duration = 0;
            var bones = map["bones"];
            for (var boneName in bones) {
                if (!bones.hasOwnProperty(boneName)) continue;
                var boneIndex = skeletonData.findBoneIndex(boneName);
                if (boneIndex == -1) throw "Bone not found: " + boneName;
                var boneMap = bones[boneName];
                for (var timelineName in boneMap) {
                    if (!boneMap.hasOwnProperty(timelineName)) continue;
                    var values = boneMap[timelineName];
                    if (timelineName == "rotate") {
                        var timeline = new spine.RotateTimeline(values.length);
                        timeline.boneIndex = boneIndex;
                        var frameIndex = 0;
                        for (var i = 0, n = values.length; i < n; i++) {
                            var valueMap = values[i];
                            timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
                            spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                            frameIndex++;
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);
                    } else if (timelineName == "translate" || timelineName == "scale") {
                        var timeline;
                        var timelineScale = 1;
                        if (timelineName == "scale") timeline = new spine.ScaleTimeline(values.length); else {
                            timeline = new spine.TranslateTimeline(values.length);
                            timelineScale = this.scale;
                        }
                        timeline.boneIndex = boneIndex;
                        var frameIndex = 0;
                        for (var i = 0, n = values.length; i < n; i++) {
                            var valueMap = values[i];
                            var x = (valueMap["x"] || 0) * timelineScale;
                            var y = (valueMap["y"] || 0) * timelineScale;
                            timeline.setFrame(frameIndex, valueMap["time"], x, y);
                            spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                            frameIndex++;
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);
                    } else throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
                }
            }
            var slots = map["slots"];
            for (var slotName in slots) {
                if (!slots.hasOwnProperty(slotName)) continue;
                var slotMap = slots[slotName];
                var slotIndex = skeletonData.findSlotIndex(slotName);
                for (var timelineName in slotMap) {
                    if (!slotMap.hasOwnProperty(timelineName)) continue;
                    var values = slotMap[timelineName];
                    if (timelineName == "color") {
                        var timeline = new spine.ColorTimeline(values.length);
                        timeline.slotIndex = slotIndex;
                        var frameIndex = 0;
                        for (var i = 0, n = values.length; i < n; i++) {
                            var valueMap = values[i];
                            var color = valueMap["color"];
                            var r = spine.SkeletonJson.toColor(color, 0);
                            var g = spine.SkeletonJson.toColor(color, 1);
                            var b = spine.SkeletonJson.toColor(color, 2);
                            var a = spine.SkeletonJson.toColor(color, 3);
                            timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
                            spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                            frameIndex++;
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);
                    } else if (timelineName == "attachment") {
                        var timeline = new spine.AttachmentTimeline(values.length);
                        timeline.slotIndex = slotIndex;
                        var frameIndex = 0;
                        for (var i = 0, n = values.length; i < n; i++) {
                            var valueMap = values[i];
                            timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                    } else throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
                }
            }
            skeletonData.animations.push(new spine.Animation(name, timelines, duration));
        }
    };
    spine.SkeletonJson.readCurve = function(timeline, frameIndex, valueMap) {
        var curve = valueMap["curve"];
        if (!curve) return;
        if (curve == "stepped") timeline.curves.setStepped(frameIndex); else if (curve instanceof Array) timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
    };
    spine.SkeletonJson.toColor = function(hexString, colorIndex) {
        if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
        return parseInt(hexString.substring(colorIndex * 2, 2), 16) / 255;
    };
    spine.Atlas = function(atlasText, textureLoader) {
        this.textureLoader = textureLoader;
        this.pages = [];
        this.regions = [];
        var reader = new spine.AtlasReader(atlasText);
        var tuple = [];
        tuple.length = 4;
        var page = null;
        while (true) {
            var line = reader.readLine();
            if (line == null) break;
            line = reader.trim(line);
            if (line.length == 0) page = null; else if (!page) {
                page = new spine.AtlasPage;
                page.name = line;
                page.format = spine.Atlas.Format[reader.readValue()];
                reader.readTuple(tuple);
                page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
                page.magFilter = spine.Atlas.TextureFilter[tuple[1]];
                var direction = reader.readValue();
                page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
                page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
                if (direction == "x") page.uWrap = spine.Atlas.TextureWrap.repeat; else if (direction == "y") page.vWrap = spine.Atlas.TextureWrap.repeat; else if (direction == "xy") page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;
                textureLoader.load(page, line);
                this.pages.push(page);
            } else {
                var region = new spine.AtlasRegion;
                region.name = line;
                region.page = page;
                region.rotate = reader.readValue() == "true";
                reader.readTuple(tuple);
                var x = parseInt(tuple[0]);
                var y = parseInt(tuple[1]);
                reader.readTuple(tuple);
                var width = parseInt(tuple[0]);
                var height = parseInt(tuple[1]);
                region.u = x / page.width;
                region.v = y / page.height;
                if (region.rotate) {
                    region.u2 = (x + height) / page.width;
                    region.v2 = (y + width) / page.height;
                } else {
                    region.u2 = (x + width) / page.width;
                    region.v2 = (y + height) / page.height;
                }
                region.x = x;
                region.y = y;
                region.width = Math.abs(width);
                region.height = Math.abs(height);
                if (reader.readTuple(tuple) == 4) {
                    region.splits = [ parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]) ];
                    if (reader.readTuple(tuple) == 4) {
                        region.pads = [ parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]) ];
                        reader.readTuple(tuple);
                    }
                }
                region.originalWidth = parseInt(tuple[0]);
                region.originalHeight = parseInt(tuple[1]);
                reader.readTuple(tuple);
                region.offsetX = parseInt(tuple[0]);
                region.offsetY = parseInt(tuple[1]);
                region.index = parseInt(reader.readValue());
                this.regions.push(region);
            }
        }
    };
    spine.Atlas.prototype = {
        findRegion: function(name) {
            var regions = this.regions;
            for (var i = 0, n = regions.length; i < n; i++) if (regions[i].name == name) return regions[i];
            return null;
        },
        dispose: function() {
            var pages = this.pages;
            for (var i = 0, n = pages.length; i < n; i++) this.textureLoader.unload(pages[i].rendererObject);
        },
        updateUVs: function(page) {
            var regions = this.regions;
            for (var i = 0, n = regions.length; i < n; i++) {
                var region = regions[i];
                if (region.page != page) continue;
                region.u = region.x / page.width;
                region.v = region.y / page.height;
                if (region.rotate) {
                    region.u2 = (region.x + region.height) / page.width;
                    region.v2 = (region.y + region.width) / page.height;
                } else {
                    region.u2 = (region.x + region.width) / page.width;
                    region.v2 = (region.y + region.height) / page.height;
                }
            }
        }
    };
    spine.Atlas.Format = {
        alpha: 0,
        intensity: 1,
        luminanceAlpha: 2,
        rgb565: 3,
        rgba4444: 4,
        rgb888: 5,
        rgba8888: 6
    };
    spine.Atlas.TextureFilter = {
        nearest: 0,
        linear: 1,
        mipMap: 2,
        mipMapNearestNearest: 3,
        mipMapLinearNearest: 4,
        mipMapNearestLinear: 5,
        mipMapLinearLinear: 6
    };
    spine.Atlas.TextureWrap = {
        mirroredRepeat: 0,
        clampToEdge: 1,
        repeat: 2
    };
    spine.AtlasPage = function() {};
    spine.AtlasPage.prototype = {
        name: null,
        format: null,
        minFilter: null,
        magFilter: null,
        uWrap: null,
        vWrap: null,
        rendererObject: null,
        width: 0,
        height: 0
    };
    spine.AtlasRegion = function() {};
    spine.AtlasRegion.prototype = {
        page: null,
        name: null,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        u: 0,
        v: 0,
        u2: 0,
        v2: 0,
        offsetX: 0,
        offsetY: 0,
        originalWidth: 0,
        originalHeight: 0,
        index: 0,
        rotate: false,
        splits: null,
        pads: null
    };
    spine.AtlasReader = function(text) {
        this.lines = text.split(/\r\n|\r|\n/);
    };
    spine.AtlasReader.prototype = {
        index: 0,
        trim: function(value) {
            return value.replace(/^\s+|\s+$/g, "");
        },
        readLine: function() {
            if (this.index >= this.lines.length) return null;
            return this.lines[this.index++];
        },
        readValue: function() {
            var line = this.readLine();
            var colon = line.indexOf(":");
            if (colon == -1) throw "Invalid line: " + line;
            return this.trim(line.substring(colon + 1));
        },
        readTuple: function(tuple) {
            var line = this.readLine();
            var colon = line.indexOf(":");
            if (colon == -1) throw "Invalid line: " + line;
            var i = 0, lastMatch = colon + 1;
            for (; i < 3; i++) {
                var comma = line.indexOf(",", lastMatch);
                if (comma == -1) {
                    if (i == 0) throw "Invalid line: " + line;
                    break;
                }
                tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
                lastMatch = comma + 1;
            }
            tuple[i] = this.trim(line.substring(lastMatch));
            return i + 1;
        }
    };
    spine.AtlasAttachmentLoader = function(atlas) {
        this.atlas = atlas;
    };
    spine.AtlasAttachmentLoader.prototype = {
        newAttachment: function(skin, type, name) {
            switch (type) {
              case spine.AttachmentType.region:
                var region = this.atlas.findRegion(name);
                if (!region) throw "Region not found in atlas: " + name + " (" + type + ")";
                var attachment = new spine.RegionAttachment(name);
                attachment.rendererObject = region;
                attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
                attachment.regionOffsetX = region.offsetX;
                attachment.regionOffsetY = region.offsetY;
                attachment.regionWidth = region.width;
                attachment.regionHeight = region.height;
                attachment.regionOriginalWidth = region.originalWidth;
                attachment.regionOriginalHeight = region.originalHeight;
                return attachment;
            }
            throw "Unknown attachment type: " + type;
        }
    };
    PIXI.AnimCache = {};
    spine.Bone.yDown = true;
    PIXI.CustomRenderable = function() {
        PIXI.DisplayObject.call(this);
    };
    PIXI.CustomRenderable.prototype = Object.create(PIXI.DisplayObject.prototype);
    PIXI.CustomRenderable.prototype.constructor = PIXI.CustomRenderable;
    PIXI.CustomRenderable.prototype.renderCanvas = function(renderer) {};
    PIXI.CustomRenderable.prototype.initWebGL = function(renderer) {};
    PIXI.CustomRenderable.prototype.renderWebGL = function(renderGroup, projectionMatrix) {};
    PIXI.BaseTextureCache = {};
    PIXI.texturesToUpdate = [];
    PIXI.texturesToDestroy = [];
    PIXI.BaseTexture = function(source) {
        PIXI.EventTarget.call(this);
        this.width = 100;
        this.height = 100;
        this.hasLoaded = false;
        this.source = source;
        if (!source) return;
        if (this.source instanceof Image || this.source instanceof HTMLImageElement) {
            if (this.source.complete) {
                this.hasLoaded = true;
                this.width = this.source.width;
                this.height = this.source.height;
                PIXI.texturesToUpdate.push(this);
            } else {
                var scope = this;
                this.source.onload = function() {
                    scope.hasLoaded = true;
                    scope.width = scope.source.width;
                    scope.height = scope.source.height;
                    PIXI.texturesToUpdate.push(scope);
                    scope.dispatchEvent({
                        type: "loaded",
                        content: scope
                    });
                };
            }
        } else {
            this.hasLoaded = true;
            this.width = this.source.width;
            this.height = this.source.height;
            PIXI.texturesToUpdate.push(this);
        }
        this._powerOf2 = false;
    };
    PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;
    PIXI.BaseTexture.prototype.destroy = function() {
        if (this.source instanceof Image) {
            this.source.src = null;
        }
        this.source = null;
        PIXI.texturesToDestroy.push(this);
    };
    PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin) {
        var baseTexture = PIXI.BaseTextureCache[imageUrl];
        if (!baseTexture) {
            var image = new Image;
            if (crossorigin) {
                image.crossOrigin = "";
            }
            image.src = imageUrl;
            baseTexture = new PIXI.BaseTexture(image);
            PIXI.BaseTextureCache[imageUrl] = baseTexture;
        }
        return baseTexture;
    };
    PIXI.TextureCache = {};
    PIXI.FrameCache = {};
    PIXI.Texture = function(baseTexture, frame) {
        PIXI.EventTarget.call(this);
        if (!frame) {
            this.noFrame = true;
            frame = new PIXI.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof PIXI.Texture) baseTexture = baseTexture.baseTexture;
        this.baseTexture = baseTexture;
        this.frame = frame;
        this.trim = new PIXI.Point;
        this.scope = this;
        if (baseTexture.hasLoaded) {
            if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            this.setFrame(frame);
        } else {
            var scope = this;
            baseTexture.addEventListener("loaded", function() {
                scope.onBaseTextureLoaded();
            });
        }
    };
    PIXI.Texture.prototype.constructor = PIXI.Texture;
    PIXI.Texture.prototype.onBaseTextureLoaded = function(event) {
        var baseTexture = this.baseTexture;
        baseTexture.removeEventListener("loaded", this.onLoaded);
        if (this.noFrame) this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        this.noFrame = false;
        this.width = this.frame.width;
        this.height = this.frame.height;
        this.scope.dispatchEvent({
            type: "update",
            content: this
        });
    };
    PIXI.Texture.prototype.destroy = function(destroyBase) {
        if (destroyBase) this.baseTexture.destroy();
    };
    PIXI.Texture.prototype.setFrame = function(frame) {
        this.frame = frame;
        this.width = frame.width;
        this.height = frame.height;
        if (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height) {
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
        }
        this.updateFrame = true;
        PIXI.Texture.frameUpdates.push(this);
    };
    PIXI.Texture.fromImage = function(imageUrl, crossorigin) {
        var texture = PIXI.TextureCache[imageUrl];
        if (!texture) {
            texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin));
            PIXI.TextureCache[imageUrl] = texture;
        }
        return texture;
    };
    PIXI.Texture.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error("The frameId '" + frameId + "' does not exist in the texture cache " + this);
        return texture;
    };
    PIXI.Texture.fromCanvas = function(canvas) {
        var baseTexture = new PIXI.BaseTexture(canvas);
        return new PIXI.Texture(baseTexture);
    };
    PIXI.Texture.addTextureToCache = function(texture, id) {
        PIXI.TextureCache[id] = texture;
    };
    PIXI.Texture.removeTextureFromCache = function(id) {
        var texture = PIXI.TextureCache[id];
        PIXI.TextureCache[id] = null;
        return texture;
    };
    PIXI.Texture.frameUpdates = [];
    PIXI.RenderTexture = function(width, height) {
        PIXI.EventTarget.call(this);
        this.width = width || 100;
        this.height = height || 100;
        this.indetityMatrix = PIXI.mat3.create();
        this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);
        if (PIXI.gl) {
            this.initWebGL();
        } else {
            this.initCanvas();
        }
    };
    PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);
    PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;
    PIXI.RenderTexture.prototype.initWebGL = function() {
        var gl = PIXI.gl;
        this.glFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.glFramebuffer);
        this.glFramebuffer.width = this.width;
        this.glFramebuffer.height = this.height;
        this.baseTexture = new PIXI.BaseTexture;
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
        this.baseTexture._glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        this.baseTexture.isRender = true;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.glFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.baseTexture._glTexture, 0);
        this.projection = new PIXI.Point(this.width / 2, this.height / 2);
        this.render = this.renderWebGL;
    };
    PIXI.RenderTexture.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        if (PIXI.gl) {
            this.projection.x = this.width / 2;
            this.projection.y = this.height / 2;
            var gl = PIXI.gl;
            gl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        } else {
            this.frame.width = this.width;
            this.frame.height = this.height;
            this.renderer.resize(this.width, this.height);
        }
    };
    PIXI.RenderTexture.prototype.initCanvas = function() {
        this.renderer = new PIXI.CanvasRenderer(this.width, this.height, null, 0);
        this.baseTexture = new PIXI.BaseTexture(this.renderer.view);
        this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);
        this.render = this.renderCanvas;
    };
    PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear) {
        var gl = PIXI.gl;
        gl.colorMask(true, true, true, true);
        gl.viewport(0, 0, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.glFramebuffer);
        if (clear) {
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        var children = displayObject.children;
        var originalWorldTransform = displayObject.worldTransform;
        displayObject.worldTransform = PIXI.mat3.create();
        displayObject.worldTransform[4] = -1;
        displayObject.worldTransform[5] = this.projection.y * 2;
        if (position) {
            displayObject.worldTransform[2] = position.x;
            displayObject.worldTransform[5] -= position.y;
        }
        PIXI.visibleCount++;
        displayObject.vcount = PIXI.visibleCount;
        for (var i = 0, j = children.length; i < j; i++) {
            children[i].updateTransform();
        }
        var renderGroup = displayObject.__renderGroup;
        if (renderGroup) {
            if (displayObject == renderGroup.root) {
                renderGroup.render(this.projection);
            } else {
                renderGroup.renderSpecific(displayObject, this.projection);
            }
        } else {
            if (!this.renderGroup) this.renderGroup = new PIXI.WebGLRenderGroup(gl);
            this.renderGroup.setRenderable(displayObject);
            this.renderGroup.render(this.projection);
        }
        displayObject.worldTransform = originalWorldTransform;
    };
    PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear) {
        var children = displayObject.children;
        displayObject.worldTransform = PIXI.mat3.create();
        if (position) {
            displayObject.worldTransform[2] = position.x;
            displayObject.worldTransform[5] = position.y;
        }
        for (var i = 0, j = children.length; i < j; i++) {
            children[i].updateTransform();
        }
        if (clear) this.renderer.context.clearRect(0, 0, this.width, this.height);
        this.renderer.renderDisplayObject(displayObject);
        this.renderer.context.setTransform(1, 0, 0, 1, 0, 0);
    };
    PIXI.AssetLoader = function(assetURLs, crossorigin) {
        PIXI.EventTarget.call(this);
        this.assetURLs = assetURLs;
        this.crossorigin = crossorigin;
        this.loadersByType = {
            jpg: PIXI.ImageLoader,
            jpeg: PIXI.ImageLoader,
            png: PIXI.ImageLoader,
            gif: PIXI.ImageLoader,
            json: PIXI.JsonLoader,
            anim: PIXI.SpineLoader,
            xml: PIXI.BitmapFontLoader,
            fnt: PIXI.BitmapFontLoader
        };
    };
    PIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader;
    PIXI.AssetLoader.prototype.load = function() {
        var scope = this;
        this.loadCount = this.assetURLs.length;
        for (var i = 0; i < this.assetURLs.length; i++) {
            var fileName = this.assetURLs[i];
            var fileType = fileName.split(".").pop().toLowerCase();
            var loaderClass = this.loadersByType[fileType];
            if (!loaderClass) throw new Error(fileType + " is an unsupported file type");
            var loader = new loaderClass(fileName, this.crossorigin);
            loader.addEventListener("loaded", function() {
                scope.onAssetLoaded();
            });
            loader.load();
        }
    };
    PIXI.AssetLoader.prototype.onAssetLoaded = function() {
        this.loadCount--;
        this.dispatchEvent({
            type: "onProgress",
            content: this
        });
        if (this.onProgress) this.onProgress();
        if (this.loadCount == 0) {
            this.dispatchEvent({
                type: "onComplete",
                content: this
            });
            if (this.onComplete) this.onComplete();
        }
    };
    PIXI.JsonLoader = function(url, crossorigin) {
        PIXI.EventTarget.call(this);
        this.url = url;
        this.crossorigin = crossorigin;
        this.baseUrl = url.replace(/[^\/]*$/, "");
        this.loaded = false;
    };
    PIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader;
    PIXI.JsonLoader.prototype.load = function() {
        this.ajaxRequest = new AjaxRequest;
        var scope = this;
        this.ajaxRequest.onreadystatechange = function() {
            scope.onJSONLoaded();
        };
        this.ajaxRequest.open("GET", this.url, true);
        if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType("application/json");
        this.ajaxRequest.send(null);
    };
    PIXI.JsonLoader.prototype.onJSONLoaded = function() {
        if (this.ajaxRequest.readyState == 4) {
            if (this.ajaxRequest.status == 200 || window.location.href.indexOf("http") == -1) {
                this.json = JSON.parse(this.ajaxRequest.responseText);
                if (this.json.frames) {
                    var scope = this;
                    var textureUrl = this.baseUrl + this.json.meta.image;
                    var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
                    var frameData = this.json.frames;
                    this.texture = image.texture.baseTexture;
                    image.addEventListener("loaded", function(event) {
                        scope.onLoaded();
                    });
                    for (var i in frameData) {
                        var rect = frameData[i].frame;
                        if (rect) {
                            PIXI.TextureCache[i] = new PIXI.Texture(this.texture, {
                                x: rect.x,
                                y: rect.y,
                                width: rect.w,
                                height: rect.h
                            });
                            if (frameData[i].trimmed) {
                                PIXI.TextureCache[i].realSize = frameData[i].spriteSourceSize;
                                PIXI.TextureCache[i].trim.x = 0;
                            }
                        }
                    }
                    image.load();
                } else if (this.json.bones) {
                    var spineJsonParser = new spine.SkeletonJson;
                    var skeletonData = spineJsonParser.readSkeletonData(this.json);
                    PIXI.AnimCache[this.url] = skeletonData;
                    this.onLoaded();
                } else {
                    this.onLoaded();
                }
            } else {
                this.onError();
            }
        }
    };
    PIXI.JsonLoader.prototype.onLoaded = function() {
        this.loaded = true;
        this.dispatchEvent({
            type: "loaded",
            content: this
        });
    };
    PIXI.JsonLoader.prototype.onError = function() {
        this.dispatchEvent({
            type: "error",
            content: this
        });
    };
    PIXI.SpriteSheetLoader = function(url, crossorigin) {
        PIXI.EventTarget.call(this);
        this.url = url;
        this.crossorigin = crossorigin;
        this.baseUrl = url.replace(/[^\/]*$/, "");
        this.texture = null;
        this.frames = {};
    };
    PIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader;
    PIXI.SpriteSheetLoader.prototype.load = function() {
        var scope = this;
        var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
        jsonLoader.addEventListener("loaded", function(event) {
            scope.json = event.content.json;
            scope.onJSONLoaded();
        });
        jsonLoader.load();
    };
    PIXI.SpriteSheetLoader.prototype.onJSONLoaded = function() {
        var scope = this;
        var textureUrl = this.baseUrl + this.json.meta.image;
        var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
        var frameData = this.json.frames;
        this.texture = image.texture.baseTexture;
        image.addEventListener("loaded", function(event) {
            scope.onLoaded();
        });
        for (var i in frameData) {
            var rect = frameData[i].frame;
            if (rect) {
                PIXI.TextureCache[i] = new PIXI.Texture(this.texture, {
                    x: rect.x,
                    y: rect.y,
                    width: rect.w,
                    height: rect.h
                });
                if (frameData[i].trimmed) {
                    PIXI.TextureCache[i].realSize = frameData[i].spriteSourceSize;
                    PIXI.TextureCache[i].trim.x = 0;
                }
            }
        }
        image.load();
    };
    PIXI.SpriteSheetLoader.prototype.onLoaded = function() {
        this.dispatchEvent({
            type: "loaded",
            content: this
        });
    };
    PIXI.ImageLoader = function(url, crossorigin) {
        PIXI.EventTarget.call(this);
        this.texture = PIXI.Texture.fromImage(url, crossorigin);
    };
    PIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader;
    PIXI.ImageLoader.prototype.load = function() {
        if (!this.texture.baseTexture.hasLoaded) {
            var scope = this;
            this.texture.baseTexture.addEventListener("loaded", function() {
                scope.onLoaded();
            });
        } else {
            this.onLoaded();
        }
    };
    PIXI.ImageLoader.prototype.onLoaded = function() {
        this.dispatchEvent({
            type: "loaded",
            content: this
        });
    };
    PIXI.BitmapFontLoader = function(url, crossorigin) {
        PIXI.EventTarget.call(this);
        this.url = url;
        this.crossorigin = crossorigin;
        this.baseUrl = url.replace(/[^\/]*$/, "");
        this.texture = null;
    };
    PIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader;
    PIXI.BitmapFontLoader.prototype.load = function() {
        this.ajaxRequest = new XMLHttpRequest;
        var scope = this;
        this.ajaxRequest.onreadystatechange = function() {
            scope.onXMLLoaded();
        };
        this.ajaxRequest.open("GET", this.url, true);
        if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType("application/xml");
        this.ajaxRequest.send(null);
    };
    PIXI.BitmapFontLoader.prototype.onXMLLoaded = function() {
        if (this.ajaxRequest.readyState == 4) {
            if (this.ajaxRequest.status == 200 || window.location.href.indexOf("http") == -1) {
                var textureUrl = this.baseUrl + this.ajaxRequest.responseXML.getElementsByTagName("page")[0].attributes.getNamedItem("file").nodeValue;
                var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
                this.texture = image.texture.baseTexture;
                var data = {};
                var info = this.ajaxRequest.responseXML.getElementsByTagName("info")[0];
                var common = this.ajaxRequest.responseXML.getElementsByTagName("common")[0];
                data.font = info.attributes.getNamedItem("face").nodeValue;
                data.size = parseInt(info.attributes.getNamedItem("size").nodeValue, 10);
                data.lineHeight = parseInt(common.attributes.getNamedItem("lineHeight").nodeValue, 10);
                data.chars = {};
                var letters = this.ajaxRequest.responseXML.getElementsByTagName("char");
                for (var i = 0; i < letters.length; i++) {
                    var charCode = parseInt(letters[i].attributes.getNamedItem("id").nodeValue, 10);
                    var textureRect = {
                        x: parseInt(letters[i].attributes.getNamedItem("x").nodeValue, 10),
                        y: parseInt(letters[i].attributes.getNamedItem("y").nodeValue, 10),
                        width: parseInt(letters[i].attributes.getNamedItem("width").nodeValue, 10),
                        height: parseInt(letters[i].attributes.getNamedItem("height").nodeValue, 10)
                    };
                    PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect);
                    data.chars[charCode] = {
                        xOffset: parseInt(letters[i].attributes.getNamedItem("xoffset").nodeValue, 10),
                        yOffset: parseInt(letters[i].attributes.getNamedItem("yoffset").nodeValue, 10),
                        xAdvance: parseInt(letters[i].attributes.getNamedItem("xadvance").nodeValue, 10),
                        kerning: {},
                        texture: new PIXI.Texture(this.texture, textureRect)
                    };
                }
                var kernings = this.ajaxRequest.responseXML.getElementsByTagName("kerning");
                for (i = 0; i < kernings.length; i++) {
                    var first = parseInt(kernings[i].attributes.getNamedItem("first").nodeValue, 10);
                    var second = parseInt(kernings[i].attributes.getNamedItem("second").nodeValue, 10);
                    var amount = parseInt(kernings[i].attributes.getNamedItem("amount").nodeValue, 10);
                    data.chars[second].kerning[first] = amount;
                }
                PIXI.BitmapText.fonts[data.font] = data;
                var scope = this;
                image.addEventListener("loaded", function() {
                    scope.onLoaded();
                });
                image.load();
            }
        }
    };
    PIXI.BitmapFontLoader.prototype.onLoaded = function() {
        this.dispatchEvent({
            type: "loaded",
            content: this
        });
    };
    PIXI.SpineLoader = function(url, crossorigin) {
        PIXI.EventTarget.call(this);
        this.url = url;
        this.crossorigin = crossorigin;
        this.loaded = false;
    };
    PIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader;
    PIXI.SpineLoader.prototype.load = function() {
        var scope = this;
        var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
        jsonLoader.addEventListener("loaded", function(event) {
            scope.json = event.content.json;
            scope.onJSONLoaded();
        });
        jsonLoader.load();
    };
    PIXI.SpineLoader.prototype.onJSONLoaded = function(event) {
        var spineJsonParser = new spine.SkeletonJson;
        var skeletonData = spineJsonParser.readSkeletonData(this.json);
        PIXI.AnimCache[this.url] = skeletonData;
        this.onLoaded();
    };
    PIXI.SpineLoader.prototype.onLoaded = function() {
        this.loaded = true;
        this.dispatchEvent({
            type: "loaded",
            content: this
        });
    };
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else {
        root.PIXI = PIXI;
    }
}).call(this);
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('math/Circle',['require', 'exports', 'module', '../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = require("../vendor/pixi").Circle;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('math/Rectangle',['require', 'exports', 'module', '../utils/inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit");

var Rectangle = module.exports = function(x, y, width, height) {
    this.x = x || 0;
    this.y = y || 0;
    this._width = width || 0;
    this._height = height || 0;
    this.halfWidth = this._width / 2;
    this.halfHeight = this._height / 2;
};

inherit(Rectangle, Object, {
    clone: function() {
        return new Rectangle(this.x, this.y, this._width, this._height);
    },
    contains: function(x, y) {
        if (this._width <= 0 || this._height <= 0) return false;
        var x1 = this.x;
        if (x >= x1 && x <= x1 + this._width) {
            var y1 = this.y;
            if (y >= y1 && y <= y1 + this._height) {
                return true;
            }
        }
        return false;
    },
    overlaps: function(rect) {
        return this.right > rect.x && this.x < rect.right && this.bottom > rect.y && this.y < rect.bottom;
    }
});

Object.defineProperty(Rectangle.prototype, "width", {
    get: function() {
        return this._width;
    },
    set: function(w) {
        this._width = w || 0;
        this.halfWidth = this._width / 2;
    }
});

Object.defineProperty(Rectangle.prototype, "height", {
    get: function() {
        return this._y;
    },
    set: function(h) {
        this._height = h || 0;
        this.halfHeight = this._height / 2;
    }
});

Object.defineProperty(Rectangle.prototype, "right", {
    get: function() {
        return this.x + this._width;
    }
});

Object.defineProperty(Rectangle.prototype, "left", {
    get: function() {
        return this.x;
    }
});

Object.defineProperty(Rectangle.prototype, "top", {
    get: function() {
        return this.y;
    }
});

Object.defineProperty(Rectangle.prototype, "bottom", {
    get: function() {
        return this.y + this._height;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('math/Polygon',['require', 'exports', 'module', '../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = require("../vendor/pixi").Polygon;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('utils/utils',['require', 'exports', 'module', '../math/Vector', '../math/Circle', '../math/Rectangle', '../math/Polygon'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Vector = require("../math/Vector"), Circle = require("../math/Circle"), Rectangle = require("../math/Rectangle"), Polygon = require("../math/Polygon");

var utils = module.exports = {
    _arrayDelim: /[|,]/,
    noop: function() {},
    getAbsoluteUrl: function(url) {
        var a = document.createElement("a");
        a.href = url;
        return a.href;
    },
    ajax: function(sets) {
        sets = sets || {};
        sets.method = sets.method || "GET";
        sets.dataType = sets.dataType || "text";
        if (!sets.url) throw "No URL passed to ajax";
        sets.progress = sets.progress || utils.noop;
        sets.load = sets.load || utils.noop;
        sets.error = sets.error || utils.noop;
        sets.abort = sets.abort || utils.noop;
        sets.complete = sets.complete || utils.noop;
        var xhr = utils.createAjaxRequest(), protocol = utils.getAbsoluteUrl(sets.url).split("/")[0];
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                var res = xhr.response || xhr.responseText, err = null;
                if (protocol !== "file:" && xhr.status !== 200) err = "Non-200 status code returned: " + xhr.status;
                if (!err && typeof res === "string") {
                    if (sets.dataType === "json") {
                        try {
                            res = JSON.parse(res);
                        } catch (e) {
                            err = e;
                        }
                    } else if (sets.dataType === "xml") {
                        try {
                            res = utils.parseXML(res);
                        } catch (e) {
                            err = e;
                        }
                    }
                }
                if (err) {
                    if (sets.error) sets.error.call(xhr, err);
                } else {
                    if (sets.load) sets.load.call(xhr, res);
                }
            }
        };
        if (sets.dataType !== "json" && sets.dataType !== "xml") xhr.responseType = sets.dataType; else xhr.responseType = "text";
        xhr.open(sets.method, sets.url, true);
        xhr.send();
        return xhr;
    },
    createAjaxRequest: function() {
        var activexmodes = [ "Msxml2.XMLHTTP", "Microsoft.XMLHTTP" ];
        if (window.ActiveXObject) {
            for (var i = 0; i < activexmodes.length; i++) {
                try {
                    return new window.ActiveXObject(activexmodes[i]);
                } catch (e) {}
            }
        } else if (window.XMLHttpRequest) {
            return new XMLHttpRequest;
        } else {
            return false;
        }
    },
    setValues: function(obj, values) {
        if (!values) return;
        for (var key in values) {
            var newVal = values[key];
            if (newVal === undefined) {
                continue;
            }
            if (key in obj) {
                var curVal = obj[key];
                if (typeof curVal === "number" && typeof newVal === "string") {
                    var n;
                    if (newVal.indexOf("0x") === 0) n = parseInt(newVal, 16); else n = parseInt(newVal, 10);
                    if (!isNaN(n)) obj[key] = n;
                } else if (curVal instanceof Vector && newVal instanceof Array) {
                    curVal.set(parseFloat(newVal[0], 10) || 0, parseFloat(newVal[1], 10) || parseFloat(newVal[0], 10) || 0);
                } else if (curVal instanceof Vector && typeof newVal === "string") {
                    var a = newVal.split(utils._arrayDelim, 2);
                    curVal.set(parseFloat(a[0], 10) || 0, parseFloat(a[1], 10) || parseFloat(a[0], 10) || 0);
                } else if (curVal instanceof Vector && typeof newVal === "number") {
                    curVal.set(newVal, newVal);
                } else if (curVal.x !== undefined && newVal instanceof Array) {
                    curVal.x = parseFloat(newVal[0], 10) || 0;
                    curVal.y = parseFloat(newVal[1], 10) || parseFloat(newVal[0], 10) || 0;
                } else if (curVal.x !== undefined && typeof newVal === "string") {
                    var a2 = newVal.split(utils._arrayDelim, 2);
                    curVal.x = parseFloat(a2[0], 10) || 0;
                    curVal.y = parseFloat(a2[1], 10) || parseFloat(a2[0], 10) || 0;
                } else if (curVal.x !== undefined && typeof newVal === "number") {
                    curVal.x = newVal;
                    curVal.y = newVal;
                } else if (curVal instanceof Array && typeof newVal === "string") {
                    obj[key] = newVal.split(utils._arrayDelim);
                    for (var i = 0, il = obj[key].length; i < il; ++i) {
                        var val = obj[key][i];
                        if (!isNaN(val)) obj[key][i] = parseFloat(val, 10);
                    }
                } else {
                    obj[key] = newVal;
                }
            }
        }
        return obj;
    },
    parseHitArea: function(hv) {
        var ha;
        if (hv.length % 2 !== 0 && hv.length !== 3) {
            throw "Strange number of values for hitArea! Should be a flat array of values, like: [x,y,r] for a circle, [x,y,w,h] for a rectangle, or [x,y,x,y,...] for other polygons.";
        }
        if (hv.length === 3) {
            ha = new Circle(hv[0], hv[1], hv[2]);
        } else if (hv.length === 4) {
            ha = new Rectangle(hv[0], hv[1], hv[2], hv[3]);
        } else {
            ha = new Polygon(hv);
        }
        return ha;
    },
    parseTiledProperties: function(obj) {
        if (!obj || obj.__tiledparsed) return obj;
        for (var k in obj) {
            var v = obj[k];
            if (!isNaN(v)) obj[k] = parseFloat(v, 10); else if (v === "true") obj[k] = true; else if (v === "false") obj[k] = false; else {
                try {
                    v = JSON.parse(v);
                    obj[k] = v;
                } catch (e) {}
            }
        }
        if (obj.hitArea) obj.hitArea = utils.parseHitArea(obj.hitArea);
        if (obj.static || obj.sensor) {
            obj.mass = Infinity;
            obj.inertia = Infinity;
        }
        obj.__tiledparsed = true;
        return obj;
    },
    logger: window.console || {},
    log: function() {
        utils.logger.log && utils.logger.log.apply(utils.logger, arguments);
    },
    warn: function() {
        utils.logger.warn && utils.logger.warn.apply(utils.logger, arguments);
    },
    error: function() {
        utils.logger.error && utils.logger.error.apply(utils.logger, arguments);
    }
};

if (typeof window.DOMParser !== "undefined") {
    utils.parseXML = function(xmlStr) {
        return (new window.DOMParser).parseFromString(xmlStr, "text/xml");
    };
} else if (typeof window.ActiveXObject !== "undefined" && new window.ActiveXObject("Microsoft.XMLDOM")) {
    utils.parseXML = function(xmlStr) {
        var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async = "false";
        xmlDoc.loadXML(xmlStr);
        return xmlDoc;
    };
} else {
    utils.warn("XML parser not available, trying to parse any XML will result in an error.");
    utils.parseXML = function() {
        throw "Trying to parse XML, but not XML parser is available in this environment";
    };
}
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'utils/support',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
var support = module.exports = {
    ua: window.navigator ? window.navigator.userAgent.toLowerCase() : "nodejs",
    canvas: function() {
        try {
            return !!window.CanvasRenderingContext2D && !!document.createElement("canvas").getContext("2d");
        } catch (e) {
            return false;
        }
    }(),
    webgl: function() {
        try {
            return !!window.WebGLRenderingContext && !!document.createElement("canvas").getContext("experimental-webgl");
        } catch (e) {
            return false;
        }
    }(),
    workers: !!window.Worker,
    blobUrls: !!window.Blob && !!window.URL && !!window.URL.createObjectURL,
    typedArrays: !!window.ArrayBuffer,
    fileapi: !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob,
    webAudio: !!window.AudioContext || !!window.webkitAudioContext || !!window.mozAudioContext,
    htmlAudio: !!document.createElement("audio").canPlayType,
    localStorage: !!window.localStorage,
    touch: "createTouch" in document || "ontouchstart" in window || navigator.isCocoonJS,
    gamepad: !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") !== -1
};

var audioTest = new Audio;

support.codec = {
    mp3: !!audioTest.canPlayType("audio/mpeg;").replace(/^no$/, ""),
    opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
    ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
    wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
    m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
    webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('audio/AudioPlayer',['require', 'exports', 'module', './AudioPlayer', '../utils/EventEmitter', '../utils/utils', '../utils/inherit', '../utils/support'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var AudioPlayer = require("./AudioPlayer"), EventEmitter = require("../utils/EventEmitter"), utils = require("../utils/utils"), inherit = require("../utils/inherit"), support = require("../utils/support");

var AudioPlayer = module.exports = function(manager, audio, settings) {
    EventEmitter.call(this);
    this.src = "";
    this.game = manager.game;
    this.key = audio.key;
    this.autoplay = false;
    this.format = null;
    this.loop = false;
    this.pos3d = [ 0, 0, -.5 ];
    this.sprite = {};
    Object.defineProperty(this, "volume", {
        get: this.getVolume.bind(this),
        set: this.setVolume.bind(this)
    });
    this._file = audio;
    this._volume = 1;
    this._duration = 0;
    this._loaded = false;
    this._manager = manager;
    this._webAudio = support.webAudio;
    this._nodes = [];
    this._onendTimer = [];
    utils.setValues(this, settings);
    if (this._webAudio) {
        this._setupAudioNode();
    }
    this.load();
};

inherit(AudioPlayer, Object, {
    load: function() {
        var self = this, audio = this._file;
        if (audio.webAudio) {
            if (!audio.decoded) {
                this.ctx.decodeAudioData(audio.data, function(buffer) {
                    if (buffer) {
                        audio.data = buffer;
                        audio.decoded = true;
                        self.loadSoundBuffer(buffer);
                    }
                });
            } else {
                this.loadSoundBuffer(audio.data);
            }
        } else {
            var node = audio.data.cloneNode();
            this._nodes.push(node);
            node._pos = 0;
            node.volume = this._manager.muted ? 0 : this._volume * this._manager.volume;
            this._duration = node.duration;
            this.sprite._default = [ 0, node.duration * 1e3 ];
            if (!this._loaded) {
                this._loaded = true;
                this.emit("load", {
                    message: "Audio file loaded.",
                    data: this.src
                });
            }
            if (this.autoplay) {
                this.play();
            }
        }
        return this;
    },
    play: function(sprite, cb) {
        var self = this;
        if (typeof sprite === "function") {
            cb = sprite;
            sprite = null;
        }
        if (!sprite) {
            sprite = "_default";
        }
        if (!this._loaded) {
            this.on("load", function() {
                self.play(sprite, cb);
            });
            return this;
        }
        if (!this.sprite[sprite]) {
            if (typeof cb === "function") cb();
            return this;
        }
        this._inactiveNode(function(node) {
            var pos = node._pos > 0 ? node._pos : self.sprite[sprite][0] / 1e3, duration = self.sprite[sprite][1] / 1e3 - node._pos, loop = self.loop || self.sprite[sprite][2], soundId = typeof cb === "string" ? cb : Math.round(Date.now() * Math.random()) + "", timerId;
            node._sprite = sprite;
            (function(o) {
                timerId = setTimeout(function() {
                    if (!self._webAudio && o.loop) {
                        self.stop(o.id, o.timer).play(o.sprite, o.id);
                    }
                    if (self._webAudio && !o.loop) {
                        self._nodeById(o.id).paused = true;
                    }
                    if (!self._webAudio && !o.loop) {
                        self.stop(o.id, o.timer);
                    }
                    self.emit("end", {
                        message: "Audio has finished playing",
                        data: o.id
                    });
                }, duration * 1e3);
                self._onendTimer.push(timerId);
                o.timer = timerId;
            })({
                id: soundId,
                sprite: sprite,
                loop: loop
            });
            if (self._webAudio) {
                node.id = soundId;
                node.paused = false;
                self.refreshBuffer([ loop, pos, duration ], soundId);
                self._playStart = self._manager.ctx.currentTime;
                node.gain.value = self._volume;
                if (typeof node.bufferSource.start === "undefined") {
                    node.bufferSource.noteGrainOn(0, pos, duration);
                } else {
                    node.bufferSource.start(0, pos, duration);
                }
            } else {
                if (node.readyState === 4) {
                    node.id = soundId;
                    node.currentTime = pos;
                    node.muted = self._manager.muted;
                    node.volume = self._volume * self._manager.volume;
                    node.play();
                } else {
                    self._clearEndTimer(timerId);
                    (function() {
                        var sound = self, playSpr = sprite, fn = cb, newNode = node;
                        var evt = function() {
                            sound.play(playSpr, fn);
                            newNode.removeEventListener("canplaythrough", evt, false);
                        };
                        newNode.addEventListener("canplaythrough", evt, false);
                    })();
                    return self;
                }
            }
            self.emit("play", {
                message: "Playing audio file",
                data: soundId
            });
            if (typeof cb === "function") cb(soundId);
        });
        return this;
    },
    pause: function(id, timerId) {
        var self = this;
        if (!this._loaded) {
            this.on("play", function() {
                self.play(id);
            });
            return this;
        }
        this._clearEndTimer(timerId || 0);
        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if (activeNode) {
            if (this._webAudio) {
                if (!activeNode.bufferSource) return this;
                activeNode.paused = true;
                activeNode._pos += this._manager.ctx.currentTime - this._playStart;
                if (typeof activeNode.bufferSource.stop === "undefined") {
                    activeNode.bufferSource.noteOff(0);
                } else {
                    activeNode.bufferSource.stop(0);
                }
            } else {
                activeNode._pos = activeNode.currentTime;
                activeNode.pause();
            }
        }
        this.emit("pause", {
            message: "Audio file paused",
            data: id
        });
        return this;
    },
    stop: function(id, timerId) {
        var self = this;
        if (!this._loaded) {
            this.on("play", function() {
                self.stop(id);
            });
            return this;
        }
        this._clearEndTimer(timerId || 0);
        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if (activeNode) {
            activeNode._pos = 0;
            if (this._webAudio) {
                if (!activeNode.bufferSource) return this;
                activeNode.paused = true;
                if (typeof activeNode.bufferSource.stop === "undefined") {
                    activeNode.bufferSource.noteOff(0);
                } else {
                    activeNode.bufferSource.stop(0);
                }
            } else {
                activeNode.pause();
                activeNode.currentTime = 0;
            }
        }
        return this;
    },
    mute: function(id) {
        return this.setMuted(true, id);
    },
    unmute: function(id) {
        return this.setMuted(false, id);
    },
    setMuted: function(muted, id) {
        var self = this;
        if (!this._loaded) {
            this.on("play", function() {
                self.setMuted(muted, id);
            });
            return this;
        }
        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if (activeNode) {
            if (this._webAudio) {
                activeNode.gain.value = muted ? 0 : this._volume;
            } else {
                activeNode.volume = muted ? 0 : this._volume;
            }
        }
        return this;
    },
    seek: function(pos, id) {
        var self = this;
        if (!this._loaded) {
            this.on("load", function() {
                self.seek(pos);
            });
            return this;
        }
        if (!pos || pos < 0) pos = 0;
        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if (activeNode) {
            if (this._webAudio) {
                activeNode._pos = pos;
                this.pause(activeNode.id).play(activeNode._sprite, id);
            } else {
                activeNode.currentTime = pos;
            }
        }
        return this;
    },
    getPosition: function(id) {
        var self = this;
        if (!this._loaded) {
            this.on("load", function() {
                self.getPosition(id);
            });
            return this;
        }
        var activeNode = id ? this._nodeById(id) : this._activeNode();
        if (activeNode) {
            if (this._webAudio) {
                return activeNode._pos + (this._manager.ctx.currentTime - this._playStart);
            } else {
                return activeNode.currentTime;
            }
        }
        return 0;
    },
    fade: function(from, to, len, id, cb) {
        var self = this, diff = Math.abs(from - to), dir = from > to ? "dowm" : "up", steps = diff / .01, stepTime = len / steps;
        if (typeof id === "function") {
            cb = id;
            id = null;
        }
        if (!this._loaded) {
            this.on("load", function() {
                self.fade(from, to, len, id, cb);
            });
            return this;
        }
        this.setVolume(from, id);
        for (var i = 1; i <= steps; ++i) {
            var change = this._volume + (dir === "up" ? .01 : -.01) * i, vol = Math.round(1e3 * change) / 1e3, wait = stepTime * i;
            this._doFadeStep(vol, wait, to, id, cb);
        }
    },
    getVolume: function() {
        return this._volume;
    },
    setVolume: function(vol, id) {
        var self = this;
        vol = parseFloat(vol);
        if (!this._loaded) {
            this.on("play", function() {
                self.setVolume(vol, id);
            });
            return this;
        }
        if (vol >= 0 && vol <= 1) {
            this._volume = vol;
            var activeNode = id ? this._nodeById(id) : this._activeNode();
            if (activeNode) {
                if (this._webAudio) {
                    activeNode.gain.volume = vol;
                } else {
                    activeNode.volume = vol * this._manager.volume;
                }
            }
        }
        return this;
    },
    setPosition: function(x, y, z, id) {
        var self = this;
        x = !x ? 0 : x;
        y = !y ? 0 : y;
        z = !z && z !== 0 ? -.5 : z;
        if (!this._loaded) {
            this.on("play", function() {
                self.setPosition(x, y, z, id);
            });
            return this;
        }
        if (this._webAudio) {
            var activeNode = id ? this._nodeById(id) : this._activeNode();
            if (activeNode) {
                this.pos3d[0] = x;
                this.pos3d[1] = y;
                this.pos3d[2] = z;
                activeNode.panner.setPosition(x, y, z);
            }
        }
        return this;
    },
    _doFadeStep: function(vol, wait, end, id, cb) {
        var self = this;
        setTimeout(function() {
            self.setVolume(vol, id);
            if (vol === end) {
                if (typeof cb === "function") cb();
            }
        }, wait);
    },
    _nodeById: function(id) {
        var node = this._nodes[0];
        for (var i = 0, il = this._nodes.length; i < il; ++i) {
            if (this._nodes[i].id === id) {
                node = this._nodes[i];
                break;
            }
        }
        return node;
    },
    _activeNode: function() {
        var node;
        for (var i = 0, il = this._nodes.length; i < il; ++i) {
            if (!this._nodes[i].paused) {
                node = this._nodes[i];
                break;
            }
        }
        this._drainPool();
        return node;
    },
    _inactiveNode: function(cb) {
        var node;
        for (var i = 0, il = this._nodes.length; i < il; ++i) {
            if (this._nodes[i].paused && this._nodes[i].readyState === 4) {
                cb(node = this._nodes[i]);
                break;
            }
        }
        this._drainPool();
        if (node) return;
        if (this._webAudio) {
            node = this._setupAudioNode();
            cb(node);
        } else {
            this.load();
            node = this._nodes[this.nodes.length - 1];
            node.addEventListener("loadedmetadata", function() {
                cb(node);
            });
        }
    },
    _drainPool: function() {
        var inactive = 0, i = 0, il = 0;
        for (i = 0, il = this._nodes.length; i < il; ++i) {
            if (this._nodes[i].paused) {
                inactive++;
            }
        }
        for (i = this._nodes.length; i >= 0; --i) {
            if (inactive <= 5) break;
            if (this._nodes[i].paused) {
                inactive--;
                this._nodes.splice(i, 1);
            }
        }
    },
    _clearEndTimer: function(timerId) {
        var timer = this._onendTimer.indexOf(timerId);
        timer = timer >= 0 ? timer : 0;
        if (this._onendTimer[timer]) {
            clearTimeout(this._onendTimer[timer]);
            this._onendTimer.splice(timer, 1);
        }
    },
    _setupAudioNode: function() {
        var node = this._nodes, i = this._nodes.length;
        node.push(typeof this._manager.ctx.createGain === "undefined" ? this._manager.ctx.createGainNode : this._manager.ctx.createGain());
        node[i].gain.value = this._volume;
        node[i].paused = true;
        node[i]._pos = 0;
        node[i].readyState = 4;
        node[i].connect(this._manager.masterGain);
        node[i].panner = this._manager.ctx.createPanner();
        node[i].panner.setPosition(this.pos3d[0], this.pos3d[1], this.pos3d[2]);
        node[i].panner.connect(node[i]);
        return node[i];
    },
    loadSoundBuffer: function(buffer) {
        this._duration = buffer ? buffer.duration : this._duration;
        this.sprite._default = [ 0, this._duration * 1e3 ];
        if (!this._loaded) {
            this._loaded = true;
            this.emit("load", {
                message: "Audio file loaded.",
                data: this.src
            });
        }
        if (this.autoplay) {
            this.play();
        }
    },
    refreshBuffer: function(loop, id) {
        var node = this._nodeById(id);
        node.bufferSource = this._manager.ctx.createBufferSource();
        node.bufferSource.buffer = this._file.data;
        node.bufferSource.connect(node.panner);
        node.bufferSource.loop = loop[0];
        if (loop[0]) {
            node.bufferSource.loopStart = loop[1];
            node.bufferSource.loopEnd = loop[1] + loop[2];
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('audio/AudioManager',['require', 'exports', 'module', './AudioPlayer', '../utils/inherit', '../utils/support'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var AudioPlayer = require("./AudioPlayer"), inherit = require("../utils/inherit"), support = require("../utils/support");

var __AudioCtx = window.AudioContext || window.webkitAudioContext || window.mozAudioContext, __audioctx = support.webAudio ? new __AudioCtx : null;

var AudioManager = module.exports = function(game) {
    this.game = game;
    this._muted = false;
    this._volume = 1;
    Object.defineProperty(this, "volume", {
        get: this.getVolume.bind(this),
        set: this.setVolume.bind(this)
    });
    this.ctx = __audioctx;
    this.canPlay = support.webAudio || support.htmlAudio;
    if (support.webAudio) {
        this.masterGain = this.ctx.createGain ? this.ctx.createGain() : this.ctx.createGainNode();
        this.masterGain.gain.value = 1;
        this.masterGain.connect(this.ctx.destination);
    }
    this.sounds = {};
};

inherit(AudioManager, Object, {
    getVolume: function() {
        return this._volume;
    },
    setVolume: function(v) {
        v = parseFloat(v, 10);
        if (!isNaN(v) && v >= 0 && v <= 1) {
            this._volume = v;
            if (support.webAudio) this.masterGain.gain.value = v;
            for (var key in this.sounds) {
                if (this.sounds.hasOwnProperty(key) && this.sounds[key]._webAudio === false) {
                    var player = this.sounds[key];
                    for (var i = 0, il = player._nodes.length; i < il; ++i) {
                        player._nodes[i].volume = player._volume * this._volume;
                    }
                }
            }
        }
    },
    mute: function() {
        return this.setMuted(true);
    },
    unmute: function() {
        return this.setMuted(false);
    },
    setMuted: function(m) {
        this._muted = m = !!m;
        if (support.webAudio) this.masterGain.gain.value = m ? 0 : this._volume;
        for (var key in this.sounds) {
            if (this.sounds.hasOwnProperty(key) && this.sounds[key]._webAudio === false) {
                var player = this.sounds[key];
                for (var i = 0, il = player._nodes.length; i < il; ++i) {
                    player._nodes[i].mute();
                }
            }
        }
        return this;
    },
    attach: function(sound) {
        this.sounds[sound.key] = sound;
        sound._manager = this;
        if (support.webAudio) {
            for (var i = 0; i < sound._nodes.length; ++i) {
                sound._nodes[i].disconnect();
                sound._nodes[i].connect(this.masterGain);
            }
        }
    },
    add: function(key, settings) {
        if (!this.canPlay) {
            return false;
        }
        var audio = this.game.cache.getAudio(key);
        if (!audio.player) audio.player = new AudioPlayer(this, audio, settings);
        return this.sounds[key] = audio.player;
    },
    remove: function(key) {
        var audio = this.sounds[key];
        if (audio) {
            audio.stop();
        }
        delete this.sounds[key];
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('display/Container',['require', 'exports', 'module', '../utils/EventEmitter', '../utils/utils', '../utils/inherit', '../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var EventEmitter = require("../utils/EventEmitter"), utils = require("../utils/utils"), inherit = require("../utils/inherit"), PIXI = require("../vendor/pixi");

var Container = module.exports = function(settings) {
    PIXI.DisplayObjectContainer.call(this);
    EventEmitter.call(this);
    utils.setValues(this, settings);
};

inherit(Container, PIXI.DisplayObjectContainer, {
    addChild: function(child) {
        if (child._container !== this) {
            child._container = this;
            PIXI.DisplayObjectContainer.prototype.addChild.apply(this, arguments);
        }
        return child;
    },
    addChildAt: function(child) {
        if (child._container !== this) {
            child._container = this;
            PIXI.DisplayObjectContainer.prototype.addChildAt.apply(this, arguments);
        }
        return child;
    },
    removeChild: function(child) {
        if (child._container === this) {
            child._container = null;
            PIXI.DisplayObjectContainer.prototype.removeChild.apply(this, arguments);
        }
        return child;
    },
    removeAllChildren: function() {
        while (this.children.length) {
            if (this.children[0].destroy) this.children[0].destroy();
            this.removeChild(this.children[0]);
        }
        return this;
    },
    bringChildToTop: function(child) {
        if (child._container === this) {
            this.removeChild(child);
            this.addChild(child);
        }
        return child;
    },
    destroy: function() {
        this.removeAllChildren();
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'constants',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = {
    version: "@@VERSION",
    RENDERER: {
        AUTO: "auto",
        CANVAS: "canvas",
        WEBGL: "webgl"
    },
    FILE_FORMAT: {
        JSON: 0,
        XML: 1,
        CSV: 2
    },
    ATLAS_FORMAT: {
        JSON_ARRAY: 0,
        JSON_HASH: 1,
        STARLING_XML: 2
    },
    CAMERA_FOLLOW: {
        PLATFORMER: 0,
        TOPDOWN: 1,
        TOPDOWN_TIGHT: 2,
        LOCKON: 3
    },
    AXIS: {
        NONE: 0,
        HORIZONTAL: 1,
        VERTICAL: 2,
        BOTH: 3
    },
    DIRECTION: {
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        TOP: 4,
        BOTTOM: 8,
        ALL: 15
    },
    SPRITE_TYPE: {
        PLAYER: "player",
        ENEMY: "enemy",
        FRIENDLY: "friendly",
        NEUTRAL: "neutral",
        COLLECTABLE: "collectable",
        TILE: "tile"
    },
    COLLISION_TYPE: {
        NONE: "none",
        SOLID: "solid",
        CLIFF: "cliff",
        LADDER: "ladder",
        WATER: "water",
        DEEP_WATER: "deep_water"
    },
    PHYSICS_TYPE: {
        STATIC: 0,
        KINEMATIC: 1,
        DYNAMIC: 2
    },
    SOLVE_TYPE: {
        DISPLACE: 0,
        ELASTIC: 1
    },
    PHYSICS: {
        MAX_QUAD_OBJECTS: 10,
        MAX_QUAD_LEVELS: 4,
        OVERLAP_BIAS: 4
    }
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('display/Sprite',['require', 'exports', 'module', '../utils/EventEmitter', '../math/Rectangle', '../utils/inherit', '../vendor/pixi', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var EventEmitter = require("../utils/EventEmitter"), Rectangle = require("../math/Rectangle"), inherit = require("../utils/inherit"), PIXI = require("../vendor/pixi"), C = require("../constants");

var Sprite = module.exports = function(tx) {
    PIXI.Sprite.call(this, tx);
    EventEmitter.call(this);
    this.type = C.SPRITE_TYPE.NEUTRAL;
    this.hitArea = this.hitArea || new Rectangle(0, 0, this.width, this.height);
};

inherit(Sprite, PIXI.Sprite, {
    destroy: function() {
        if (this._physics) {
            this._physics.removeSprite(this);
            this._physics = null;
        }
        if (this.parent) this.parent.removeChild(this);
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('gui/GuiItem',['require', 'exports', 'module', '../utils/inherit', '../display/Sprite'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), Sprite = require("../display/Sprite");

var GuiItem = module.exports = function(texture, interactive) {
    this.draggable = false;
    this.dragging = false;
    Sprite.call(this, texture);
    this.interactive = interactive;
};

inherit(GuiItem, Sprite, {
    mousedown: function(e) {
        Sprite.prototype.mousedown.call(this, e);
        if (!this.draggable) return;
        this.dragging = e.data.getLocalPosition(e.object.parent);
    },
    mouseup: function(e) {
        Sprite.prototype.mouseup.call(this, e);
        this.dragging = false;
    },
    mousemove: function(e) {
        Sprite.prototype.mousemove.call(this, e);
        if (!this.draggable || !this.dragging) return;
        var pos = e.data.getLocalPosition(this.parent);
        this.setPosition(this.position.x + (pos.x - this.dragging.x), this.position.y + (pos.y - this.dragging.y));
        this.dragging = pos;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('math/Ellipse',['require', 'exports', 'module', '../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = require("../vendor/pixi").Ellipse;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'math/math',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
var math = module.exports = {
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    SEED: Math.random(),
    floor: Math.floor,
    ceil: Math.ceil,
    random: Math.random,
    abs: Math.abs,
    sqrt: Math.sqrt,
    round: function(n) {
        return ~~(n + (n > 0 ? .5 : -.5));
    },
    clamp: function(n, min, max) {
        return Math.max(min, Math.min(max, n));
    },
    truncate: function(n) {
        return n > 0 ? Math.floor(n) : Math.ceil(n);
    },
    snap: function(n, gap, offset) {
        if (gap === 0) return n;
        offset = offset || 0;
        n -= offset;
        n = gap * Math.round(n / gap);
        return offset + n;
    },
    snapFloor: function(n, gap, offset) {
        if (gap === 0) return n;
        offset = offset || 0;
        n -= offset;
        n = gap * Math.floor(n / gap);
        return offset + n;
    },
    snapCeil: function(n, gap, offset) {
        if (gap === 0) return n;
        offset = offset || 0;
        n -= offset;
        n = gap * Math.ceil(n / gap);
        return offset + n;
    },
    radiansToDegrees: function(angle) {
        return angle * math.RAD_TO_DEG;
    },
    degreesToRadians: function(angle) {
        return angle * math.DEG_TO_RAD;
    },
    angleBetween: function(pos1, pos2) {
        return Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x);
    },
    randomBool: function(chance) {
        if (chance === undefined) chance = 50;
        if (chance <= 0) return false;
        if (chance >= 100) return true;
        if (Math.random() * 100 >= chance) return false;
        return true;
    },
    randomInt: function(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    },
    randomSign: function(chance) {
        return math.randomBool(chance) ? 1 : -1;
    },
    randomString: function() {
        return Math.floor(Date.now() * Math.random()).toString();
    },
    randomElement: function(array, start, len) {
        if (!start || start < 0) start = start || 0;
        if (!len || len < 1 || len > array.length - start) len = array.length - start;
        if (!array || len < 1) return null;
        return array[start + Math.floor(Math.random() * len)];
    }
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('tilemap/ObjectGroup',['require', 'exports', 'module', '../display/Container', '../math/Vector', '../math/Polygon', '../math/Ellipse', '../math/Rectangle', '../utils/utils', '../utils/inherit', '../math/math'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Container = require("../display/Container"), Vector = require("../math/Vector"), Polygon = require("../math/Polygon"), Ellipse = require("../math/Ellipse"), Rectangle = require("../math/Rectangle"), utils = require("../utils/utils"), inherit = require("../utils/inherit"), math = require("../math/math");

var ObjectGroup = module.exports = function(game, group) {
    Container.call(this, group);
    this.game = game;
    this.name = group.name || "";
    this.color = group.color;
    this.properties = group.properties || {};
    this.objects = group.objects;
    this.type = group.type;
    this.alpha = group.opacity;
    this.visible = group.visible;
};

inherit(ObjectGroup, Container, {
    spawn: function() {
        var game = this.game;
        for (var i = this.objects.length - 1; i >= 0; --i) {
            var o = this.objects[i], props = utils.parseTiledProperties(o.properties) || {}, set, interactive, obj;
            props.tileprops = {};
            if (o.gid) {
                set = this.parent.getTileset(o.gid);
                if (set) {
                    props.texture = set.getTileTexture(o.gid);
                    props.tileprops = set.getTileProperties(o.gid);
                    if (!props.hitArea) {
                        if (props.tileprops.hitArea) props.hitArea = props.tileprops.hitArea; else props.hitArea = set.properties.hitArea;
                    }
                }
            } else {
                if (!props.hitArea) {
                    if (o.polyline) props.hitArea = this._getPolyline(o); else if (o.polygon) props.hitArea = this._getPolygon(o); else if (o.ellipse) props.hitArea = this._getEllipse(o); else props.hitArea = this._getRectangle(o);
                }
            }
            o.name = o.name || props.name || props.tileprops.name;
            o.type = o.type || props.type || props.tileprops.type;
            if (typeof props.texture === "string") {
                props.texture = game.cache.getTexture(props.texture);
            }
            if (!props.texture) {
                obj = new Container;
                obj.width = o.width;
                obj.height = o.height;
                obj.name = o.name;
                obj.type = o.type;
                obj.hitArea = props.hitArea;
                obj.rotation = o.rotation;
                obj.sensor = true;
                obj.setPosition(o.x, o.y);
                obj.enablePhysics(game.physics);
                if (this.parent._showPhysics) obj.showPhysics();
            } else {
                props.width = o.width;
                props.height = o.height;
                props.zIndex = this.zIndex;
                obj = game.spritepool.create(o.name, props.texture, props);
                obj.name = o.name;
                obj.type = o.type;
                obj.hitArea = props.hitArea;
                obj.mass = props.mass || props.tileprops.mass;
                obj.inertia = props.inertia || props.tileprops.inertia;
                obj.friction = props.friction || props.tileprops.friction;
                obj.sensor = props.sensor || props.tileprops.sensor;
                obj.setPosition(o.x, o.y);
                var a = props.anchor || props.tileprops.anchor;
                obj.anchor.y = a ? a[1] : 1;
                obj.anchor.x = a ? a[0] : this.parent.orientation === "isometric" ? .5 : 0;
                if (props.mass || props.tileprops.mass) {
                    obj.enablePhysics(game.physics);
                    if (this.parent._showPhysics) obj.showPhysics();
                }
                if (props.tileprops) {
                    if (props.tileprops.flippedX) {
                        obj.scale.x = -1;
                        obj.anchor.x = a ? a[0] : 1;
                    }
                    if (props.tileprops.flippedY) {
                        obj.scale.y = -1;
                        obj.anchor.y = a ? a[1] : 0;
                    }
                    if (props.tileprops.rotatedCW) {
                        obj.rotation = math.degreesToRadians(45);
                    }
                }
                if (props.animation || props.tileprops.animation) {
                    if (obj.gotoAndPlay) {
                        obj.gotoAndPlay(props.animation || props.tileprops.animation);
                    }
                }
                if (typeof o.rotation === "number") obj.setRotation(o.rotation);
            }
            obj.visible = o.visible !== undefined ? !!o.visible : true;
            if (this.parent.orientation === "isometric") {
                var toTileX = o.x / this.parent.tileSize.x, toTileY = o.y / this.parent.tileSize.y;
                o.x = toTileX * this.parent.tileSize.x - (toTileY - 1) * (this.parent.tileSize.x / 2);
                o.y = toTileY * this.parent.tileSize.y / 2 + toTileX * this.parent.tileSize.y;
            }
            interactive = this._getInteractive(set, props);
            if (interactive) {
                obj.interactive = interactive;
                obj.click = this.onObjectEvent.bind(this, "click", obj);
                obj.mousedown = this.onObjectEvent.bind(this, "mousedown", obj);
                obj.mouseup = this.onObjectEvent.bind(this, "mouseup", obj);
                obj.mousemove = this.onObjectEvent.bind(this, "mousemove", obj);
                obj.mouseout = this.onObjectEvent.bind(this, "mouseout", obj);
                obj.mouseover = this.onObjectEvent.bind(this, "mouseover", obj);
                obj.mouseupoutside = this.onObjectEvent.bind(this, "mouseupoutside", obj);
            }
            obj.properties = {};
            for (var t in props.tileprops) obj.properties[t] = props.tileprops[t];
            for (var k in props) if (k !== "tileprops") obj.properties[k] = props[k];
            obj._objIndex = i;
            this.addChild(obj);
        }
        return this;
    },
    onObjectEvent: function(eventName, obj, data) {
        this.parent.onObjectEvent(eventName, obj, data);
    },
    _getPolygon: function(o) {
        var points = [];
        for (var i = 0, il = o.polygon.length; i < il; ++i) {
            points.push(new Vector(o.polygon[i].x, o.polygon[i].y));
        }
        return new Polygon(points);
    },
    _getPolyline: function(o) {
        var points = [];
        for (var i = 0, il = o.polyline.length; i < il; ++i) {
            points.push(new Vector(o.polyline[i].x, o.polyline[i].y));
        }
        return new Polygon(points);
    },
    _getEllipse: function(o) {
        return new Ellipse(0, 0, o.width, o.height);
    },
    _getRectangle: function(o) {
        return new Rectangle(0, 0, o.width, o.height);
    },
    _getInteractive: function(set, props) {
        return props.interactive || props.tileprops.interactive || set && set.properties.interactive || this.properties.interactive || this.parent.properties.interactive;
    },
    despawn: function() {
        for (var i = this.children.length - 1; i > -1; --i) {
            var c = this.children[i];
            if (c.destroy) c.destroy();
        }
        return this;
    },
    destroy: function() {
        this.despawn();
        Container.prototype.destroy.call(this);
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('display/BaseTexture',['require', 'exports', 'module', '../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = require("../vendor/pixi").BaseTexture;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('display/Texture',['require', 'exports', 'module', '../vendor/pixi', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Texture = module.exports = require("../vendor/pixi").Texture, utils = require("../utils/utils"), PIXI = require("../vendor/pixi");

Texture.fromJSON = function(key, json, baseTexture) {
    if (!json.frames) {
        utils.warn('Invalid Texture Atlas JSON for fromJSON, missing "frames" array, full json:', json);
        return;
    }
    var frames = json.frames, textures = {}, subkey;
    if (frames.length) {
        for (var i = 0, il = frames.length; i < il; ++i) {
            subkey = key + "_" + frames[i].filename;
            textures[frames[i].filename] = Texture._createFrame(subkey, frames[i], baseTexture);
        }
    } else {
        for (var k in frames) {
            subkey = key + "_" + k;
            textures[k] = Texture._createFrame(subkey, frames[k], baseTexture);
        }
    }
    return textures;
};

Texture._createFrame = function(key, data, baseTexture) {
    var rect = data.frame;
    if (rect) {
        var tx = PIXI.TextureCache[key] = new Texture(baseTexture, {
            x: rect.x,
            y: rect.y,
            width: rect.w,
            height: rect.h
        });
        tx.trimmed = data.trimmed;
        tx.rotated = data.rotated;
        tx.sourceSize = data.sourceSize;
        tx.realSize = data.spriteSourceSize;
        return tx;
    }
};

Texture.fromXML = function(key, xml, baseTexture) {
    if (!xml.getElementsByTagName("TextureAtlas")) {
        utils.warn("Invalid Texture Atlas XML given, missing <TextureAtlas> tag, full xml:", xml);
        return;
    }
    var frames = xml.getElementsByTagName("SubTexture") || xml.getElementsByTagName("sprite"), textures = {};
    for (var i = 0; i < frames.length; i++) {
        var frame = frames[i], attrs = frame.attributes.getNamedItem, name = attrs("name") || attrs("n"), x = attrs("x"), y = attrs("y"), width = attrs("width") || attrs("w"), height = attrs("height") || attrs("h"), ox = attrs("frameX") || attrs("oX"), oy = attrs("frameY") || attrs("oY"), owidth = attrs("frameWidth") || attrs("oW"), oheight = attrs("frameHeight") || attrs("oH"), rotated = !!attrs("r");
        var tx = textures[name] = PIXI.TextureCache[key + "_" + name] = new Texture(baseTexture, {
            x: parseInt(x.nodeValue, 10),
            y: parseInt(y.nodeValue, 10),
            width: parseInt(width.nodeValue, 10),
            height: parseInt(height.nodeValue, 10)
        });
        tx.trimmed = ox && oy;
        tx.rotated = rotated;
        if (tx.trimmed) {
            tx.sourceSize = {
                w: parseInt(owidth.nodeValue, 10),
                h: parseInt(oheight.nodeValue, 10)
            };
            tx.realSize = {
                x: Math.abs(parseInt(ox.nodeValue, 10)),
                y: Math.abs(parseInt(oy.nodeValue, 10)),
                w: parseInt(owidth.nodeValue, 10),
                h: parseInt(oheight.nodeValue, 10)
            };
        }
    }
    return textures;
};

Texture.fromSpritesheet = function(obj) {
    return obj;
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('tilemap/Tilelayer',['require', 'exports', 'module', '../display/Container', '../math/Vector', '../math/math', '../utils/utils', '../utils/inherit', '../utils/support'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Container = require("../display/Container"), Vector = require("../math/Vector"), math = require("../math/math"), utils = require("../utils/utils"), inherit = require("../utils/inherit"), support = require("../utils/support");

var Tilelayer = module.exports = function(map, layer) {
    Container.call(this, layer);
    this.map = map;
    this.game = map.game;
    this.name = layer.name || "";
    this.size = new Vector(layer.width || 0, layer.height || 0);
    this.tileIds = support.typedArrays ? new Uint32Array(layer.data) : layer.data;
    this.properties = utils.parseTiledProperties(layer.properties) || {};
    this.type = layer.type;
    this.position.x = layer.x;
    this.position.y = layer.y;
    this.alpha = layer.opacity;
    this.visible = layer.visible;
    this._overlaps = [];
    this._tempTileBlock = [];
    this._tempTileX = 0;
    this._tempTileY = 0;
    this._tempTileW = 0;
    this._tempTileH = 0;
};

inherit(Tilelayer, Container, {
    render: function(ctx, x, y, width, height) {
        var map = this.map, tsx = map.tileSize.x, tsy = map.tileSize.y, startX = Math.floor(x / tsx), startY = Math.floor(y / tsy), maxX = Math.ceil(width / tsx), maxY = Math.ceil(height / tsx), nx = x * width % tsx, ny = y * height % tsy, sx = map.size.x;
        for (var i = startX; i < maxX; ++i) {
            for (var j = startY; j < maxY; ++j) {
                var id = i + j * sx, tid = this.tileIds[id], set = map.getTileset(tid);
                if (set) {
                    var tx = set.getTileTexture(tid), frame = tx.frame;
                    ctx.drawImage(tx.baseTexture.source, frame.x, frame.y, frame.width, frame.height, i * tsx - nx + set.tileoffset.x, j * tsy - ny + set.tileoffset.y, frame.width, frame.height);
                }
            }
        }
    },
    getTileOverlaps: function(sprite) {
        this._overlaps.length = 0;
        if (sprite.body.x < 0 || sprite.body.x > this.map.realSize.x || sprite.body.y < 0 || sprite.body.y > this.map.realSize.y) {
            return this._overlaps;
        }
        this._tempTileX = math.snapFloor(sprite.body.x, this.map.tileSize.x) / this.map.tileSize.x;
        this._tempTileY = math.snapFloor(sprite.body.y, this.map.tileSize.y) / this.map.tileSize.y;
        this._tempTileW = (math.snapCeil(sprite.body.width, this.map.tileSize.x) + this.map.tileSize.x) / this.map.tileSize.x;
        this._tempTileH = (math.snapCeil(sprite.body.height, this.map.tileSize.y) + this.map.tileSize.y) / this.map.tileSize.y;
        this.getTempBlock(this._tempTileX, this._tempTileY, this._tempTileW, this._tempTileH, true);
        for (var i = 0, il = this._tempTileBlock.length; i < il; ++i) {
            var block = this._tempTileBlock[i];
            if (this.game.physics.separateTile(sprite, block.x * this.map.tileSize.x, block.y * this.map.tileSize.y, this.map.tileSize.x, this.map.tileSize.y, block.tile.mass || 1, block.tile.collideLeft, block.tile.collideRight, block.tile.collideUp, block.tile.collideDown, block.tile.separateX, block.tile.separateY)) {
                this._overlaps.push(block);
            }
        }
        return this._overlaps;
    },
    getTempBlock: function(x, y, width, height, collisionOnly) {
        collisionOnly = collisionOnly || false;
        var map = this.map, sx = map.size.x, sy = map.size.y;
        if (x < 0) x = 0;
        if (y < 0) y = 0;
        if (width > sx) width = sx;
        if (height > sy) height = sy;
        this._tempTileBlock.length = 0;
        for (var ty = y; ty < y + height; ty++) {
            for (var tx = x; tx < x + width; tx++) {
                var id = tx + ty * sx, tid = this.tileIds[id], set = map.getTileset(tid), props;
                if (!set) continue;
                props = set.getTileProperties(tid);
                if (!collisionOnly || props.collidable) {
                    this._tempTileBlock.push({
                        x: tx,
                        y: ty,
                        tile: props
                    });
                }
            }
        }
    },
    destroy: function() {
        Container.prototype.destroy.call(this);
        this.game = null;
        this.name = null;
        this.size = null;
        this.tileIds = null;
        this.properties = null;
        this.type = null;
        this.position.x = null;
        this.position.y = null;
        this.alpha = null;
        this.visible = null;
        this.preRender = null;
        this.chunkSize = null;
        this._preRendered = null;
        this._tilePool = null;
        this._buffered = null;
        this._panDelta = null;
        this._rendered = null;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('tilemap/Tileset',['require', 'exports', 'module', '../utils/utils', '../utils/inherit', '../math/math', '../display/Texture', '../math/Vector', '../vendor/pixi', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var utils = require("../utils/utils"), inherit = require("../utils/inherit"), math = require("../math/math"), Texture = require("../display/Texture"), Vector = require("../math/Vector"), PIXI = require("../vendor/pixi"), C = require("../constants");

var Tileset = module.exports = function(texture, settings) {
    Texture.call(this, texture.baseTexture || texture);
    this.firstgid = settings.firstgid || 1;
    this.name = settings.name;
    this.tileSize = new Vector(settings.tilewidth, settings.tileheight);
    this.spacing = settings.spacing || 0;
    this.margin = settings.margin || 0;
    this.tileoffset = new Vector(settings.tileoffset ? settings.tileoffset.x : 0, settings.tileoffset ? settings.tileoffset.y : 0);
    this.numTiles = new Vector(math.floor((this.baseTexture.source.width - this.margin) / (this.tileSize.x - this.spacing)), math.floor((this.baseTexture.source.height - this.margin) / (this.tileSize.y - this.spacing)));
    this.lastgid = this.firstgid + (this.numTiles.x * this.numTiles.y - 1 || 0);
    this.properties = settings.properties || {};
    this.tileproperties = settings.tileproperties || {};
    this.size = new Vector(settings.imagewidth || this.baseTexture.source.width, settings.imageheight || this.baseTexture.source.height);
    this.textures = [];
    this.properties = utils.parseTiledProperties(this.properties);
    for (var k in this.tileproperties) {
        this.tileproperties[k] = utils.parseTiledProperties(this.tileproperties[k]);
    }
    for (var t = 0, tl = this.lastgid - this.firstgid + 1; t < tl; ++t) {
        var y = math.floor(t / this.numTiles.x), x = t - y * this.numTiles.x;
        x = x * this.tileSize.x + x * this.spacing + this.margin;
        y = y * this.tileSize.y + y * this.spacing + this.margin;
        this.textures.push(new Texture(this.baseTexture, new PIXI.Rectangle(x, y, this.tileSize.x, this.tileSize.y)));
    }
};

inherit(Tileset, Texture, {
    getTileProperties: function(tileId) {
        if (!tileId) return null;
        var flags = Tileset.FLAGS, flippedX = tileId & flags.FlippedX, flippedY = tileId & flags.FlippedY, rotatedCW = tileId & flags.RotatedCW;
        tileId = (tileId & ~Tileset.FLAGS.ALL) - this.firstgid;
        if (tileId < 0) return null;
        var props = this.tileproperties[tileId] ? this.tileproperties[tileId] : this.tileproperties[tileId] = {
            collidable: false,
            breakable: false,
            type: C.COLLISION_TYPE.NONE
        };
        props.flippedX = flippedX;
        props.flippedY = flippedY;
        props.rotatedCW = rotatedCW;
        return props;
    },
    getTileTexture: function(tileId) {
        if (!tileId) return null;
        tileId = (tileId & ~Tileset.FLAGS.ALL) - this.firstgid;
        if (tileId < 0) return null;
        return this.textures[tileId];
    },
    contains: function(tileId) {
        if (!tileId) return false;
        tileId &= ~Tileset.FLAGS.ALL;
        return tileId >= this.firstgid && tileId <= this.lastgid;
    }
});

Tileset.FLAGS = {
    FlippedX: 2147483648,
    FlippedY: 1073741824,
    RotatedCW: 536870912
};

var mask = 0;

for (var f in Tileset.FLAGS) {
    mask |= Tileset.FLAGS[f];
}

Tileset.FLAGS.ALL = mask;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('tilemap/Tilemap',['require', 'exports', 'module', '../display/Container', './ObjectGroup', '../display/BaseTexture', '../display/Texture', '../display/Sprite', '../math/Vector', './Tilelayer', './Tileset', '../vendor/pixi', '../utils/utils', '../utils/inherit', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Container = require("../display/Container"), ObjectGroup = require("./ObjectGroup"), BaseTexture = require("../display/BaseTexture"), Texture = require("../display/Texture"), Sprite = require("../display/Sprite"), Vector = require("../math/Vector"), Tilelayer = require("./Tilelayer"), Tileset = require("./Tileset"), PIXI = require("../vendor/pixi"), utils = require("../utils/utils"), inherit = require("../utils/inherit"), C = require("../constants");

var Tilemap = module.exports = function(game, map, tilesetTextures) {
    Container.call(this, map);
    this.game = game;
    this.properties = utils.parseTiledProperties(map.properties) || {};
    this.scale.x = this.properties.scale || 1;
    this.scale.y = this.properties.scale || 1;
    this.tileSize = new Vector(map.tilewidth, map.tileheight);
    this.size = new Vector(map.width, map.height);
    this.orientation = map.orientation;
    this.version = map.version;
    this.backgroundColor = map.backgroundColor;
    this.tilesets = [];
    this.scaledTileSize = new Vector(map.tilewidth * this.scale.x, map.tileheight * this.scale.y);
    this.realSize = new Vector(this.size.x * this.scaledTileSize.x, this.size.y * this.scaledTileSize.y);
    this.collisionLayer = null;
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.btx = new BaseTexture(this.canvas);
    this.tx = new Texture(this.btx);
    this.addChild(this.spr = new Sprite(this.tx));
    for (var t = 0, tl = map.tilesets.length; t < tl; ++t) {
        var ts = map.tilesets[t];
        this.tilesets.push(new Tileset(tilesetTextures[ts.name], ts));
    }
    for (var i = 0, il = map.layers.length; i < il; ++i) {
        var lyr, name = map.layers[i].name ? map.layers[i].name.toLowerCase() : "";
        switch (map.layers[i].type) {
          case "tilelayer":
            lyr = new Tilelayer(this, map.layers[i]);
            if (!this.collisionLayer) this.collisionLayer = lyr;
            if (name.indexOf("collide") !== -1 || name.indexOf("collision") !== -1) this.collisionLayer = lyr;
            break;
          case "objectgroup":
            lyr = new ObjectGroup(this.game, map.layers[i]);
            break;
          case "imagelayer":
            lyr = new Sprite(map.layers[i]);
            break;
        }
        this.addChild(lyr);
    }
    this._cache = {
        x: null,
        y: null,
        width: null,
        height: null
    };
    this.resize(this.game.width, this.game.height);
    var w = this.game.state.active.world;
    w.bounds.width = Math.max(w.bounds.width, this.realSize.x);
    w.bounds.height = Math.max(w.bounds.height, this.realSize.y);
};

inherit(Tilemap, Container, {
    getTileset: function(tileId) {
        for (var i = 0, il = this.tilesets.length; i < il; ++i) if (this.tilesets[i].contains(tileId)) return this.tilesets[i];
    },
    destroy: function() {
        Container.prototype.destroy.call(this);
        this.game = null;
        this.properties = null;
        this.tileSize = null;
        this.size = null;
        this.orientation = null;
        this.version = null;
        this.backgroundColor = null;
        this.tilesets = null;
        this.scaledTileSize = null;
        this.realSize = null;
    },
    spawnObjects: function() {
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.type === "objectgroup") {
                o.spawn();
            }
        }
        return this;
    },
    despawnObjects: function() {
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.type === "objectgroup") {
                o.despawn();
            }
        }
        return this;
    },
    onTileEvent: function(eventName, tile, data) {
        this.emit("tile." + eventName, {
            tile: tile,
            data: data
        });
    },
    onObjectEvent: function(eventName, obj, data) {
        this.emit("object." + eventName, {
            object: obj,
            data: data
        });
    },
    findLayer: function(name) {
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.name === name) return o;
        }
    },
    render: function(x, y, width, height) {
        if (this._cache.x === x && this._cache.y === y && this._cache.w === width && this._cache.h === height) return this;
        this._cache.x = x;
        this._cache.y = y;
        this._cache.w = width;
        this._cache.h = height;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.render) o.render(this.ctx, x, y, width, height);
        }
        if (this.game.renderMethod === C.RENDERER.WEBGL) PIXI.texturesToUpdate.push(this.btx);
        return this;
    },
    resize: function(w, h) {
        this.canvas.width = w;
        this.canvas.height = h;
        this.btx.width = w;
        this.btx.height = h;
        this.tx.frame.width = w;
        this.tx.frame.height = h;
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('utils/ObjectPool',['require', 'exports', 'module', './inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("./inherit");

var ObjectPool = function(type, parent) {
    this.type = type;
    this.pool = [];
    this.parent = parent;
};

inherit(ObjectPool, Object, {
    create: function() {
        var o = this.pool.pop();
        if (!o) {
            o = this._construct(this.type, arguments);
            if (this.parent) this.parent.addChild(o);
        }
        o.__allocated = true;
        return o;
    },
    free: function(o) {
        if (o.__allocated) {
            o.__allocated = false;
            this.pool.push(o);
        }
    },
    _construct: function(ctor, args) {
        function F() {
            return ctor.apply(this, args);
        }
        F.prototype = ctor.prototype;
        return new F;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('text/BitmapText',['require', 'exports', 'module', '../display/Container', '../utils/ObjectPool', '../display/Texture', '../display/Sprite', '../math/Vector', '../math/Rectangle', '../utils/utils', '../utils/inherit', '../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Container = require("../display/Container"), ObjectPool = require("../utils/ObjectPool"), Texture = require("../display/Texture"), Sprite = require("../display/Sprite"), Vector = require("../math/Vector"), Rectangle = require("../math/Rectangle"), utils = require("../utils/utils"), inherit = require("../utils/inherit"), PIXI = require("../vendor/pixi");

var BitmapText = module.exports = function(text, font, style) {
    Container.call(this);
    this.dirty = true;
    this.font = font;
    this._text = text;
    this.sprites = new ObjectPool(Sprite, this);
    this.setText(text);
    this.setStyle(style);
};

inherit(BitmapText, Container, {
    setStyle: function(style) {
        style = style || {};
        this.align = style.align;
        this.size = style.size || this.font.size;
        this.dirty = true;
    },
    renderText: function() {
        var font = this.font, pos = new Vector, prevCode = null, chars = [], maxLineWidth = 0, lineWidths = [], line = 0, scale = this.size / font.size;
        for (var i = 0; i < this.text.length; ++i) {
            var code = this.text.charCodeAt(i), ch = this.text.charAt(i);
            if (/(?:\r\n|\r|\n)/.test(ch)) {
                lineWidths.push(pos.x);
                maxLineWidth = Math.max(maxLineWidth, pos.x);
                line++;
                pos.x = 0;
                pos.y += font.lineHeight;
                prevCode = null;
                continue;
            }
            var data = font.chars[code];
            if (!data) continue;
            if (prevCode && data[prevCode]) {
                pos.x += data.kerning[prevCode] || 0;
            }
            chars.push({
                texture: data.texture,
                line: line,
                code: code,
                x: pos.x + data.xOffset,
                y: pos.y + data.yOffset
            });
            pos.x += data.xAdvance;
            prevCode = code;
        }
        lineWidths.push(pos.x);
        maxLineWidth = Math.max(maxLineWidth, pos.x);
        var lineAlignOffsets = [], align = this.align, offset = 0;
        for (i = 0; i <= line; ++i) {
            offset = 0;
            if (align === "right") offset = maxLineWidth - lineWidths[i]; else if (align === "center") offset = (maxLineWidth - lineWidths[i]) / 2;
            lineAlignOffsets.push(offset);
        }
        for (i = 0; i < chars.length; ++i) {
            var c = this.sprites.create(chars[i].texture);
            c.setTexture(chars[i].texture);
            c.visible = true;
            c.position.x = (chars[i].x + lineAlignOffsets[chars[i].line]) * scale;
            c.position.y = chars[i].y * scale;
            c.scale.x = c.scale.y = scale;
            this.addChild(c);
        }
        this.width = pos.x * scale;
        this.height = (pos.y + font.lineHeight) * scale;
    },
    clone: function() {
        return new BitmapText(this._text, this.font, {
            align: this.align,
            size: this.size
        });
    },
    updateTransform: function() {
        if (this.dirty) {
            for (var c = 0, cl = this.children.length; c < cl; ++c) {
                var child = this.children[c];
                child.visible = false;
                this.sprites.free(child);
            }
            this.renderText();
            this.dirty = false;
        }
        Container.prototype.updateTransform.call(this);
    }
});

Object.defineProperty(BitmapText.prototype, "text", {
    get: function() {
        return this._text;
    },
    set: function(text) {
        this._text = text;
        this.dirty = true;
    }
});

BitmapText.parseXML = function(key, xml, texture) {
    var btx = texture.baseTexture;
    if (!xml.getElementsByTagName("font")) {
        utils.warn("Invalid XML for BitmapText.parseXML(), missing <font> tag. Full XML:", xml);
    }
    var data = {}, info = xml.getElementsByTagName("info")[0], common = xml.getElementsByTagName("common")[0];
    data.name = info.attributes.getNamedItem("face").nodeValue;
    data.size = parseInt(info.attributes.getNamedItem("size").nodeValue, 10);
    data.lineHeight = parseInt(common.attributes.getNamedItem("lineHeight").nodeValue, 10);
    data.chars = {};
    var chars = xml.getElementsByTagName("char");
    for (var i = 0, il = chars.length; i < il; ++i) {
        var letter = chars[i], attrs = letter.attributes.getNamedItem, code = parseInt(attrs("id").nodeValue, 10), rect = new Rectangle(parseInt(attrs("x").nodeValue, 10), parseInt(attrs("y").nodeValue, 10), parseInt(attrs("width").nodeValue, 10), parseInt(attrs("height").nodeValue, 10)), tx = PIXI.TextureCache[key + "_" + code] = new Texture(btx, rect);
        data.chars[code] = {
            xOffset: parseInt(attrs("xoffset").nodeValue, 10),
            yOffset: parseInt(attrs("yoffset").nodeValue, 10),
            xAdvance: parseInt(attrs("xadvance").nodeValue, 10),
            kerning: {},
            texture: tx
        };
    }
    var kernings = xml.getElementsByTagName("kerning");
    for (i = 0, il = kernings.length; i < il; ++i) {
        var kern = kernings[i], attrs2 = kern.attributes.getNamedItem, first = parseInt(attrs2("first").nodeValue, 10), second = parseInt(attrs2("second").nodeValue, 10), amount = parseInt(attrs2("amount").nodeValue, 10);
        data.chars[second].kerning[first] = amount;
    }
    PIXI.BitmapText.fonts[data.name] = data;
    return data;
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('utils/ObjectFactory',['require', 'exports', 'module', './inherit', '../gui/GuiItem', '../display/Sprite', '../tilemap/Tilemap', '../math/Rectangle', '../text/BitmapText', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("./inherit"), GuiItem = require("../gui/GuiItem"), Sprite = require("../display/Sprite"), Tilemap = require("../tilemap/Tilemap"), Rectangle = require("../math/Rectangle"), BitmapText = require("../text/BitmapText"), C = require("../constants");

var ObjectFactory = module.exports = function(state, parent) {
    this.state = state;
    this.game = state.game;
    this.parent = parent;
};

inherit(ObjectFactory, Object, {
    obj: function(obj) {
        return this.parent.addChild(obj);
    },
    sprite: function(tx, frame, physics) {
        var spr, game = this.game;
        if (typeof tx === "string") {
            if (frame || frame === 0) tx = game.cache.getTextures(tx)[frame]; else tx = game.cache.getTexture(tx);
        }
        if (!tx) {
            tx = game.cache.getTexture("__default");
        }
        spr = new Sprite(tx);
        if (physics || physics === undefined) {
            this.state.physics.addSprite(spr);
        }
        return this.parent.addChild(spr);
    },
    audio: function(key, settings) {
        return this.game.audio.addChild(key, settings);
    },
    tilemap: function(key, constrain) {
        var obj = this.game.cache.getTilemap(key) || {}, fmt = obj.format, data = obj.data, txs = obj.textures, tilemap;
        if (fmt === C.FILE_FORMAT.JSON) {
            tilemap = new Tilemap(this.game, data, txs);
        } else if (fmt === C.FILE_FORMAT.XML) {
            tilemap = Tilemap.fromXML(this.game, data, txs);
        } else if (fmt === C.FILE_FORMAT.CSV) {
            tilemap = Tilemap.fromCSV(this.game, data, txs);
        }
        if (constrain) {
            this.state.camera.constrain(new Rectangle(0, 0, tilemap.realSize.x, tilemap.realSize.y));
        }
        return this.parent.addChild(tilemap);
    },
    gui: function(tx, interact) {
        if (typeof tx === "string") tx = this.game.cache.getTexture(tx);
        return this.parent.addChild(new GuiItem(tx, interact));
    },
    bitmaptext: function(text, font, style) {
        if (typeof font === "string") font = this.game.cache.getBitmapFont(font);
        return this.parent.addChild(new BitmapText(text, font, style));
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('camera/Camera',['require', 'exports', 'module', '../display/Container', '../display/Sprite', '../math/Rectangle', '../math/Vector', '../utils/ObjectFactory', '../utils/inherit', '../math/math', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Container = require("../display/Container"), Sprite = require("../display/Sprite"), Rectangle = require("../math/Rectangle"), Vector = require("../math/Vector"), ObjectFactory = require("../utils/ObjectFactory"), inherit = require("../utils/inherit"), math = require("../math/math"), C = require("../constants");

var Camera = module.exports = function(state) {
    this.world = state.world;
    this.game = state.game;
    this.state = state;
    this.bounds = state.world.bounds.clone();
    this._deadzone = null;
    this._target = null;
    this.size = new Vector(0, 0);
    this.hSize = new Vector(0, 0);
    this.gui = new Container;
    this.add = new ObjectFactory(state, this.gui);
    Container.call(this);
    this.addChild(this.gui);
};

inherit(Camera, Container, {
    follow: function(spr, style) {
        if (!(spr instanceof Sprite)) return this;
        this._target = spr;
        switch (style) {
          case C.CAMERA_FOLLOW.PLATFORMER:
            var w = this.size.x / 8;
            var h = this.size.y / 3;
            this._deadzone = new Rectangle((this.size.x - w) / 2, (this.size.y - h) / 2 - h / 4, w, h);
            break;
          case C.CAMERA_FOLLOW.TOPDOWN:
            var sq4 = Math.max(this.size.x, this.size.y) / 4;
            this._deadzone = new Rectangle((this.size.x - sq4) / 2, (this.size.y - sq4) / 2, sq4, sq4);
            break;
          case C.CAMERA_FOLLOW.TOPDOWN_TIGHT:
            var sq8 = Math.max(this.size.x, this.size.y) / 8;
            this._deadzone = new Rectangle((this.size.x - sq8) / 2, (this.size.y - sq8) / 2, sq8, sq8);
            break;
          case C.CAMERA_FOLLOW.LOCKON:
          default:
            this._deadzone = null;
            break;
        }
        this.focusSprite(this._target);
        return this;
    },
    unfollow: function() {
        this._target = null;
        return this;
    },
    focusSprite: function(spr) {
        return this.focus(math.round(spr.position.x), math.round(spr.position.y));
    },
    focus: function(x, y) {
        y = x.y !== undefined ? x.y : y || 0;
        x = x.x !== undefined ? x.x : x || 0;
        var goToX = x - this.hSize.x, goToY = y - this.hSize.y, dx = goToX + this.world.position.x, dy = goToY + this.world.position.y;
        return this.pan(dx, dy);
    },
    pan: function(dx, dy) {
        dy = dx.y !== undefined ? dx.y : dy || 0;
        dx = dx.x !== undefined ? dx.x : dx || 0;
        if (!dx && !dy) return;
        var pos = this.world.position, newX = pos.x - dx, newY = pos.y - dy, b = this.bounds;
        if (b) {
            if (this._outsideBounds(-newX, -pos.y)) {
                dx = (dx < 0 ? b.x : b.right - this.size.x) + pos.x;
            }
            if (this._outsideBounds(-pos.x, -newY)) {
                dy = (dy < 0 ? b.y : b.bottom - this.size.y) + pos.y;
            }
        }
        if (!dx) dx = 0;
        if (!dy) dy = 0;
        this.world.pan(-dx, -dy);
        return this;
    },
    _outsideBounds: function(x, y) {
        return !this.bounds.contains(x, y) || !this.bounds.contains(x, y + this.size.y) || !this.bounds.contains(x + this.size.x, y) || !this.bounds.contains(x + this.size.x, y + this.size.y);
    },
    resize: function(w, h) {
        this.size.set(w, h);
        this.hSize.set(math.round(this.size.x / 2), math.round(this.size.y / 2));
        return this;
    },
    constrain: function(shape) {
        this.bounds = shape;
        return this;
    },
    unconstrain: function() {
        this.bounds = null;
        return this;
    },
    update: function(dt) {
        if (this._target) {
            if (!this._deadzone) {
                this.focusSprite(this._target);
            } else {
                var moveX, moveY, dx, dy, camX = this._target.position.x + this.world.position.x, camY = this._target.position.y + this.world.position.y;
                moveX = moveY = dx = dy = 0;
                dx = camX - this._deadzone.x;
                dy = camY - this._deadzone.y;
                if (dx < 0) moveX = dx;
                if (dy < 0) moveY = dy;
                dx = camX - (this._deadzone.x + this._deadzone.width);
                dy = camY - (this._deadzone.y + this._deadzone.height);
                if (dx > 0) moveX = dx;
                if (dy > 0) moveY = dy;
                this.pan(math.round(moveX), math.round(moveY));
            }
        }
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var c = this.children[i];
            if (c.update) c.update(dt);
        }
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('display/AnimatedSprite',['require', 'exports', 'module', './Sprite', './Texture', '../utils/inherit', '../math/math'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Sprite = require("./Sprite"), Texture = require("./Texture"), inherit = require("../utils/inherit"), math = require("../math/math");

var AnimatedSprite = module.exports = function(anims, speed, start) {
    if (anims instanceof Array) {
        anims = {
            _default: {
                frames: anims
            }
        };
        start = "_default";
    } else {
        for (var a in anims) {
            if (start === undefined) start = a;
            var anim = anims[a];
            if (anim instanceof Array) anims[a] = {
                frames: anim
            }; else if (anim instanceof Texture) anims[a] = {
                frames: [ anim ]
            };
        }
    }
    Sprite.call(this, anims[start].frames[0]);
    this.speed = speed || 1;
    this.loop = false;
    this.animations = anims;
    this.currentAnimation = start;
    this.currentFrame = 0;
    this.playing = false;
};

inherit(AnimatedSprite, Sprite, {
    addAnimation: function(name, frames, speed, loop) {
        if (typeof name === "object") {
            this.animations[name.name] = name;
        } else {
            this.animations[name] = {
                name: name,
                frames: frames,
                speed: speed,
                loop: loop
            };
        }
    },
    gotoAndPlay: function(anim, frame) {
        if (typeof anim === "number") {
            this.currentFrame = anim;
        } else {
            this.currentFrame = frame || 0;
            this.lastRound = math.round(frame || 0);
            this.currentAnimation = anim;
        }
        this.playing = true;
        this.setTexture(this.animations[this.currentAnimation].frames[this.currentFrame]);
        this.emit("frame", this.currentAnimation, this.lastRound);
    },
    gotoAndStop: function(anim, frame) {
        if (typeof anim === "number") {
            this.currentFrame = anim;
        } else {
            this.currentFrame = frame || 0;
            this.lastRound = math.round(frame || 0);
            this.currentAnimation = anim;
        }
        this.playing = false;
        this.setTexture(this.animations[this.currentAnimation].frames[this.currentFrame]);
        this.emit("frame", this.currentAnimation, this.lastRound);
    },
    play: function() {
        this.playing = true;
    },
    stop: function() {
        this.playing = false;
    },
    updateTransform: function() {
        Sprite.prototype.updateTransform.call(this);
        if (!this.playing) return;
        var anim = this.animations[this.currentAnimation], round, loop = anim.loop !== undefined ? anim.loop : this.loop;
        this.currentFrame += anim.speed || this.speed;
        round = math.round(this.currentFrame);
        if (round < anim.frames.length) {
            if (round !== this.lastRound) {
                this.lastRound = round;
                this.setTexture(anim.frames[round]);
                this.emit("frame", this.currentAnimation, round);
            }
        } else {
            if (loop) {
                this.gotoAndPlay(0);
            } else {
                this.stop();
                this.emit("complete", this.currentAnimation);
            }
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('fx/camera/Effect',['require', 'exports', 'module', '../../display/Container', '../../utils/inherit', '../../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Container = require("../../display/Container"), inherit = require("../../utils/inherit"), PIXI = require("../../vendor/pixi");

var Effect = module.exports = function() {
    Container.call(this);
    this.addChild(this.gfx = new PIXI.Graphics);
    this.gfx.visible = false;
    this.done = true;
};

inherit(Effect, Container, {
    start: function() {
        this.done = false;
        return this;
    },
    stop: function() {
        this.done = true;
        return this;
    },
    update: function() {
        return this;
    },
    _complete: function() {
        this.done = true;
        if (typeof this.cb === "function") {
            var ret = this.cb();
            if (ret !== false) this.stop();
        } else {
            this.stop();
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('fx/camera/Close',['require', 'exports', 'module', './Effect', '../../utils/inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Effect = require("./Effect"), inherit = require("../../utils/inherit");

var Close = module.exports = function() {
    Effect.call(this);
};

inherit(Close, Effect, {
    start: function(shape, duration, pos, cb) {
        Effect.prototype.start.call(this);
        if (typeof pos === "function") {
            cb = pos;
            pos = null;
        }
        if (typeof duration === "function") {
            cb = duration;
            pos = null;
            duration = null;
        }
        if (typeof shape === "function") {
            cb = shape;
            pos = null;
            duration = null;
            shape = null;
        }
        this.shape = shape || "circle";
        this.duration = duration && duration > 0 ? duration : 1e3;
        this.cb = cb;
        this.cx = pos ? pos.x : this.parent.size.x / 2;
        this.cy = pos ? pos.y : this.parent.size.y / 2;
        this.w = this.mx = this.parent.size.x;
        this.h = this.my = this.parent.size.y;
        this.radius = this.maxRadius = Math.max(this.w / 2, this.h / 2);
        this.gfx.visible = true;
        this.gfx.position.x = this.cx;
        this.gfx.position.y = this.cy;
        this.parent.game.activeState.mask = this.gfx;
        if (shape === "ellipse") {
            this.gfx.scale.y = .5;
        } else {
            this.gfx.scale.y = 1;
        }
        return this;
    },
    stop: function() {
        Effect.prototype.stop.call(this);
        this.radius = this.sx = this.sy = 0;
        this.gfx.visible = false;
        if (this.parent.game.activeState.mask === this.gfx) this.parent.game.activeState.mask = null;
        return this;
    },
    update: function(dt) {
        if (this.done) return;
        var part = dt * 1e3 / this.duration;
        this.gfx.clear();
        this.gfx.beginFill(16711935);
        switch (this.shape) {
          case "ellipse":
          case "circle":
            this.radius -= part * this.maxRadius;
            if (this.radius <= 0) {
                this._complete();
            } else {
                this.gfx.drawCircle(0, 0, this.radius);
            }
            break;
          case "rect":
          case "rectangle":
            this.w -= part * this.mx;
            this.h -= part * this.my;
            if (this.w <= 0) {
                this._complete();
            } else {
                this.gfx.drawRect(-(this.w / 2), -(this.h / 2), this.w, this.h);
            }
            break;
        }
        this.gfx.endFill();
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('fx/camera/Fade',['require', 'exports', 'module', './Effect', '../../utils/inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Effect = require("./Effect"), inherit = require("../../utils/inherit");

var Fade = module.exports = function() {
    Effect.call(this);
};

inherit(Fade, Effect, {
    start: function(color, duration, alpha, cb) {
        Effect.prototype.start.call(this);
        if (typeof alpha === "function") {
            cb = duration;
            alpha = null;
        }
        if (typeof duration === "function") {
            cb = duration;
            alpha = null;
            duration = null;
        }
        if (typeof color === "function") {
            cb = color;
            alpha = null;
            duration = null;
            color = null;
        }
        color = typeof color === "number" ? color : 16777215;
        this.goal = alpha || 1;
        this.duration = duration && duration > 0 ? duration : 1e3;
        this.cb = cb;
        this.gfx.visible = true;
        this.gfx.alpha = 0;
        this.gfx.clear();
        this.gfx.beginFill(color);
        this.gfx.drawRect(0, 0, this.parent.size.x, this.parent.size.y);
        return this;
    },
    stop: function() {
        Effect.prototype.stop.call(this);
        this.gfx.alpha = 0;
        this.gfx.visible = false;
        return this;
    },
    update: function(dt) {
        if (this.done) return;
        if (this.gfx.alpha < this.goal) {
            this.gfx.alpha += dt * 1e3 / this.duration;
            if (this.gfx.alpha >= this.goal) {
                this._complete();
            }
        }
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('fx/camera/Flash',['require', 'exports', 'module', './Effect', '../../utils/inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Effect = require("./Effect"), inherit = require("../../utils/inherit");

var Flash = module.exports = function() {
    Effect.call(this);
};

inherit(Flash, Effect, {
    start: function(color, duration, alpha, cb) {
        Effect.prototype.start.call(this);
        if (typeof alpha === "function") {
            cb = duration;
            alpha = null;
        }
        if (typeof duration === "function") {
            cb = duration;
            alpha = null;
            duration = null;
        }
        if (typeof color === "function") {
            cb = color;
            alpha = null;
            duration = null;
            color = null;
        }
        alpha = alpha || 1;
        color = typeof color === "number" ? color : 16777215;
        this.duration = duration && duration > 0 ? duration : 1e3;
        this.cb = cb;
        this.gfx.visible = true;
        this.gfx.alpha = alpha;
        this.gfx.clear();
        this.gfx.beginFill(color);
        this.gfx.drawRect(0, 0, this.parent.size.x, this.parent.size.y);
        return this;
    },
    stop: function() {
        Effect.prototype.stop.call(this);
        this.gfx.alpha = 0;
        this.gfx.visible = false;
        return this;
    },
    update: function(dt) {
        if (this.done) return;
        if (this.gfx.alpha > 0) {
            this.gfx.alpha -= dt * 1e3 / this.duration;
            if (this.gfx.alpha <= 0) {
                this._complete();
            }
        }
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('fx/camera/Scanlines',['require', 'exports', 'module', './Effect', '../../utils/inherit', '../../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Effect = require("./Effect"), inherit = require("../../utils/inherit"), C = require("../../constants");

var Scanlines = module.exports = function() {
    Effect.call(this);
};

inherit(Scanlines, Effect, {
    start: function(color, direction, spacing, thickness, alpha) {
        Effect.prototype.start.call(this);
        color = color || 0;
        direction = direction || C.AXIS.HORIZONTAL;
        spacing = spacing || 4;
        thickness = thickness || 1;
        alpha = alpha || .3;
        var sx = this.parent.size.x, sy = this.parent.size.y;
        this.gfx.clear();
        this.gfx.visible = true;
        this.gfx.beginFill(color, alpha);
        if (direction & C.AXIS.VERTICAL) {
            for (var x = 0; x < sx; x += spacing) {
                this.gfx.drawRect(x, 0, thickness, sy);
            }
        }
        if (direction & C.AXIS.HORIZONTAL) {
            for (var y = 0; y < sy; y += spacing) {
                this.gfx.drawRect(0, y, sx, thickness);
            }
        }
        this.gfx.endFill();
        return this;
    },
    stop: function() {
        Effect.prototype.stop.call(this);
        this.gfx.visible = false;
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('fx/camera/Shake',['require', 'exports', 'module', './Effect', '../../math/Vector', '../../utils/inherit', '../../math/math', '../../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Effect = require("./Effect"), Vector = require("../../math/Vector"), inherit = require("../../utils/inherit"), math = require("../../math/math"), C = require("../../constants");

var Shake = module.exports = function() {
    Effect.call(this);
    this.offset = new Vector;
};

inherit(Shake, Effect, {
    start: function(intensity, duration, direction, cb) {
        Effect.prototype.start.call(this);
        if (typeof direction === "function") {
            cb = direction;
            direction = null;
        }
        if (typeof duration === "function") {
            cb = duration;
            direction = null;
            duration = null;
        }
        if (typeof intensity === "function") {
            cb = intensity;
            direction = null;
            duration = null;
            intensity = null;
        }
        this.intensity = intensity || .01;
        this.duration = duration || 1e3;
        this.direction = direction || C.AXIS.BOTH;
        this.offset.x = this.offset.y = 0;
        this.cb = cb;
        return this;
    },
    stop: function() {
        Effect.prototype.stop.call(this);
        this.duration = this.offset.x = this.offset.y = 0;
        return this;
    },
    update: function(dt) {
        if (this.done) return;
        this.duration -= dt * 1e3;
        this.offset.x = -this.offset.x;
        this.offset.y = -this.offset.y;
        this.parent.pan(this.offset.x, this.offset.y);
        if (this.duration <= 0) {
            this._complete();
        } else {
            if (this.direction & C.AXIS.HORIZONTAL) this.offset.x = math.round(Math.random() * this.intensity * this.parent.size.x * 2 - this.intensity * this.parent.size.x);
            if (this.direction & C.AXIS.VERTICAL) this.offset.y = math.round(Math.random() * this.intensity * this.parent.size.y * 2 - this.intensity * this.parent.size.y);
            this.parent.pan(this.offset.x, this.offset.y);
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('game/World',['require', 'exports', 'module', '../utils/inherit', '../display/Container', '../math/Rectangle', '../utils/ObjectFactory'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), Container = require("../display/Container"), Rectangle = require("../math/Rectangle"), ObjectFactory = require("../utils/ObjectFactory");

var World = module.exports = function(state) {
    this.game = state.game;
    this.state = state;
    this.bounds = new Rectangle(0, 0, state.game.width, state.game.height);
    this.add = new ObjectFactory(state, this);
    Container.call(this);
};

inherit(World, Container, {
    pan: function(x, y) {
        y = x.y !== undefined ? x.y : y || 0;
        x = x.x !== undefined ? x.x : x || 0;
        this.position.x += x * this.scale.x;
        this.position.y += y * this.scale.y;
        return this;
    },
    update: function() {
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.render) o.render(-this.position.x, -this.position.y, this.game.camera.size.x, this.game.camera.size.y);
        }
        return this;
    },
    resize: function(w, h) {
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.resize) o.resize(w, h);
        }
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('math/QuadTree',['require', 'exports', 'module', './Rectangle', './math', '../utils/inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Rectangle = require("./Rectangle"), math = require("./math"), inherit = require("../utils/inherit");

var QuadTree = module.exports = function(bounds, maxObjects, maxLevels, level) {
    this.maxObjects = maxObjects || 10;
    this.maxLevels = maxLevels || 4;
    this.level = level || 0;
    this.setBounds(bounds);
    this.objects = [];
    this.nodes = [];
    this._nextLevel = this.level;
};

inherit(QuadTree, Object, {
    split: function() {
        var b = this.bounds;
        this._nextLevel++;
        this.nodes[0] = new QuadTree(new Rectangle(b.midX, b.y, b.subWidth, b.subHeight), this.maxObjects, this.maxLevels, this._nextLevel);
        this.nodes[1] = new QuadTree(new Rectangle(b.x, b.y, b.subWidth, b.subHeight), this.maxObjects, this.maxLevels, this._nextLevel);
        this.nodes[2] = new QuadTree(new Rectangle(b.x, b.midY, b.subWidth, b.subHeight), this.maxObjects, this.maxLevels, this._nextLevel);
        this.nodes[3] = new QuadTree(new Rectangle(b.midX, b.midY, b.subWidth, b.subHeight), this.maxObjects, this.maxLevels, this._nextLevel);
    },
    insert: function(body) {
        var i = 0, index = -1;
        if (this.nodes[0]) {
            index = this.getIndex(body);
            if (index !== -1) {
                this.nodes[index].insert(body);
                return;
            }
        }
        this.objects.push(body);
        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
            if (!this.nodes[0]) {
                this.split();
            }
            while (i < this.objects.length) {
                index = this.getIndex(this.objects[i]);
                if (index !== -1) {
                    this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                } else {
                    i++;
                }
            }
        }
    },
    getIndex: function(body) {
        var index = -1;
        if (body.x < this.bounds.midX && body.right < this.bounds.midX) {
            if (body.y < this.bounds.midY && body.bottom < this.bounds.midY) {
                index = 1;
            } else if (body.y > this.bounds.midY) {
                index = 2;
            }
        } else if (body.x > this.bounds.midX) {
            if (body.y < this.bounds.midY && body.bottom < this.bounds.midY) {
                index = 0;
            } else if (body.y > this.bounds.midY) {
                index = 3;
            }
        }
        return index;
    },
    retrieve: function(body) {
        var returnObjects = this.objects, index = this.getIndex(body);
        if (this.nodes[0]) {
            if (index !== -1) {
                returnObjects = returnObjects.concat(this.nodes[index].retrieve(body));
            } else {
                returnObjects = returnObjects.concat(this.nodes[0].retrieve(body));
                returnObjects = returnObjects.concat(this.nodes[1].retrieve(body));
                returnObjects = returnObjects.concat(this.nodes[2].retrieve(body));
                returnObjects = returnObjects.concat(this.nodes[3].retrieve(body));
            }
        }
        return returnObjects;
    },
    clear: function() {
        if (this.nodes[0]) {
            this.nodes[0].clear();
            this.nodes[1].clear();
            this.nodes[2].clear();
            this.nodes[3].clear();
        }
        this.objects.length = 0;
        this.nodes.length = 0;
    },
    setBounds: function(bounds) {
        this.bounds = bounds;
        bounds.x = math.round(bounds.x);
        bounds.y = math.round(bounds.y);
        bounds.width = math.round(bounds.width);
        bounds.height = math.round(bounds.height);
        bounds.subWidth = Math.floor(bounds.width / 2);
        bounds.subHeight = Math.floor(bounds.height / 2);
        bounds.midX = bounds.x + bounds.subWidth;
        bounds.midY = bounds.y + bounds.subHeight;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('physics/Body',['require', 'exports', 'module', '../math/Rectangle', '../math/Vector', '../math/math', '../utils/inherit', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Rectangle = require("../math/Rectangle"), Vector = require("../math/Vector"), math = require("../math/math"), inherit = require("../utils/inherit"), C = require("../constants");

var Body = module.exports = function(sprite) {
    Rectangle.call(this, sprite.position.x, sprite.position.y, sprite.width, sprite.height);
    this.sprite = sprite;
    this.size = sprite.currentFrame;
    this.type = C.PHYSICS_TYPE.DYNAMIC;
    this.solveType = C.SOLVE_TYPE.DISPLACE;
    this.velocity = new Vector;
    this.accel = new Vector;
    this.drag = new Vector;
    this.gravity = new Vector;
    this.bounce = new Vector;
    this.offset = new Vector;
    this.maxVelocity = new Vector(1e4, 1e4);
    this.angularVelocity = 0;
    this.angularAccel = 0;
    this.angularDrag = 0;
    this.maxAngular = 1e3;
    this.mass = 1;
    this.rotation = 0;
    this.allowRotation = true;
    this.allowCollide = C.DIRECTION.ALL;
    this.touching = C.DIRECTION.NONE;
    this.wasTouching = C.DIRECTION.NONE;
    this.overlap = new Vector;
    this.lastPos = new Vector;
    this._accel = 0;
    this._drag = 0;
    this._vDelta = 0;
    this._accel = 0;
    this._accel = 0;
};

inherit(Body, Rectangle, {
    computeVelocity: function(dt, vel, accel, drag, maxVel) {
        this._accel = accel * dt;
        this._drag = drag * dt;
        if (this._accel) {
            vel += this._accel;
        } else if (this._drag) {
            if (vel - this._drag > 0) vel -= this._drag; else if (vel + this._drag < 0) vel += this._drag; else vel = 0;
        }
        if (vel) math.clamp(vel, -maxVel, maxVel);
        return vel;
    },
    updateMotion: function(dt) {
        if (this.type === C.PHYSICS_TYPE.DYNAMIC) {
            this.velocity.x += this.gravity.x * dt;
            this.velocity.y += this.gravity.y * dt;
        }
        this._vDelta = (this.computeVelocity(dt, this.angularVelocity, this.angularAccel, this.angularDrag, this.maxAngular) - this.angularVelocity) / 2;
        this.angularVelocity += this._vDelta;
        this.rotation += this.angularVelocity * dt;
        this._vDelta = (this.computeVelocity(dt, this.velocity.x, this.accel.x, this.drag.x, this.maxVelocity.x) - this.velocity.x) / 2;
        this.velocity.x += this._vDelta;
        this.x += this.velocity.x * dt;
        this._vDelta = (this.computeVelocity(dt, this.velocity.y, this.accel.y, this.drag.y, this.maxVelocity.y) - this.velocity.y) / 2;
        this.velocity.y += this._vDelta;
        this.y += this.velocity.y * dt;
    },
    update: function(dt) {
        this.wasTouching = this.touching;
        this.touching = C.DIRECTION.NONE;
        this.lastPos.set(this.x, this.y);
        this.x = this.sprite.position.x - this.sprite.anchor.x * this._width + this.offset.x;
        this.y = this.sprite.position.y - this.sprite.anchor.y * this._height + this.offset.y;
        this.rotation = this.sprite.angle;
        if (this.type !== C.PHYSICS_TYPE.STATIC) this.updateMotion(dt);
        this.syncSprite();
    },
    syncSprite: function() {
        this.sprite.position.x = this.x - this.offset.x + this.sprite.anchor.x * this._width;
        this.sprite.position.y = this.y - this.offset.y + this.sprite.anchor.y * this._height;
        if (this.allowRotation) {
            this.sprite.angle = this.rotation;
        }
    },
    deltaX: function() {
        return this.x - this.lastPos.x;
    },
    deltaY: function() {
        return this.y - this.lastPos.y;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('physics/Physics',['require', 'exports', 'module', '../math/QuadTree', '../math/Rectangle', '../display/Container', '../display/Sprite', '../tilemap/Tilemap', './Body', '../utils/inherit', '../math/math', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var QuadTree = require("../math/QuadTree"), Rectangle = require("../math/Rectangle"), Container = require("../display/Container"), Sprite = require("../display/Sprite"), Tilemap = require("../tilemap/Tilemap"), Body = require("./Body"), inherit = require("../utils/inherit"), math = require("../math/math"), C = require("../constants");

var Physics = module.exports = function(state) {
    this.state = state;
    this.maxObjects = C.PHYSICS.MAX_QUAD_OBJECTS;
    this.maxLevels = C.PHYSICS.MAX_QUAD_LEVELS;
    this.tree = new QuadTree(state.world.bounds.clone(), this.maxObjects, this.maxLevels);
    this.bodies = [];
    this._result = false;
    this._total = 0;
    this._overlap = 0;
    this._maxOverlap = 0;
    this._velocity1 = 0;
    this._velocity2 = 0;
    this._newVelocity1 = 0;
    this._newVelocity2 = 0;
    this._average = 0;
    this._mapData = null;
    this._potentials = null;
    this._bounds1 = new Rectangle;
    this._bounds2 = new Rectangle;
};

inherit(Physics, Object, {
    update: function(dt) {
        this.tree.clear();
        var bods = this.bodies;
        for (var i = 0, il = bods.length, body; i < il; ++i) {
            body = bods[i];
            body.computeVelocity(dt);
            body.update(dt);
            if (body.canCollide && body.sprite.visible) {
                this.tree.insert(body);
            }
        }
    },
    addSprite: function(sprite) {
        if (!sprite.body) sprite.body = new Body(sprite);
        this.bodies.push(sprite.body);
        sprite._physics = this;
    },
    removeSprite: function(sprite) {
        var i = this.bodies.indexOf(sprite.body);
        if (i !== -1) this.bodies.splice(i, 1);
    },
    collide: function(obj1, obj2, onCollision) {
        if (obj1 && obj2) {
            if (obj1 instanceof Sprite) {
                if (obj2 instanceof Sprite) {
                    this._collideSpriteVsSprite(obj1, obj2, onCollision);
                } else if (obj2 instanceof Tilemap) {
                    this._collideSpriteVsTilemap(obj1, obj2, onCollision);
                } else if (obj2 instanceof Container) {
                    this._collideSpriteVsContainer(obj1, obj2, onCollision);
                }
            } else if (obj1 instanceof Tilemap) {
                if (obj2 instanceof Sprite) {
                    this._collideSpriteVsTilemap(obj2, obj1, onCollision);
                } else if (obj2 instanceof Container) {
                    this._collideContainerVsTilemap(obj2, obj1, onCollision);
                }
            } else if (obj1 instanceof Container) {
                if (obj2 instanceof Sprite) {
                    this._collideSpriteVsContainer(obj2, obj1, onCollision);
                } else if (obj2 instanceof Tilemap) {
                    this._collideContainerVsTilemap(obj1, obj2, onCollision);
                } else if (obj2 instanceof Container) {
                    this._collideContainerVsContainer(obj1, obj2, onCollision);
                }
            }
        }
    },
    separate: function(b1, b2) {
        this._result = this._separateX(b1, b2) || this._separateY(b1, b2);
        if (this._result) {
            b1.syncSprite();
            b2.syncSprite();
        }
    },
    _hit: function(obj1, obj2, cb) {
        this._total++;
        if (cb) cb(obj1, obj2);
    },
    _separateX: function(b1, b2) {
        if (b1.type === C.PHYSICS_TYPE.STATIC && b2.type === C.PHYSICS_TYPE.STATIC) return;
        this._overlap = 0;
        var dx1 = b1.deltaX(), dx2 = b2.deltaX();
        if (dx1 === dx2) return false;
        this._bounds1.x = b1.x - (dx1 > 0 ? dx1 : 0);
        this._bounds1.y = b1.lastPos.y;
        this._bounds1.width = b1.width + (dx1 > 0 ? dx1 : -dx1);
        this._bounds1.height = b1.height;
        this._bounds2.x = b2.x - (dx2 > 0 ? dx2 : 0);
        this._bounds2.y = b2.lastPos.y;
        this._bounds2.width = b2.width + (dx2 > 0 ? dx2 : -dx2);
        this._bounds2.height = b2.height;
        if (this._bounds1.overlap(this._bounds2)) {
            this._maxOverlap = math.abs(dx1) + math.abs(dx2) + C.PHYSICS.OVERLAP_BIAS;
            if (dx1 > dx2) {
                this._overlap = b1.right - b2.x;
                if (this._overlap > this._maxOverlap || !(b1.allowCollide & C.DIRECTION.RIGHT) || !(b2.allowCollide & C.DIRECTION.LEFT)) {
                    this._overlap = 0;
                } else {
                    b1.touching |= C.DIRECTION.RIGHT;
                    b2.touching |= C.DIRECTION.LEFT;
                }
            } else if (dx1 < dx2) {
                this._overlap = b1.x - b2.width - b2.x;
                if (-this._overlap > this._maxOverlap || !(b1.allowCollide & C.DIRECTION.LEFT) || !(b2.allowCollide & C.DIRECTION.RIGHT)) {
                    this._overlap = 0;
                } else {
                    b1.touching |= C.DIRECTION.LEFT;
                    b2.touching |= C.DIRECTION.RIGHT;
                }
            }
        }
        if (this._overlap) {
            b1.overlap.x = b2.overlap.x = this._overlap;
            this._velocity1 = b1.velocity.x;
            this._velocity2 = b2.velocity.x;
            if (b1.type !== C.PHYSICS_TYPE.STATIC && b2.type !== C.PHYSICS_TYPE.STATIC) {
                this._overlap *= .5;
                b1.x = b1.x - this._overlap;
                b2.x += this._overlap;
                this._newVelocity1 = math.sqrt(this._velocity2 * this._velocity2 * b2.mass / b1.mass) * (this._velocity2 > 0 ? 1 : -1);
                this._newVelocity2 = math.sqrt(this._velocity1 * this._velocity1 * b1.mass / b2.mass) * (this._velocity1 > 0 ? 1 : -1);
                this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                this._newVelocity1 -= this._average;
                this._newVelocity2 -= this._average;
                b1.velocity.x = this._average + this._newVelocity1 * b1.bounce.x;
                b2.velocity.x = this._average + this._newVelocity2 * b1.bounce.x;
            } else if (b1.type !== C.PHYSICS_TYPE.STATIC) {
                b1.x -= this._overlap;
                b1.velocity.x = this._velocity2 - this._velocity1 * b1.bounce.x;
            } else if (b2.type !== C.PHYSICS_TYPE.STATIC) {
                b2.x += this._overlap;
                b2.velocity.x = this._velocity1 - this._velocity2 * b2.bounce.x;
            }
            return true;
        }
        return false;
    },
    _separateY: function(b1, b2) {
        if (b1.type === C.PHYSICS_TYPE.STATIC && b2.type === C.PHYSICS_TYPE.STATIC) return;
        this._overlap = 0;
        var dy1 = b1.deltaY(), dy2 = b2.deltaY();
        if (dy1 === dy2) return false;
        this._bounds1.x = b1.x;
        this._bounds1.y = b1.y - (dy1 > 0 ? dy1 : 0);
        this._bounds1.width = b1.width;
        this._bounds1.height = b1.height + math.abs(dy1);
        this._bounds2.x = b2.x;
        this._bounds2.y = b2.y - (dy2 > 0 ? dy2 : 0);
        this._bounds2.width = b2.width;
        this._bounds2.height = b2.height + math.abs(dy2);
        if (this._bounds1.overlap(this._bounds2)) {
            this._maxOverlap = math.abs(dy1) + math.abs(dy2) + C.PHYSICS.OVERLAP_BIAS;
            if (dy1 > dy2) {
                this._overlap = b1.bottom - b2.y;
                if (this._overlap > this._maxOverlap || !(b1.allowCollide & C.DIRECTION.DOWN) || !(b2.allowCollide & C.DIRECTION.UP)) {
                    this._overlap = 0;
                } else {
                    b1.touching |= C.DIRECTION.DOWN;
                    b2.touching |= C.DIRECTION.UP;
                }
            } else if (dy1 < dy2) {
                this._overlap = b1.y - b2.height - b2.y;
                if (-this._overlap > this._maxOverlap || !(b1.allowCollide & C.DIRECTION.UP) || !(b2.allowCollide & C.DIRECTION.DOWN)) {
                    this._overlap = 0;
                } else {
                    b1.touching |= C.DIRECTION.UP;
                    b2.touching |= C.DIRECTION.DOWN;
                }
            }
        }
        if (this._overlap) {
            b1.overlap.y = b2.overlap.y = this._overlap;
            this._velocity1 = b1.velocity.y;
            this._velocity2 = b2.velocity.y;
            if (b1.type !== C.PHYSICS_TYPE.STATIC && b2.type !== C.PHYSICS_TYPE.STATIC) {
                this._overlap *= .5;
                b1.y = b1.y - this._overlap;
                b2.y += this._overlap;
                this._newVelocity1 = math.sqrt(this._velocity2 * this._velocity2 * b2.mass / b1.mass) * (this._velocity2 > 0 ? 1 : -1);
                this._newVelocity2 = math.sqrt(this._velocity1 * this._velocity1 * b1.mass / b2.mass) * (this._velocity1 > 0 ? 1 : -1);
                this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                this._newVelocity1 -= this._average;
                this._newVelocity2 -= this._average;
                b1.velocity.y = this._average + this._newVelocity1 * b1.bounce.y;
                b2.velocity.y = this._average + this._newVelocity2 * b1.bounce.y;
            } else if (b1.type !== C.PHYSICS_TYPE.STATIC) {
                b1.y -= this._overlap;
                b1.velocity.y = this._velocity2 - this._velocity1 * b1.bounce.y;
                if (b2.carry && dy1 > dy2) {
                    b1.x += b2.deltaX();
                }
            } else if (b2.type !== C.PHYSICS_TYPE.STATIC) {
                b2.y += this._overlap;
                b2.velocity.y = this._velocity1 - this._velocity2 * b2.bounce.y;
                if (b1.carry && dy1 < dy2) {
                    b2.x += b1.deltaX();
                }
            }
            return true;
        }
        return false;
    },
    _collideSpriteVsSprite: function(sprite1, sprite2, onCollision) {
        this.separate(sprite1.body, sprite2.body);
        if (this._result) {
            this._hit(sprite1, sprite2, onCollision);
        }
    },
    _collideSpriteVsTilemap: function(sprite, tilemap, onCollision) {
        this._mapData = tilemap.collisionLayer.getTileOverlaps(sprite);
        for (var i = 0, il = this._mapData.length; i < il; ++i) {
            this._hit(sprite, this._mapData[i].tile, onCollision);
        }
    },
    _collideContainerVsTilemap: function(container, tilemap, onCollision) {
        if (container.first._iNext) {
            var node = container.first._iNext;
            do {
                if (node instanceof Sprite) this.collideSpriteVsTilemap(node, tilemap, onCollision);
                node = node._iNext;
            } while (node !== container.last._iNext);
        }
    },
    _collideSpriteVsContainer: function(sprite, container, onCollision) {
        this._potentials = this.tree.retrieve(sprite);
        for (var i = 0, il = this._potentials.length; i < il; ++i) {
            if (this._potentials[i].sprite._container === container) {
                this.separate(sprite.body, this._potentials[i]);
                if (this._result) {
                    this._hit(sprite, container, onCollision);
                }
            }
        }
    },
    _collideContainerVsContainer: function(container1, container2, onCollision) {
        if (container1.first._iNext) {
            var node = container1.first._iNext;
            do {
                if (node instanceof Sprite) this.collideSpriteVsGroup(node, container2, onCollision);
                node = node._iNext;
            } while (node !== container1.last._iNext);
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('game/State',['require', 'exports', 'module', '../display/Container', './World', '../camera/Camera', '../physics/Physics', '../math/math', '../utils/inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Container = require("../display/Container"), World = require("./World"), Camera = require("../camera/Camera"), Physics = require("../physics/Physics"), math = require("../math/math"), inherit = require("../utils/inherit");

var State = module.exports = function(game, name) {
    if (!name) name = math.randomString();
    this.name = name;
    this.game = game;
    this.world = new World(this);
    this.physics = new Physics(this);
    this.camera = new Camera(this);
    Container.call(this);
    this.disable();
    this.addChild(this.camera);
    this.addChild(this.world);
    this.camera.resize(game.width, game.height);
};

inherit(State, Container, {
    enable: function() {
        this.visible = true;
        return this;
    },
    disable: function() {
        this.visible = false;
        return this;
    },
    resize: function(w, h) {
        this.camera.resize(w, h);
        this.world.resize(w, h);
    },
    update: function(dt) {
        this.game.timings.cameraStart = this.game.clock.now();
        this.camera.update(dt);
        this.game.timings.cameraEnd = this.game.clock.now();
        this.game.timings.worldStart = this.game.clock.now();
        this.world.update(dt);
        this.game.timings.worldEnd = this.game.clock.now();
        this.game.timings.physicsStart = this.game.clock.now();
        this.physics.update(dt);
        this.game.timings.physicsEnd = this.game.clock.now();
        return this;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('game/StateManager',['require', 'exports', 'module', '../utils/inherit', './State'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), State = require("./State");

var StateManager = module.exports = function(game) {
    this.game = game;
    this.states = {};
    this.active = null;
    this._createDefault();
};

inherit(StateManager, Object, {
    _createDefault: function() {
        return this.add("__default", true);
    },
    add: function(Name, enable) {
        var state;
        if (typeof Name === "string") {
            state = new State(this.game, Name);
        } else if (typeof Name === "function") {
            state = new Name(this.game);
        } else {
            state = Name;
            state.game = this.game;
        }
        this.states[state.name] = state;
        this.game.stage.addChild(state);
        if (enable) this.enable(state);
        return this;
    },
    remove: function(state) {
        if (typeof state === "string") state = this.states[state];
        if (state.parent) state.parent.removeChild(state);
        delete this.states[state.name];
    },
    enable: function(state) {
        if (typeof state !== "string") state = state.name;
        if (this.states[state]) {
            if (this.active) this.active.disable();
            this.active = this.states[state].enable();
        }
        return this;
    },
    destroy: function() {
        this.game = null;
        this.states = {};
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('utils/Cache',['require', 'exports', 'module', './inherit', '../constants', '../display/Texture', '../display/BaseTexture', '../text/BitmapText', '../vendor/pixi'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("./inherit"), C = require("../constants"), Texture = require("../display/Texture"), BaseTexture = require("../display/BaseTexture"), BitmapText = require("../text/BitmapText"), PIXI = require("../vendor/pixi");

var Cache = module.exports = function(game) {
    this.game = game;
    this._canvases = {};
    this._images = {};
    this._sounds = {};
    this._text = {};
    this._tilemaps = {};
    this.addDefaultImage();
};

inherit(Cache, Object, {
    addCanvas: function(obj) {
        this._canvases[obj.key] = obj;
    },
    addSpriteSheet: function(obj) {
        var key = obj.key;
        PIXI.BaseTextureCache[key] = new BaseTexture(obj.image);
        PIXI.TextureCache[key] = new Texture(PIXI.BaseTextureCache[key]);
        obj.texture = PIXI.TextureCache[key];
        obj.textures = Texture.fromSpritesheet(obj);
        this._images[key] = obj;
    },
    addTilemap: function(obj) {
        var key = obj.key, fmt = obj.format, tsets, name;
        if (fmt === C.FILE_FORMAT.XML) tsets = obj.data.getElementsByTagName("tilesets"); else if (fmt === C.FILE_FORMAT.JSON) tsets = obj.data.tilesets;
        obj.textures = {};
        for (var i = 0, il = obj.images.length; i < il; ++i) {
            if (fmt === C.FILE_FORMAT.JSON) name = tsets[i].name; else if (fmt === C.FILE_FORMAT.XML) name = tsets[i].attributes.getNamedItem("name").nodeValue;
            var k = key + "_" + name;
            PIXI.BaseTextureCache[k] = new BaseTexture(obj.images[i]);
            PIXI.TextureCache[k] = new Texture(PIXI.BaseTextureCache[k]);
            obj.textures[name] = PIXI.TextureCache[k];
        }
        this._tilemaps[key] = obj;
    },
    addTextureAtlas: function(obj) {
        var key = obj.key;
        PIXI.BaseTextureCache[key] = new BaseTexture(obj.image);
        PIXI.TextureCache[key] = new Texture(PIXI.BaseTextureCache[key]);
        obj.texture = PIXI.TextureCache[key];
        if (obj.format === C.ATLAS_FORMAT.JSON_ARRAY || obj.format === C.ATLAS_FORMAT.JSON_HASH) {
            obj.textures = Texture.fromJSON(key, obj.data, obj.texture.baseTexture);
        } else if (obj.format === C.ATLAS_FORMAT.STARLING_XML) {
            obj.textures = Texture.fromXML(key, obj.data, obj.texture.baseTexture);
        }
        this._images[key] = obj;
    },
    addBitmapFont: function(obj) {
        var key = obj.key;
        PIXI.BaseTextureCache[key] = new BaseTexture(obj.image);
        PIXI.TextureCache[key] = new Texture(PIXI.BaseTextureCache[key]);
        obj.texture = PIXI.TextureCache[key];
        obj.font = BitmapText.parseXML(key, obj.data, obj.texture);
        this._images[key] = obj;
    },
    addImage: function(obj) {
        var key = obj.key;
        PIXI.BaseTextureCache[key] = new BaseTexture(obj.image);
        PIXI.TextureCache[key] = new Texture(PIXI.BaseTextureCache[key]);
        obj.texture = PIXI.TextureCache[key];
        this._images[key] = obj;
    },
    addAudio: function(obj) {
        var key = obj.key;
        if (!obj.webAudio) {
            obj.decoded = true;
        }
        obj.isDecoding = false;
        this._sounds[key] = obj;
    },
    updateSound: function(key, property, value) {
        if (this._sounds[key]) this._sounds[key][property] = value;
    },
    addText: function(obj) {
        this._text[obj.key] = obj;
    },
    addDefaultImage: function() {
        var key = "__default";
        var base = new BaseTexture;
        base.width = 32;
        base.height = 32;
        base.hasLoaded = true;
        PIXI.BaseTextureCache[key] = base;
        PIXI.TextureCache[key] = new Texture(base);
        this._images[key] = {
            texture: PIXI.TextureCache[key]
        };
    },
    getCanvas: function(key) {
        if (this._canvases[key]) return this._canvases[key].canvas;
    },
    getImage: function(key) {
        if (this._images[key]) return this._images[key].image;
    },
    getTexture: function(key) {
        if (this._images[key]) return this._images[key].texture;
    },
    getTextures: function(key) {
        if (this._images[key]) return this._images[key].textures;
    },
    getBitmapFont: function(key) {
        if (this._images[key]) return this._images[key].font;
    },
    getTilemap: function(key) {
        return this._tilemaps[key];
    },
    getAudio: function(key) {
        return this._sounds[key];
    },
    getAudioData: function(key) {
        if (this._sounds[key]) return this._sounds[key].data;
    },
    getText: function(key) {
        if (this._text[key]) return this._text[key].data;
    },
    removeCanvas: function(key) {
        delete this._canvases[key];
    },
    removeImage: function(key) {
        delete this._images[key];
    },
    removeSound: function(key) {
        delete this._sounds[key];
    },
    removeText: function(key) {
        delete this._text[key];
    },
    destroy: function() {
        this._canvases = {};
        this._images = {};
        this._sounds = {};
        this._text = {};
        this._tilemaps = {};
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('utils/Clock',['require', 'exports', 'module', './inherit'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("./inherit");

var Clock = module.exports = function() {
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
    this.timer = window.performance && window.performance.now ? window.performance : Date;
};

inherit(Clock, Object, {
    now: function() {
        return this.timer.now();
    },
    start: function() {
        this.startTime = this.oldTime = this.now();
        this.running = true;
    },
    stop: function() {
        this.getElapsedTime();
        this.running = false;
    },
    reset: function() {
        this.elapsedTime = 0;
        this.startTime = this.oldTime = this.now();
    },
    getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
    },
    getDelta: function() {
        var diff = 0;
        if (this.running) {
            var newTime = this.now();
            diff = .001 * (newTime - this.oldTime);
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('utils/SpritePool',['require', 'exports', 'module', './inherit', '../display/Sprite'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("./inherit"), Sprite = require("../display/Sprite");

var SpritePool = module.exports = function(game) {
    this.types = {};
    this.game = game;
    this.add("_default", Sprite);
};

inherit(SpritePool, Object, {
    add: function(name, obj) {
        return this.types[name] = obj;
    },
    has: function(name) {
        return !!this.types[name];
    },
    create: function(name, texture, props) {
        if (!name || !this.types[name]) name = "_default";
        return new this.types[name](texture, props);
    },
    free: function() {
        return;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('loader/Loader',['require', 'exports', 'module', '../utils/utils', '../utils/inherit', '../utils/support', '../utils/EventEmitter', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var utils = require("../utils/utils"), inherit = require("../utils/inherit"), support = require("../utils/support"), EventEmitter = require("../utils/EventEmitter"), C = require("../constants");

var AssetLoader = module.exports = function(game) {
    EventEmitter.call(this);
    this.game = game;
    this.keys = [];
    this.assets = {};
    this.total = 0;
    this.done = 0;
    this.isLoading = false;
    this.hasLoaded = false;
    this.progress = 0;
    this.crossOrigin = "";
    this.baseUrl = "";
};

inherit(AssetLoader, Object, {
    hasKey: function(key) {
        return !!this.assets[key];
    },
    reset: function() {
        this.progress = 0;
        this.total = 0;
        this.done = 0;
        this.hasLoaded = false;
        this.isLoading = false;
        this.assets = {};
        this.keys.length = 0;
    },
    add: function(type, key, url, opts) {
        var entry = {
            type: type,
            key: key,
            url: url,
            image: null,
            data: null,
            error: false,
            loaded: false
        };
        if (opts !== undefined) {
            for (var p in opts) {
                entry[p] = opts[p];
            }
        }
        this.assets[key] = entry;
        this.keys.push(key);
        this.total++;
    },
    image: function(key, url, overwrite) {
        if (overwrite || !this.hasKey(key)) this.add("image", key, url);
    },
    text: function(key, url, overwrite) {
        if (overwrite || !this.hasKey(key)) this.add("text", key, url);
    },
    spritesheet: function(key, url, frameWidth, frameHeight, numFrames, overwrite) {
        if (overwrite || !this.hasKey(key)) this.add("spritesheet", key, url, {
            frameWidth: frameWidth,
            frameHeight: frameHeight,
            numFrames: numFrames
        });
    },
    audio: function(key, urls, overwrite) {
        if (overwrite || !this.hasKey(key)) this.add("audio", key, urls);
    },
    tilemap: function(key, url, data, format, overwrite) {
        if (overwrite || !this.hasKey(key)) {
            if (!format) format = C.FILE_FORMAT.JSON;
            if (typeof data === "string") {
                switch (format) {
                  case C.FILE_FORMAT.JSON:
                    data = JSON.parse(data);
                    break;
                  case C.FILE_FORMAT.XML:
                    data = C.utils.parseXML(data);
                    break;
                  case C.FILE_FORMAT.CSV:
                    break;
                }
            }
            this.add("tilemap", key, url, {
                data: data,
                format: format
            });
        }
    },
    bitmapFont: function(key, textureUrl, dataUrl, data, format, overwrite) {
        if (overwrite || !this.hasKey(key)) {
            if (!format) format = C.FILE_FORMAT.XML;
            if (typeof data === "string") {
                switch (format) {
                  case C.FILE_FORMAT.XML:
                    data = utils.parseXML(data);
                    break;
                  case C.FILE_FORMAT.JSON:
                    data = JSON.parse(data);
                    break;
                }
            }
            this.add("bitmapfont", key, textureUrl, {
                dataUrl: dataUrl,
                data: data,
                format: format
            });
        }
    },
    atlasJSONArray: function(key, textureURL, atlasURL, atlasData) {
        this.atlas(key, textureURL, atlasURL, atlasData, C.ATLAS_FORMAT.JSON_ARRAY);
    },
    atlasJSONHash: function(key, textureURL, atlasURL, atlasData) {
        this.atlas(key, textureURL, atlasURL, atlasData, C.ATLAS_FORMAT.JSON_HASH);
    },
    atlasXML: function(key, textureURL, atlasURL, atlasData) {
        this.atlas(key, textureURL, atlasURL, atlasData, C.ATLAS_FORMAT.STARLING_XML);
    },
    atlas: function(key, textureUrl, dataUrl, data, format, overwrite) {
        if (overwrite || !this.hasKey(key)) {
            if (!format) format = C.ATLAS_FORMAT.JSON_ARRAY;
            if (typeof data === "string") {
                switch (format) {
                  case C.ATLAS_FORMAT.STARLING_XML:
                    data = utils.parseXML(data);
                    break;
                  case C.ATLAS_FORMAT.JSON_ARRAY:
                  case C.ATLAS_FORMAT.JSON_HASH:
                    data = JSON.parse(data);
                    break;
                }
            }
            this.add("textureatlas", key, textureUrl, {
                dataUrl: dataUrl,
                data: data,
                format: format
            });
        }
    },
    start: function() {
        if (this.isLoading) return;
        this.progress = 0;
        this.hasLoaded = false;
        this.isLoading = true;
        this.emit("start", this.keys.length);
        if (this.keys.length > 0) {
            while (this.keys.length > 0) this.loadFile();
        } else {
            this.progress = 100;
            this.hasLoaded = true;
            this.emit("complete");
        }
    },
    loadFile: function() {
        var file = this.assets[this.keys.shift()], self = this;
        switch (file.type) {
          case "image":
          case "spritesheet":
          case "textureatlas":
          case "bitmapfont":
            file.image = new Image;
            file.image.name = file.key;
            file.image.addEventListener("load", this.fileComplete.bind(this, file.key), false);
            file.image.addEventListener("error", this.fileError.bind(this, file.key), false);
            file.image.crossOrigin = file.crossOrigin !== undefined ? file.crossOrigin : this.crossOrigin;
            file.image.src = this.baseUrl + file.url;
            break;
          case "tilemap":
            utils.ajax({
                url: this.baseUrl + file.url,
                dataType: this._getFormatAjaxType(file.format),
                load: function(data) {
                    file.data = data;
                    self.fileComplete(file.key);
                },
                error: function(err) {
                    self.fileError(file.key, err);
                }
            });
            break;
          case "audio":
            file.url = this.getAudioURL(file.url);
            if (file.url) {
                if (support.webAudio) {
                    utils.ajax({
                        url: this.baseURL + file.url,
                        dataType: "arraybuffer",
                        load: function(data) {
                            file.data = data;
                            self.fileComplete(file.key);
                        },
                        error: function(err) {
                            self.fileError(file.key, err);
                        }
                    });
                } else if (support.htmlAudio) {
                    file.data = new Audio;
                    file.data.name = file.key;
                    file.data.preload = "auto";
                    file.data.src = this.baseUrl + file.url;
                    file.data.addEventListener("error", file._bndError = this.fileError.bind(this, file.key), false);
                    file.data.addEventListener("canplaythrough", file._bndComplete = this.fileComplete.bind(this, file.key), false);
                    file.data.load();
                }
            } else {
                this.fileError(file.key, "No supported audio URL could be determined!");
            }
            break;
          case "text":
            utils.ajax({
                url: this.baseURL + file.url,
                dataType: "text",
                load: function(data) {
                    file.data = data;
                    self.fileComplete(file.key);
                },
                error: function(err) {
                    self.fileError(file.key, err);
                }
            });
            break;
        }
    },
    getAudioUrl: function(urls) {
        for (var i = 0, il = urls.length; i < il; ++i) {
            var url = urls[i], ext = url.match(/.+\.([^?]+)(\?|$)/);
            ext = ext && ext.length >= 2 ? ext[1] : url.match(/data\:audio\/([^?]+);/)[1];
            if (support.codec[ext]) {
                return url;
            }
        }
    },
    fileError: function(key, error) {
        this.assets[key].loaded = true;
        this.assets[key].error = true;
        this.emit("error", key);
        utils.warn('Error loading file "' + key + '", error received:', error);
        this.fileDone(key, true);
    },
    fileComplete: function(key) {
        if (!this.assets[key]) return utils.warn("fileComplete key is invalid!", key);
        this.assets[key].loaded = true;
        var file = this.assets[key], done = true, self = this;
        switch (file.type) {
          case "image":
            this.game.cache.addImage(file);
            break;
          case "spritesheet":
            this.game.cache.addSpriteSheet(file);
            break;
          case "tilemap":
            file.baseUrl = file.url.replace(/[^\/]*$/, "");
            file.numImages = file.numLoaded = 0;
            file.images = [];
            if (file.format === C.FILE_FORMAT.JSON) {
                done = false;
                this._loadJsonTilesets(file);
            } else if (file.format === C.FILE_FORMAT.XML) {
                done = false;
                this._loadXmlTilesets(file);
            }
            break;
          case "textureatlas":
            done = false;
            this._dataget(file, function() {
                self.game.cache.addTextureAtlas(file);
            });
            break;
          case "bitmapfont":
            done = false;
            this._dataget(file, function() {
                self.game.cache.addBitmapFont(file);
            });
            break;
          case "audio":
            if (support.webAudio) {
                file.webAudio = true;
                file.decoded = false;
            } else {
                file.data.removeEventListener("error", file._bndError);
                file.data.removeEventListener("canplaythrough", file._bndComplete);
            }
            this.game.cache.addAudio(file);
            break;
          case "text":
            this.game.cache.addText(file);
            break;
        }
        if (done) {
            this.fileDone(file.key);
        }
    },
    fileDone: function(key, fail) {
        this.done++;
        this.progress = Math.round(this.done / this.total * 100);
        if (fail) {
            this.emit("error", key);
        }
        if (this.progress >= 100) {
            this.progress = 100;
            this.hasLoaded = true;
            this.isLoading = false;
            this.emit("complete");
        }
    },
    _getFormatAjaxType: function(type) {
        switch (type) {
          case C.ATLAS_FORMAT.JSON_ARRAY:
          case C.ATLAS_FORMAT.JSON_HASH:
          case C.FILE_FORMAT.JSON:
            return "json";
          case C.ATLAS_FORMAT.STARLING_XML:
          case C.FILE_FORMAT.XML:
            return "xml";
          case C.FILE_FORMAT.CSV:
            return "text";
        }
    },
    _dataget: function(file, cb) {
        var self = this;
        if (!file.dataUrl) {
            setTimeout(cb);
        } else {
            utils.ajax({
                url: this.baseUrl + file.dataUrl,
                dataType: this._getFormatAjaxType(file.format),
                load: function(data) {
                    file.data = data;
                    if (cb) cb();
                    self.fileDone(file.key);
                },
                error: function(err) {
                    self.fileError(file.key, err);
                }
            });
        }
    },
    _loadJsonTilesets: function(file) {
        var data = file.data, baseUrl = file.baseUrl;
        for (var i = 0, il = data.tilesets.length; i < il; ++i) {
            var set = data.tilesets[i], img;
            if (!set.image) continue;
            file.numImages++;
            img = new Image;
            img.addEventListener("load", this._onTilesetLoaded.bind(this, file), false);
            img.addEventListener("error", this._onTilesetError.bind(this, file), false);
            img.crossOrigin = file.crossOrigin !== undefined ? file.crossOrigin : this.crossOrigin;
            img.src = this.baseUrl + baseUrl + set.image;
            file.images.push(img);
        }
    },
    _loadXmlTilesets: function(file) {
        var data = file.data, baseUrl = file.baseUrl, tilesets = data.getElementsByTagName("tileset");
        for (var i = 0, il = tilesets.length; i < il; ++i) {
            var set = tilesets[i], imgElm = set.getElementsByTagName("image")[0], img;
            if (!imgElm) continue;
            file.numImages++;
            img = new Image;
            img.addEventListener("load", this._onTilesetLoaded.bind(this, file), false);
            img.addEventListener("error", this._onTilesetError.bind(this, file), false);
            img.crossOrigin = file.crossOrigin !== undefined ? file.crossOrigin : this.crossOrigin;
            img.src = this.baseUrl + baseUrl + imgElm.attributes.getNamedItem("source").nodeValue;
            file.images.push(img);
        }
    },
    _onTilesetLoaded: function(file) {
        file.numLoaded++;
        if (file.numImages === file.numLoaded) {
            this.game.cache.addTilemap(file);
            this.fileDone(file.key, file.error);
        }
    },
    _onTilesetError: function(file) {
        file.error = true;
        file.numLoaded++;
        if (file.numImages === file.numLoaded) {
            this.fileDone(file.key, file.error);
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('input/Input',['require', 'exports', 'module', '../utils/inherit', '../utils/EventEmitter'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), EventEmitter = require("../utils/EventEmitter");

var InputType = module.exports = function(view) {
    EventEmitter.call(this);
    this.bind = this.on;
    this.view = view;
};

inherit(InputType, Object, {
    preventDefault: function(e) {
        if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
        return false;
    },
    stopPropogation: function(e) {
        if (e.stopPropagation) e.stopPropagation(); else e.cancelBubble = true;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('input/Keyboard',['require', 'exports', 'module', '../utils/inherit', './Input'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), Input = require("./Input");

var Keyboard = module.exports = function(view) {
    Input.call(this, view);
    this.sequence = [];
    this.sequenceTimeout = 500;
    this._clearSq = null;
    view.addEventListener("keydown", this.onKeyDown.bind(this), false);
    view.addEventListener("keyup", this.onKeyUp.bind(this), false);
};

inherit(Keyboard, Input, {
    onKeyDown: function(e, override) {
        return this.modifyKey(e, override || e.keyCode || e.which, true);
    },
    onKeyUp: function(e, override) {
        return this.modifyKey(e, override || e.keyCode || e.which, false);
    },
    modifyKey: function(e, key, down) {
        this.emit(key, {
            input: this,
            originalEvent: e,
            down: down
        });
        if (down) {
            this.sequence.push(key);
            var s = this.sequence.toString();
            if (s !== key.toString()) {
                this.emit(s, {
                    input: this,
                    originalEvent: e,
                    down: down
                });
            }
            clearTimeout(this._clearSq);
            this._clearSq = setTimeout(this._clearSequence.bind(this), this.sequenceTimeout);
        }
    },
    _clearSequence: function() {
        this.sequence.length = 0;
    }
});

Keyboard.KEY = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    INSERT: 45,
    DELETE: 46,
    NUM0: 48,
    NUM1: 49,
    NUM2: 50,
    NUM3: 51,
    NUM4: 52,
    NUM5: 53,
    NUM6: 54,
    NUM7: 55,
    NUM8: 56,
    NUM9: 57,
    PLUS: 61,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    NUMPAD0: 96,
    NUMPAD1: 97,
    NUMPAD2: 98,
    NUMPAD3: 99,
    NUMPAD4: 100,
    NUMPAD5: 101,
    NUMPAD6: 102,
    NUMPAD7: 103,
    NUMPAD8: 104,
    NUMPAD9: 105,
    NUMPAD_STAR: 106,
    NUMPAD_PLUS: 107,
    NUMPAD_MINUS: 109,
    NUMPAD_DOT: 110,
    NUMPAD_SLASH: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    MINUS: 173,
    TILDE: 192
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('input/GamepadButtons',['require', 'exports', 'module', '../utils/inherit', './Input'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), Input = require("./Input");

var GamepadButtons = module.exports = function() {
    Input.call(this);
    this.threshold = .4;
    this.buttons = {};
    for (var bt in GamepadButtons.BUTTON) {
        this.buttons[GamepadButtons.BUTTON[bt]] = {
            code: GamepadButtons.BUTTON[bt],
            name: bt,
            down: false,
            value: 0
        };
    }
};

inherit(GamepadButtons, Input, {
    pollStatus: function(pad) {
        for (var b = 0, bl = pad.buttons.length; b < bl; ++b) {
            var down = pad.buttons[b] > this.threshold, status = this.buttons[b];
            status.value = pad.buttons[b];
            if (status.down !== down) {
                status.down = down;
                this.emit(b, status);
            }
        }
    }
});

GamepadButtons.BUTTON = {
    FACE_1: 0,
    FACE_2: 1,
    FACE_3: 2,
    FACE_4: 3,
    LEFT_SHOULDER: 4,
    RIGHT_SHOULDER: 5,
    LEFT_TRIGGER: 6,
    RIGHT_TRIGGER: 7,
    SELECT: 8,
    START: 9,
    LEFT_ANALOGUE_STICK: 10,
    RIGHT_ANALOGUE_STICK: 11,
    PAD_TOP: 12,
    PAD_BOTTOM: 13,
    PAD_LEFT: 14,
    PAD_RIGHT: 15,
    SYSTEM_MENU: 16
};

GamepadButtons.getGpButtonName = function(i) {
    for (var k in GamepadButtons.BUTTON) {
        if (GamepadButtons.BUTTON[k] === i) {
            return k;
        }
    }
    return "";
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('input/GamepadSticks',['require', 'exports', 'module', '../utils/inherit', './Input'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), Input = require("./Input");

var GamepadSticks = module.exports = function() {
    Input.call(this);
    this.threshold = .5;
    this.axes = {};
    for (var ax in GamepadSticks.AXIS) {
        this.axes[GamepadSticks.AXIS[ax]] = {
            code: GamepadSticks.AXIS[ax],
            name: ax,
            value: 0
        };
    }
};

inherit(GamepadSticks, Input, {
    pollStatus: function(pad) {
        for (var a = 0, al = pad.axes.length; a < al; ++a) {
            var ax = pad.axes[a], status = this.axes[a];
            if (Math.abs(ax) >= this.threshold) {
                status.value = ax;
            } else {
                status.value = 0;
            }
            this.emit(a, status);
        }
    }
});

GamepadSticks.AXIS = {
    LEFT_ANALOGUE_HOR: 0,
    LEFT_ANALOGUE_VERT: 1,
    RIGHT_ANALOGUE_HOR: 2,
    RIGHT_ANALOGUE_VERT: 3
};

GamepadSticks.getGpAxisName = function(i) {
    for (var k in GamepadSticks.AXIS) {
        if (GamepadSticks.AXIS[k] === i) {
            return k;
        }
    }
    return "";
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('input/Gamepad',['require', 'exports', 'module', '../utils/inherit', './Input', './GamepadButtons', './GamepadSticks'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), Input = require("./Input"), GamepadButtons = require("./GamepadButtons"), GamepadSticks = require("./GamepadSticks");

var Gamepad = module.exports = function() {
    Input.call(this);
    this.ticking = false;
    this.pads = [];
    this.prevTimestamps = [];
    this.buttons = new GamepadButtons;
    this.sticks = new GamepadSticks;
    window.addEventListener("MozGamepadConnected", this.onGamepadConnect.bind(this), false);
    window.addEventListener("MozGamepadDisconnected", this.onGamepadDisconnect.bind(this), false);
    if (!!navigator.webkitGamepads || !!navigator.webkitGetGamepads) {
        this.startPolling();
    }
};

inherit(Gamepad, Input, {
    onGamepadConnect: function(event) {
        this.pads.push(event.gamepad);
        this.startPolling();
    },
    onGamepadDisconnect: function(event) {
        for (var i = 0, il = this.pads.length; i < il; ++i) {
            if (this.pads[i].index === event.gamepad.index) {
                this.pads.splice(i, 1);
                break;
            }
        }
        if (this.pads.length === 0) this.stopPolling();
    },
    startPolling: function() {
        if (this.ticking) return;
        this.ticking = true;
        this.update();
    },
    stopPolling: function() {
        this.ticking = false;
    },
    pollGamepads: function() {
        var rawPads = navigator.webkitGetGamepads && navigator.webkitGetGamepads() || navigator.webkitGamepads;
        if (rawPads) {
            this.pads.length = 0;
            for (var i = 0, il = rawPads.length; i < il; ++i) {
                if (rawPads[i]) {
                    this.pads.push(rawPads[i]);
                }
            }
        }
    },
    pollStatus: function() {
        for (var i = 0, il = this.pads.length; i < il; ++i) {
            var pad = this.pads[i];
            if (pad.timestamp && pad.timestamp === this.prevTimestamps[i]) continue;
            this.prevTimestamps[i] = pad.timestamp;
            this.buttons.pollStatus(pad);
            this.sticks.pollStatus(pad);
        }
    },
    update: function() {
        if (!this.ticking) return;
        this.pollGamepads();
        this.pollStatus();
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('input/InputManager',['require', 'exports', 'module', '../utils/inherit', './Keyboard', './Gamepad'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var inherit = require("../utils/inherit"), Keyboard = require("./Keyboard"), Gamepad = require("./Gamepad");

var InputManager = module.exports = function(game) {
    this.game = game;
    this.canvas = game.canvas;
    this.keyboard = new Keyboard(this.canvas);
    this.gamepad = new Gamepad;
};

inherit(InputManager, Object, {
    update: function(dt) {
        this.gamepad.update(dt);
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('game/Game',['require', 'exports', 'module', './StateManager', '../utils/EventEmitter', '../utils/Cache', '../utils/Clock', '../utils/SpritePool', '../loader/Loader', '../input/InputManager', '../audio/AudioManager', '../utils/support', '../utils/inherit', '../vendor/pixi', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var StateManager = require("./StateManager"), EventEmitter = require("../utils/EventEmitter"), Cache = require("../utils/Cache"), Clock = require("../utils/Clock"), SpritePool = require("../utils/SpritePool"), Loader = require("../loader/Loader"), InputManager = require("../input/InputManager"), AudioManager = require("../audio/AudioManager"), support = require("../utils/support"), inherit = require("../utils/inherit"), PIXI = require("../vendor/pixi"), C = require("../constants");

var Game = module.exports = function(container, settings) {
    EventEmitter.call(this);
    settings = settings || {};
    settings.width = settings.width || 800;
    settings.height = settings.height || 600;
    settings.renderer = settings.renderer || C.RENDERER.AUTO;
    settings.transparent = settings.transparent || false;
    settings.background = settings.background || "#FFF";
    settings.antialias = settings.antialias !== undefined ? settings.antialias : true;
    settings.canvas = settings.canvas || null;
    this.container = typeof container === "string" ? document.getElementById(container) : container;
    if (!this.container) this.container = document.body;
    this.width = settings.width;
    this.height = settings.height;
    this.renderMethod = settings.renderer;
    this.transparent = settings.transparent;
    this.background = settings.background;
    this.antialias = settings.antialias;
    this.canvas = settings.canvas;
    this.renderer = this._createRenderer();
    this.stage = new PIXI.Stage(this.background, this.interactive);
    this.clock = new Clock;
    this.audio = new AudioManager(this);
    this.load = new Loader(this);
    this.cache = new Cache(this);
    this.input = new InputManager(this);
    this.spritepool = new SpritePool(this);
    this.state = new StateManager(this);
    this.timings = {};
    var view = this.canvas;
    if (!view.getAttribute("tabindex")) view.setAttribute("tabindex", "1");
    view.focus();
    view.addEventListener("click", function() {
        view.focus();
    }, false);
};

inherit(Game, Object, {
    _createRenderer: function() {
        var method = this.renderMethod, render = null;
        if (!support.webgl && !support.canvas) {
            throw "Neither WebGL nor Canvas is supported by this browser!";
        } else if ((method === C.RENDERER.WEBGL || method === C.RENDERER.AUTO) && support.webgl) {
            method = C.RENDERER.WEBGL;
            render = new PIXI.WebGLRenderer(this.width, this.height, this.canvas, this.transparent, this.antialias);
        } else if ((method === C.RENDERER.CANVAS || method === C.RENDERER.AUTO) && support.canvas) {
            method = C.RENDERER.CANVAS;
            render = new PIXI.CanvasRenderer(this.width, this.height, this.canvas, this.transparent);
        } else {
            throw 'Your render method ("' + method + '") is not supported by this browser!';
        }
        if (!this.canvas) {
            this.container.appendChild(render.view);
            this.canvas = render.view;
        }
        return render;
    },
    resize: function(w, h) {
        this.renderer.resize(w, h);
        this.width = w;
        this.height = h;
        for (var i = 0, il = this.stage.children.length; i < il; ++i) {
            var o = this.stage.children[i];
            if (o.resize) o.resize(w, h);
        }
        return this;
    },
    requestFullscreen: function() {
        var elem = this.renderer.view;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        }
        return this;
    },
    render: function() {
        this.clock.start();
        this._tick();
        return this;
    },
    _tick: function() {
        window.requestAnimFrame(this._tick.bind(this));
        var dt = this.clock.getDelta();
        this.timings.lastDelta = dt;
        this.timings.inputStart = this.clock.now();
        this.input.update(dt);
        this.timings.inputEnd = this.clock.now();
        this.timings.userFuncsStart = this.clock.now();
        this.emit("tick", dt);
        this.timings.userFuncsEnd = this.clock.now();
        this.timings.stateStart = this.clock.now();
        this.state.active.update(dt);
        this.timings.stateEnd = this.clock.now();
        this.timings.renderStart = this.clock.now();
        this.renderer.render(this.stage);
        this.timings.renderEnd = this.clock.now();
    }
});

Object.defineProperty(Game.prototype, "camera", {
    get: function() {
        return this.state.active.camera;
    }
});

Object.defineProperty(Game.prototype, "world", {
    get: function() {
        return this.state.active.world;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('tilemap/Tile',['require', 'exports', 'module', '../display/Sprite', '../utils/inherit', '../constants'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Sprite = require("../display/Sprite"), inherit = require("../utils/inherit"), C = require("../constants");

var Tile = module.exports = function(texture) {
    this.collisionType = C.COLLISION_TYPE.NONE;
    Sprite.call(this, texture);
    this.type = Sprite.TYPE.TILE;
};

inherit(Tile, Sprite, {
    onCollision: function(obj) {
        Sprite.prototype.onCollision.call(this, obj);
        switch (this.collisionType) {
          case C.COLLISION_TYPE.SOLID:
            obj.setVelocity(0);
            break;
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core.js',['require', 'exports', 'module', './audio/AudioManager', './audio/AudioPlayer', './camera/Camera', './display/BaseTexture', './display/Texture', './display/Container', './display/Sprite', './display/AnimatedSprite', './text/BitmapText', './fx/camera/Effect', './fx/camera/Close', './fx/camera/Fade', './fx/camera/Flash', './fx/camera/Scanlines', './fx/camera/Shake', './game/Game', './game/State', './game/StateManager', './gui/GuiItem', './input/Input', './input/InputManager', './input/Keyboard', './input/Gamepad', './input/GamepadButtons', './input/GamepadSticks', './loader/Loader', './tilemap/Tile', './tilemap/Tilelayer', './tilemap/Tilemap', './tilemap/Tileset', './tilemap/ObjectGroup', './math/math', './math/Circle', './math/Ellipse', './math/Polygon', './math/Rectangle', './math/Vector', './physics/Physics', './physics/Body', './utils/utils', './utils/support', './utils/inherit', './utils/Cache', './utils/Clock', './utils/EventEmitter', './utils/ObjectPool', './utils/SpritePool', './utils/ObjectFactory', './vendor/pixi', './constants'], 
  function (require, exports, module) {
  var __umodule = (function (require, exports, module) {
  // uRequire: start body of original nodejs module
({
    urequire: {
        rootExports: "gf"
    }
});

module.exports = {
    AudioManager: require("./audio/AudioManager"),
    AudioPlayer: require("./audio/AudioPlayer"),
    Camera: require("./camera/Camera"),
    BaseTexture: require("./display/BaseTexture"),
    Texture: require("./display/Texture"),
    Container: require("./display/Container"),
    Sprite: require("./display/Sprite"),
    AnimatedSprite: require("./display/AnimatedSprite"),
    BitmapText: require("./text/BitmapText"),
    fx: {
        camera: {
            Effect: require("./fx/camera/Effect"),
            Close: require("./fx/camera/Close"),
            Fade: require("./fx/camera/Fade"),
            Flash: require("./fx/camera/Flash"),
            Scanlines: require("./fx/camera/Scanlines"),
            Shake: require("./fx/camera/Shake")
        }
    },
    Game: require("./game/Game"),
    State: require("./game/State"),
    StateManager: require("./game/StateManager"),
    GuiItem: require("./gui/GuiItem"),
    Input: require("./input/Input"),
    InputManager: require("./input/InputManager"),
    Keyboard: require("./input/Keyboard"),
    Gamepad: require("./input/Gamepad"),
    GamepadButtons: require("./input/GamepadButtons"),
    GamepadSticks: require("./input/GamepadSticks"),
    Loader: require("./loader/Loader"),
    Tile: require("./tilemap/Tile"),
    Tilelayer: require("./tilemap/Tilelayer"),
    Tilemap: require("./tilemap/Tilemap"),
    Tileset: require("./tilemap/Tileset"),
    ObjectGroup: require("./tilemap/ObjectGroup"),
    math: require("./math/math"),
    Circle: require("./math/Circle"),
    Ellipse: require("./math/Ellipse"),
    Polygon: require("./math/Polygon"),
    Rectangle: require("./math/Rectangle"),
    Vector: require("./math/Vector"),
    Physics: require("./physics/Physics"),
    Body: require("./physics/Body"),
    utils: require("./utils/utils"),
    support: require("./utils/support"),
    inherit: require("./utils/inherit"),
    Cache: require("./utils/Cache"),
    Clock: require("./utils/Clock"),
    EventEmitter: require("./utils/EventEmitter"),
    ObjectPool: require("./utils/ObjectPool"),
    SpritePool: require("./utils/SpritePool"),
    ObjectFactory: require("./utils/ObjectFactory"),
    PIXI: require("./vendor/pixi")
};

var C = require("./constants");

for (var k in C) {
    module.exports[k] = C[k];
}
// uRequire: end body of original nodejs module


return module.exports;
})(require, exports, module);


window.gf = __umodule;

return __umodule;
}
);
})(__global);

      return require('core.js');
  };

  if (__isAMD) {
      define([], factory);
  } else {
      if (__isNode) {
          module.exports = factory();
      } else {
          factory();
      }
  }
})();